<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>Quantum-Cascade N-Back ‚Äî Maximum G-Load (5 Words)</title>
<style>
:root { --bg:#0b0d10; --fg:#e6fbff; --a:#00ccff; --mut:#8fe7ff }
*{ box-sizing:border-box }
html,body{ height:100% }
body{ margin:0; background:#0b0d10; color:#e6fbff; font-family:system-ui,-apple-system,Segoe UI,Roboto,sans-serif }
.wrap{ max-width:1280px; margin:0 auto; padding:16px }
.row{ display:flex; gap:12px; flex-wrap:wrap }
.col{ flex:1 1 360px }
.box{ background:#101418; border:1px solid rgba(0,200,255,.25); border-radius:14px; padding:12px }
.title{ font-weight:800; margin-bottom:6px; letter-spacing:.3px }
.btn{ background:#0b0d10; color:#00ccff; border:1px solid #00ccff; border-radius:10px; padding:10px 14px; font-weight:700; cursor:pointer }
.btn:disabled{ opacity:.5; cursor:not-allowed }
label{ font-size:12px; color:#8fe7ff; display:block; margin:6px 0 }
input[type=range], input[type=number]{ width:100% }
.kbd{ border:1px solid rgba(255,255,255,.25); padding:2px 6px; border-radius:6px; background:#0b0d10 }
.mut{ color:#8fe7ff; font-size:12px }
hr.hr{border:none;border-top:1px solid rgba(0,200,255,.25);margin:8px 0}
#premiseContainer{ margin-top:12px; min-height:140px; background:#0e1113; border:1px solid rgba(0,200,255,.25); border-radius:12px; padding:16px; font-size:32px; line-height:2.2; word-break:break-word; font-family:'Courier New',monospace; font-weight:900; letter-spacing:2px }
.premise-line{ margin:16px 0; padding:18px; border-left:8px solid rgba(0,200,255,.8); background:linear-gradient(90deg, rgba(0,200,255,.25), rgba(0,200,255,.05)); border-radius:6px; position:relative }
.premise-number{ position:absolute; left:-45px; top:50%; transform:translateY(-50%); color:#00ccff; font-size:22px; font-weight:bold }
.badge{ display:inline-block; padding:2px 8px; border:1px solid rgba(0,200,255,.35); border-radius:999px; font-size:12px; color:#8fe7ff; margin-left:6px }
#countdown{ font-weight:800; color:#00ccff }
.entity{ color:#ff6b6b; text-shadow:0 0 16px rgba(255,107,107,.9) }
.operation{ color:#4ecdc4; text-shadow:0 0 14px rgba(78,205,196,.9) }
.mediator{ color:#a55eea; font-weight:900; text-shadow:0 0 18px rgba(165,94,234,1) }
.slash{ color:#ff9ff3; font-weight:900; font-size:120% }
.compound{ color:#00d2d3; text-decoration:underline; text-shadow:0 0 12px rgba(0,210,211,.8) }
.meta-info{ font-size:14px; color:#4a8aff; margin-top:14px; opacity:0.9; font-weight:normal }
</style>
</head>
<body>
<div class="wrap">
  <div class="row">
    <div class="col">
      <div class="box">
        <div class="title">Configuration</div>
        <div class="mut" style="margin-bottom:10px">
          <strong>Difficulty: Quantum-Cascade</strong><br>
          G-Load: ~0.95+ | Max 5 words
        </div>
        <hr class="hr">
        <label>N-Back level: <span id="nVal">1</span></label>
        <input id="nback" type="range" min="1" max="5" step="1" value="1">
        <hr class="hr">
        <label>Statements per trial: <span id="stmtVal">1</span></label>
        <input id="statements" type="range" min="1" max="5" step="1" value="1">
        <div class="mut small">Multiple statements create cascading transformations</div>
      </div>
    </div>

    <div class="col">
      <div class="box">
        <div class="title">Timing & Block</div>
        <div class="mut">Solve window: <strong><span id="solveLabel">5.0</span>s</strong> after speaking.</div>
        <label>Solve window (1‚Äì30s): <span id="solveVal">5.0s</span></label>
        <input id="solveWindow" type="range" min="1" max="30" step="0.1" value="5">
        <label>Trials per block: <span id="tVal">200</span></label>
        <input id="trials" type="range" min="20" max="500" step="10" value="200">
        <label>Target match rate: <span id="rVal">25%</span></label>
        <input id="rate" type="range" min="0" max="100" step="1" value="25">
        <label><input id="speakEnabled" type="checkbox" checked> Speak sentences</label>
      </div>
    </div>

    <div class="col">
      <div class="box">
        <div class="title">Controls / Status</div>
        <div style="display:flex; gap:8px; flex-wrap:wrap; margin-top:6px">
          <button id="start" class="btn">‚ñ∂ Start</button>
          <button id="pause" class="btn" disabled>‚è∏ Pause</button>
          <button id="reset" class="btn" disabled>üîÑ Reset</button>
          <button id="hit" class="btn" disabled>‚úì Match (<span class="kbd">Space</span>)</button>
          <button id="skip" class="btn" disabled>‚è≠ Skip</button>
        </div>
        <div class="mut" style="margin-top:8px">
          Trial <span id="idx">0</span>/<span id="max">200</span>
          <span class="badge">Planned: <span id="ptype">‚Äî</span></span>
          <span class="badge">Actual: <span id="isMatch">‚Äî</span></span>
          <span class="badge">Countdown: <span id="countdown">‚Äî</span></span>
        </div>
        <div class="mut">Correct: <span id="corr">0</span> ‚Ä¢ Errors: <span id="err">0</span></div>
      </div>
    </div>
  </div>

  <div class="box" style="margin-top:12px">
    <div class="title">Quantum-Cascade Premise <span class="badge">‚â§5 words</span> <span class="badge">0.95+ g-load</span></div>
    <div id="premiseContainer" aria-live="polite">‚Äî</div>
  </div>
</div>

<script>
/* ============================================================
   QUANTUM-CASCADE N-BACK
   Maximum g-load in ‚â§5 words
   True randomization, no repetition
   ============================================================ */

const $ = id => document.getElementById(id);
function setText(id,v){ const el=$(id); if(el) el.textContent=v; }
function shuffle(a){ for(let i=a.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [a[i],a[j]]=[a[j],a[i]] } return a; }

/* ===== QUANTUM-CASCADE GENERATOR ===== */
class QuantumCascadeGenerator {
    constructor() {
        // Dynamic entity pools - rotated to prevent repetition
        this.entitySets = [
            // Set 1: Greek letters
            ['ALPHA', 'BETA', 'GAMMA', 'DELTA', 'EPSILON', 'ZETA', 'ETA', 'THETA'],
            // Set 2: Mathematical
            ['VERTEX', 'EDGE', 'NODE', 'GRAPH', 'TREE', 'MESH', 'GRID', 'PATH'],
            // Set 3: Trigonometric
            ['SINE', 'COSINE', 'TANGENT', 'WAVE', 'PHASE', 'CYCLE', 'FREQ', 'AMP'],
            // Set 4: Quantum
            ['QUARK', 'LEPTON', 'BOSON', 'PHOTON', 'GLUON', 'MESON', 'HADRON', 'FERMION'],
            // Set 5: Elements
            ['FIRE', 'WATER', 'EARTH', 'AIR', 'VOID', 'ETHER', 'PLASMA', 'FLUX'],
            // Set 6: Colors
            ['RED', 'BLUE', 'GREEN', 'GOLD', 'SILVER', 'BLACK', 'WHITE', 'VIOLET'],
            // Set 7: Numbers
            ['ONE', 'TWO', 'THREE', 'FOUR', 'FIVE', 'SIX', 'SEVEN', 'EIGHT'],
            // Set 8: Abstract
            ['LIGHT', 'SHADOW', 'STREAM', 'PULSE', 'ECHO', 'MIRROR', 'PRISM', 'LENS'],
            // Set 9: Cosmic
            ['STAR', 'NOVA', 'NEBULA', 'COMET', 'ORBIT', 'GALAXY', 'COSMOS', 'QUASAR'],
            // Set 10: Logic
            ['TRUE', 'FALSE', 'NULL', 'BOTH', 'NEITHER', 'ALL', 'NONE', 'ANY']
        ];

        // Operation variants - never repeat within 20 trials
        this.operationSets = [
            ['folds', 'creases', 'bends', 'warps', 'curves', 'flexes', 'buckles', 'crimps'],
            ['spirals', 'helixes', 'coils', 'twists', 'winds', 'gyres', 'vortexes', 'swirls'],
            ['accelerates', 'quickens', 'hastens', 'rushes', 'surges', 'boosts', 'propels', 'speeds'],
            ['merges', 'fuses', 'blends', 'unites', 'combines', 'joins', 'bonds', 'melds'],
            ['splits', 'divides', 'fractures', 'segments', 'fragments', 'breaks', 'cleaves', 'parts'],
            ['inverts', 'reverses', 'flips', 'mirrors', 'reflects', 'echoes', 'bounces', 'returns'],
            ['expands', 'grows', 'swells', 'inflates', 'enlarges', 'extends', 'spreads', 'widens'],
            ['contracts', 'shrinks', 'compresses', 'condenses', 'reduces', 'narrows', 'tightens', 'constricts']
        ];

        // Mediators - evolve every 5 trials
        this.mediatorSets = [
            ['TOPAZ', 'RUBY', 'EMERALD', 'SAPPHIRE', 'DIAMOND'],
            ['GOLD', 'SILVER', 'COPPER', 'IRON', 'MERCURY'],
            ['CHAOS', 'ORDER', 'ENTROPY', 'HARMONY', 'BALANCE'],
            ['NEXUS', 'PORTAL', 'GATEWAY', 'BRIDGE', 'TUNNEL'],
            ['CRYSTAL', 'PRISM', 'LENS', 'MIRROR', 'GLASS']
        ];

        // Track usage to ensure novelty
        this.usedPremises = new Set();
        this.recentEntities = [];
        this.recentOperations = [];
        this.trialCount = 0;
        this.currentEntitySet = 0;
        this.currentOpSet = 0;
        this.currentMediatorSet = 0;
    }

    generatePremise(difficulty, trial, nback, count = 1) {
        this.trialCount = trial;
        const premises = [];
        
        // Rotate pools to ensure variety
        if (trial % 3 === 0) {
            this.currentEntitySet = Math.floor(Math.random() * this.entitySets.length);
        }
        if (trial % 5 === 0) {
            this.currentOpSet = Math.floor(Math.random() * this.operationSets.length);
            this.currentMediatorSet = Math.floor(Math.random() * this.mediatorSets.length);
        }
        
        for (let i = 0; i < count; i++) {
            let premise;
            let attempts = 0;
            
            // Keep generating until we get a unique premise
            do {
                premise = this.buildQuantumPremise(trial + i + attempts);
                attempts++;
            } while (this.usedPremises.has(premise.text) && attempts < 50);
            
            this.usedPremises.add(premise.text);
            premises.push(premise);
            
            // Limit memory to prevent infinite growth
            if (this.usedPremises.size > 500) {
                const premiseArray = Array.from(this.usedPremises);
                this.usedPremises = new Set(premiseArray.slice(-250));
            }
        }
        
        return premises;
    }

    buildQuantumPremise(seed) {
        // Use true randomization with seed influence
        const r = () => Math.random();
        const pattern = Math.floor(r() * 6);
        
        let text = '';
        let structure = {};
        
        switch(pattern) {
            case 0: // [E1/E2] [compound-op] [E3/E4] [mediator]
                text = this.pattern1(r, seed);
                structure = {entities: 4, ops: 2, dims: 5};
                break;
            
            case 1: // [E1/E2/E3] [mega-op] [E4/E5]
                text = this.pattern2(r, seed);
                structure = {entities: 5, ops: 3, dims: 6};
                break;
            
            case 2: // [E1] [op1-op2] [E2] [op3] [mediator]
                text = this.pattern3(r, seed);
                structure = {entities: 3, ops: 3, dims: 5};
                break;
            
            case 3: // [E1/E2] [op] [E3/E4/E5]
                text = this.pattern4(r, seed);
                structure = {entities: 5, ops: 1, dims: 4};
                break;
            
            case 4: // [mega-op] [E1/E2] [E3] [mediator-mod]
                text = this.pattern5(r, seed);
                structure = {entities: 3, ops: 2, dims: 5};
                break;
            
            case 5: // [E1] [triple-op] [E2/E3] [mediator]
                text = this.pattern6(r, seed);
                structure = {entities: 3, ops: 3, dims: 6};
                break;
        }
        
        // Ensure exactly 5 words
        const words = text.split(' ');
        if (words.length > 5) {
            text = words.slice(0, 5).join(' ');
        }
        
        return {
            text: text,
            structure: structure,
            seed: seed
        };
    }

    pattern1(r, seed) {
        // [E1/E2] [compound-op] [E3/E4] [mediator]
        const e1 = this.getEntity(r);
        const e2 = this.getEntity(r);
        const op1 = this.getOp(r);
        const op2 = this.getOp(r);
        const e3 = this.getEntity(r);
        const e4 = this.getEntity(r);
        const med = this.getMediator(r);
        return `${e1}/${e2} ${op1}-${op2} ${e3}/${e4} ${med}`;
    }

    pattern2(r, seed) {
        // [E1/E2/E3] [mega-op] [E4/E5]
        const e1 = this.getEntity(r);
        const e2 = this.getEntity(r);
        const e3 = this.getEntity(r);
        const op1 = this.getOp(r);
        const op2 = this.getOp(r);
        const op3 = this.getOp(r);
        const e4 = this.getEntity(r);
        const e5 = this.getEntity(r);
        return `${e1}/${e2}/${e3} ${op1}-${op2}-${op3} ${e4}/${e5}`;
    }

    pattern3(r, seed) {
        // [E1] [op1-op2] [E2] [op3] [mediator]
        const e1 = this.getEntity(r);
        const op1 = this.getOp(r);
        const op2 = this.getOp(r);
        const e2 = this.getEntity(r);
        const op3 = this.getOp(r);
        const med = this.getMediator(r);
        return `${e1} ${op1}-${op2} ${e2} ${op3} ${med}`;
    }

    pattern4(r, seed) {
        // [E1/E2] [op] [E3/E4/E5]
        const e1 = this.getEntity(r);
        const e2 = this.getEntity(r);
        const op = this.getOp(r);
        const e3 = this.getEntity(r);
        const e4 = this.getEntity(r);
        const e5 = this.getEntity(r);
        return `${e1}/${e2} ${op} ${e3}/${e4}/${e5}`;
    }

    pattern5(r, seed) {
        // [mega-op] [E1/E2] [E3] [mediator-mod]
        const op1 = this.getOp(r);
        const op2 = this.getOp(r);
        const e1 = this.getEntity(r);
        const e2 = this.getEntity(r);
        const e3 = this.getEntity(r);
        const med = this.getMediator(r);
        const mod = ['twisting', 'cascading', 'echoing', 'inverting'][Math.floor(r() * 4)];
        return `${op1}-${op2} ${e1}/${e2} ${e3} ${med}-${mod}`;
    }

    pattern6(r, seed) {
        // [E1] [triple-op] [E2/E3] [mediator]
        const e1 = this.getEntity(r);
        const op1 = this.getOp(r);
        const op2 = this.getOp(r);
        const op3 = this.getOp(r);
        const e2 = this.getEntity(r);
        const e3 = this.getEntity(r);
        const med = this.getMediator(r);
        return `${e1} ${op1}-${op2}-${op3} ${e2}/${e3} ${med}`;
    }

    getEntity(r) {
        const pool = this.entitySets[this.currentEntitySet];
        const shuffled = shuffle([...pool]);
        
        // Avoid recent entities
        for (const entity of shuffled) {
            if (!this.recentEntities.includes(entity)) {
                this.recentEntities.push(entity);
                if (this.recentEntities.length > 10) {
                    this.recentEntities.shift();
                }
                return entity;
            }
        }
        
        // If all recent, just return random
        return shuffled[Math.floor(r() * shuffled.length)];
    }

    getOp(r) {
        const pool = this.operationSets[this.currentOpSet];
        const shuffled = shuffle([...pool]);
        
        // Avoid recent operations
        for (const op of shuffled) {
            if (!this.recentOperations.includes(op)) {
                this.recentOperations.push(op);
                if (this.recentOperations.length > 8) {
                    this.recentOperations.shift();
                }
                return op;
            }
        }
        
        return shuffled[Math.floor(r() * shuffled.length)];
    }

    getMediator(r) {
        const pool = this.mediatorSets[this.currentMediatorSet];
        return pool[Math.floor(r() * pool.length)];
    }

    // Check deep structure compatibility for n-back
    checkCompatibility(premises1, premises2, difficulty) {
        const struct1 = this.extractStructure(premises1);
        const struct2 = this.extractStructure(premises2);
        
        // Deep structure must match, surface must differ
        let structureMatch = 0;
        let surfaceDifference = 0;
        
        // Check structural similarity
        if (Math.abs(struct1.entityCount - struct2.entityCount) <= 1) structureMatch += 0.3;
        if (Math.abs(struct1.opCount - struct2.opCount) <= 1) structureMatch += 0.3;
        if (struct1.pattern === struct2.pattern) structureMatch += 0.4;
        
        // Check surface difference
        const tokens1 = new Set(premises1[0].text.split(/[\s\-\/]+/));
        const tokens2 = new Set(premises2[0].text.split(/[\s\-\/]+/));
        const overlap = [...tokens1].filter(t => tokens2.has(t)).length;
        surfaceDifference = 1 - (overlap / Math.max(tokens1.size, tokens2.size));
        
        // Match requires high structural similarity but high surface difference
        return structureMatch >= 0.7 && surfaceDifference >= 0.6;
    }

    extractStructure(premises) {
        const p = premises[0];
        const text = p.text || p;
        
        // Count entities (words with all caps)
        const entities = (text.match(/[A-Z]{2,}/g) || []).length;
        
        // Count operations (words with hyphens or lowercase)
        const ops = (text.match(/[a-z]+/g) || []).length;
        
        // Identify pattern type
        let pattern = 'unknown';
        if (text.match(/^[A-Z]+\/[A-Z]+/)) pattern = 'entity-first';
        else if (text.match(/^[a-z]+-[a-z]+/)) pattern = 'op-first';
        else pattern = 'mixed';
        
        return {
            entityCount: entities,
            opCount: ops,
            pattern: pattern
        };
    }
}

/* ===== Global state ===== */
const premiseGenerator = new QuantumCascadeGenerator();
let MAX=200, RATE=25, N=1, SPEAK=true, SOLVE_WINDOW=5.0, STATEMENTS=1;

/* ===== Session management ===== */
let idx=0, correct=0, errors=0, planned=[], history=[], SESSION={running:false, paused:false};
let currentTruth=false, responded=false, solveTimer=null, countdownTimer=null, countdownLeft=0;

function planSequence(){ 
  planned.length=MAX; 
  for(let i=0;i<MAX;i++) planned[i]=false; 
  const elig=[]; 
  for(let i=N;i<MAX;i++) elig.push(i); 
  const k=Math.round((RATE/100)*elig.length); 
  const selected = shuffle([...elig]).slice(0, k);
  for(const i of selected) planned[i]=true; 
}

function showPremises(premises) {
  const container = $('premiseContainer');
  container.innerHTML = '';
  
  const arr = Array.isArray(premises) ? premises : [premises];
  
  arr.forEach((p, i) => {
    const div = document.createElement('div');
    div.className = 'premise-line';
    
    if (arr.length > 1) {
      const num = document.createElement('span');
      num.className = 'premise-number';
      num.textContent = (i+1).toString();
      div.appendChild(num);
    }
    
    if (typeof p === 'object' && p.text) {
      let html = p.text;
      
      // Highlight slashes
      html = html.replace(/\//g, '<span class="slash">/</span>');
      
      // Highlight compound operations
      html = html.replace(/\b([a-z]+-[a-z]+(-[a-z]+)*)\b/g, '<span class="compound">$1</span>');
      
      // Highlight mediators with modifiers
      html = html.replace(/\b([A-Z]+-(twisting|cascading|echoing|inverting))\b/g, '<span class="mediator">$1</span>');
      
      // Highlight single mediators
      html = html.replace(/\b(TOPAZ|RUBY|EMERALD|SAPPHIRE|DIAMOND|GOLD|SILVER|COPPER|IRON|MERCURY|CHAOS|ORDER|ENTROPY|HARMONY|BALANCE|NEXUS|PORTAL|GATEWAY|BRIDGE|TUNNEL|CRYSTAL|PRISM|LENS|MIRROR|GLASS)\b/g, 
                         '<span class="mediator">$1</span>');
      
      // Highlight operations (not in compounds)
      if (!html.includes('compound')) {
        html = html.replace(/\b([a-z]{3,})\b/g, '<span class="operation">$1</span>');
      }
      
      // Highlight entities
      html = html.replace(/\b([A-Z]{2,})\b/g, (match) => {
        if (!html.includes(`>${match}<`)) {
          return `<span class="entity">${match}</span>`;
        }
        return match;
      });
      
      div.innerHTML = html;
      
      // Meta info
      if (p.structure) {
        const meta = document.createElement('div');
        meta.className = 'meta-info';
        const words = p.text.split(' ').length;
        meta.textContent = `[${words} words, ${p.structure.entities} entities, ${p.structure.ops} operations, ${p.structure.dims} dimensions]`;
        div.appendChild(meta);
      }
    } else {
      div.textContent = p;
    }
    
    container.appendChild(div);
  });
}

function updateUI(){ 
  setText('idx', idx); 
  setText('max', MAX); 
  setText('ptype', (idx<MAX && idx>=N && planned[idx])?'MATCH':'NON-match'); 
  setText('corr', correct); 
  setText('err', errors); 
  setText('isMatch','‚Äî'); 
}

async function speak(text){
  if(!SPEAK) return Promise.resolve();
  if(typeof window==='undefined'||!('speechSynthesis' in window)) return Promise.resolve();
  
  // Only speak the premise text, no introductions
  const speakText = Array.isArray(text) ? 
    text.map(p => p.text || p).join('. . . ') : // Pause between statements
    (text.text || text);
    
  return new Promise(res=>{ 
    try{ 
      const u=new SpeechSynthesisUtterance(speakText); 
      u.lang='en-GB'; 
      u.rate=0.6; // Very slow for ultra-dense content
      u.pitch=1.0; 
      u.volume=1.0; 
      u.onend=()=>res(); 
      u.onerror=()=>res(); 
      if(window.speechSynthesis.speaking) window.speechSynthesis.cancel(); 
      window.speechSynthesis.speak(u); 
    }catch{ 
      res(); 
    } 
  });
}

function scheduleCountdown(sec){ 
  countdownLeft=sec; 
  setText('countdown', countdownLeft.toFixed(1)+'s'); 
  if(countdownTimer) clearInterval(countdownTimer); 
  countdownTimer=setInterval(()=>{ 
    countdownLeft=Math.max(0,countdownLeft-0.1); 
    setText('countdown', countdownLeft.toFixed(1)+'s'); 
    if(countdownLeft<=0){ 
      clearInterval(countdownTimer); 
      countdownTimer=null; 
    } 
  },100); 
}

function evaluateAndAdvance(){ 
  const resp=responded, truth=currentTruth; 
  if(resp===truth) correct++; 
  else errors++; 
  setText('corr',correct); 
  setText('err',errors); 
  setText('isMatch', String(truth).toUpperCase()); 
  idx++; 
  if(idx>=MAX){ 
    stop(); 
    return; 
  } 
  runTrial(); 
}

function runTrial(){
  if(!SESSION.running || SESSION.paused) return;
  
  const mustMatch=(idx>=N)&&planned[idx];
  
  // Generate completely unique premises each trial
  const premises = premiseGenerator.generatePremise(1, idx, N, STATEMENTS);
  
  history[idx] = premises;
  showPremises(premises); 
  responded=false; 
  
  // Check compatibility for n-back
  if(idx >= N) {
    currentTruth = premiseGenerator.checkCompatibility(premises, history[idx-N], 1);
    
    // Override for planned matches
    if(mustMatch && !currentTruth) {
      currentTruth = true;
    } else if(!mustMatch && currentTruth) {
      // Allow some natural matches
      if(Math.random() > 0.3) currentTruth = false;
    }
  } else {
    currentTruth = false;
  }
  
  setText('isMatch','‚Äî'); 
  setText('ptype', (idx<MAX && idx>=N && planned[idx])?'MATCH':'NON-match');

  speak(premises).then(()=>{ 
    scheduleCountdown(SOLVE_WINDOW); 
    if(solveTimer) clearTimeout(solveTimer); 
    solveTimer=setTimeout(()=>{ 
      evaluateAndAdvance(); 
    }, SOLVE_WINDOW*1000); 
  });
}

/* Controls */
function start(){
  MAX=+$('trials').value||200; 
  RATE=+$('rate').value||25; 
  N=+$('nback').value||1; 
  STATEMENTS=+$('statements').value||1;
  SPEAK=!!$('speakEnabled').checked;
  SOLVE_WINDOW=+($('solveWindow').value||5); 
  setText('solveLabel', SOLVE_WINDOW.toFixed(1)); 
  setText('solveVal', SOLVE_WINDOW.toFixed(1)+'s');

  idx=0; 
  correct=0; 
  errors=0; 
  planned=[]; 
  history=[]; 
  
  // Reset premise generator for true randomization
  premiseGenerator.usedPremises.clear();
  premiseGenerator.recentEntities = [];
  premiseGenerator.recentOperations = [];
  
  planSequence(); 
  updateUI();
  SESSION.running=true; 
  SESSION.paused=false;
  $('pause').disabled=false; 
  $('reset').disabled=false; 
  $('hit').disabled=false; 
  $('skip').disabled=false;
  runTrial();
}

function stop(){ 
  SESSION.running=false; 
  SESSION.paused=false; 
  if(solveTimer) clearTimeout(solveTimer); 
  if(countdownTimer) clearInterval(countdownTimer); 
  setText('countdown','‚Äî'); 
  try{ 
    if(window.speechSynthesis) window.speechSynthesis.cancel(); 
  }catch{} 
}

function togglePause(){
  if(!SESSION.running) return;
  SESSION.paused=!SESSION.paused; 
  $('pause').textContent=SESSION.paused?'‚ñ∂ Resume':'‚è∏ Pause';
  if(SESSION.paused){ 
    if(solveTimer) clearTimeout(solveTimer); 
    if(countdownTimer) clearInterval(countdownTimer); 
    try{ 
      if(window.speechSynthesis) window.speechSynthesis.cancel(); 
    }catch{} 
  }
  else{
    scheduleCountdown(countdownLeft>0?countdownLeft:SOLVE_WINDOW);
    if(solveTimer) clearTimeout(solveTimer);
    solveTimer=setTimeout(()=>{ 
      evaluateAndAdvance(); 
    }, (countdownLeft>0?countdownLeft:SOLVE_WINDOW)*1000);
  }
}

function reset(){ 
  stop(); 
  
  // Clear generator state for new random premises
  premiseGenerator.usedPremises.clear();
  premiseGenerator.recentEntities = [];
  premiseGenerator.recentOperations = [];
  premiseGenerator.currentEntitySet = Math.floor(Math.random() * premiseGenerator.entitySets.length);
  premiseGenerator.currentOpSet = Math.floor(Math.random() * premiseGenerator.operationSets.length);
  
  $('premiseContainer').innerHTML='‚Äî'; 
  setText('idx',0); 
  setText('corr',0); 
  setText('err',0); 
  setText('ptype','‚Äî'); 
  setText('isMatch','‚Äî'); 
}

function registerHit(){ 
  if(!SESSION.running || SESSION.paused) return; 
  responded=true; 
}

function skip(){ 
  if(!SESSION.running || SESSION.paused) return; 
  if(solveTimer) clearTimeout(solveTimer); 
  if(countdownTimer) clearInterval(countdownTimer); 
  setText('countdown','‚Äî'); 
  evaluateAndAdvance(); 
}

/* Event bindings */
document.addEventListener('DOMContentLoaded', ()=>{
  const sw=$('solveWindow'); 
  const updateSW=()=>{ 
    const v=+sw.value; 
    setText('solveVal', v.toFixed(1)+'s'); 
    setText('solveLabel', v.toFixed(1)); 
  };
  updateSW(); 
  sw.oninput=e=>{ 
    if(!SESSION.running){ 
      updateSW(); 
    } 
  };
  
  $('nback').oninput=e=>{ 
    if(!SESSION.running){ 
      N=+e.target.value; 
      setText('nVal',N); 
    } 
  };
  
  $('statements').oninput=e=>{ 
    if(!SESSION.running){ 
      STATEMENTS=+e.target.value; 
      setText('stmtVal',STATEMENTS); 
    } 
  };
  
  $('trials').oninput=e=>{ 
    if(!SESSION.running){ 
      MAX=+e.target.value; 
      setText('tVal',MAX); 
      setText('max',MAX); 
    } 
  };
  
  $('rate').oninput=e=>{ 
    if(!SESSION.running){ 
      RATE=+e.target.value; 
      setText('rVal',RATE+'%'); 
    } 
  };
  
  $('speakEnabled').onchange=e=>{ 
    SPEAK=!!e.target.checked; 
  };

  $('start').onclick=start; 
  $('pause').onclick=togglePause; 
  $('reset').onclick=reset; 
  $('hit').onclick=registerHit; 
  $('skip').onclick=skip;
  
  window.addEventListener('keydown', e=>{ 
    if(!SESSION.running) return; 
    if(e.code==='Space'){ 
      registerHit(); 
      e.preventDefault(); 
    } 
  });

  setText('nVal',N); 
  setText('stmtVal',STATEMENTS);
  setText('tVal',MAX); 
  setText('rVal',RATE+'%');
  updateUI();
});
</script>
</body>
</html>
