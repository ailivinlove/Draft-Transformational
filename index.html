<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>Quantum Relational N-Back ‚Äî Maximum G-Load 0.95+</title>
<style>
:root { 
  --bg:#050507; 
  --panel:#0a0c0f;
  --fg:#e8f4f8; 
  --accent:#00d4ff; 
  --secondary:#8fe7ff;
  --success:#26de81;
  --error:#ff5555;
  --warning:#ffaa00;
  --glow:rgba(0,212,255,0.15);
}

* { box-sizing:border-box; margin:0; padding:0; }
html, body { height:100%; overflow-x:hidden; font-family:system-ui,-apple-system,sans-serif; }
body { 
  background:linear-gradient(135deg, var(--bg) 0%, #0a0a12 100%); 
  color:var(--fg);
}

.container { max-width:1320px; margin:0 auto; padding:20px; }
.grid { display:grid; grid-template-columns:repeat(auto-fit, minmax(380px, 1fr)); gap:20px; margin-bottom:20px; }

.panel { 
  background:var(--panel); 
  border:1px solid rgba(0,212,255,.2); 
  border-radius:12px; 
  padding:24px; 
  backdrop-filter:blur(10px);
  box-shadow:0 8px 32px rgba(0,0,0,0.4);
}

.panel-title { 
  font-weight:800; 
  margin-bottom:20px; 
  color:var(--accent);
  font-size:18px;
  letter-spacing:0.5px;
}

.btn { 
  background:var(--glow); 
  color:var(--accent); 
  border:1px solid var(--accent); 
  border-radius:8px; 
  padding:14px 24px; 
  font-weight:700; 
  cursor:pointer; 
  transition:all 0.3s;
  font-size:15px;
  letter-spacing:0.5px;
}
.btn:hover:not(:disabled) { 
  background:rgba(0,212,255,0.3); 
  transform:translateY(-2px);
  box-shadow:0 4px 20px rgba(0,212,255,.4);
}
.btn:disabled { opacity:0.3; cursor:not-allowed; }

.btn-instructions { 
  background:rgba(138,43,226,0.15); 
  border-color:#8a2be2; 
  color:#b19cd9;
}
.btn-instructions:hover { 
  background:rgba(138,43,226,0.3); 
}

label { 
  font-size:13px; 
  color:var(--secondary); 
  display:block; 
  margin:15px 0 8px 0;
  font-weight:600;
  text-transform:uppercase;
  letter-spacing:1px;
}

input[type=range] { 
  width:100%; 
  height:6px;
  background:rgba(0,212,255,0.1);
  border-radius:3px;
  outline:none;
  -webkit-appearance:none;
  margin-bottom:5px;
}
input[type=range]::-webkit-slider-thumb {
  -webkit-appearance:none;
  width:20px;
  height:20px;
  background:var(--accent);
  border-radius:50%;
  cursor:pointer;
  box-shadow:0 0 20px rgba(0,212,255,0.6);
}
input[type=range]::-moz-range-thumb {
  width:20px;
  height:20px;
  background:var(--accent);
  border-radius:50%;
  cursor:pointer;
  box-shadow:0 0 20px rgba(0,212,255,0.6);
}

.kbd { 
  display:inline-block;
  padding:5px 12px; 
  border-radius:6px; 
  background:rgba(0,0,0,0.6); 
  border:1px solid rgba(255,255,255,.4);
  font-size:13px;
  font-weight:bold;
  box-shadow:inset 0 -2px 0 rgba(0,0,0,0.4);
}

#premiseDisplay { 
  min-height:200px; 
  background:linear-gradient(135deg, rgba(10,12,15,0.98), rgba(15,18,22,0.98));
  border:2px solid rgba(0,212,255,.3); 
  border-radius:16px; 
  padding:40px; 
  font-size:38px; 
  line-height:1.8; 
  font-family:'Courier New',monospace; 
  font-weight:900; 
  letter-spacing:2px;
  position:relative;
  overflow:hidden;
  box-shadow:inset 0 0 50px rgba(0,212,255,0.05);
}

#premiseDisplay::before {
  content:'';
  position:absolute;
  top:-50%;
  left:-50%;
  width:200%;
  height:200%;
  background:radial-gradient(circle, rgba(0,212,255,0.03) 0%, transparent 60%);
  animation:rotate 45s linear infinite;
  pointer-events:none;
}

@keyframes rotate { from{transform:rotate(0deg)} to{transform:rotate(360deg)} }
@keyframes pulse { 0%,100%{opacity:1} 50%{opacity:0.85} }
@keyframes glow { 0%,100%{text-shadow:0 0 20px currentColor} 50%{text-shadow:0 0 30px currentColor} }

.premise-text { 
  padding:25px; 
  margin:15px 0;
  border-left:8px solid var(--accent); 
  background:linear-gradient(90deg, rgba(0,212,255,.08), transparent); 
  border-radius:8px; 
  animation:pulse 3s ease-in-out infinite;
  position:relative;
  z-index:1;
}

/* Advanced symbol styling for quantum packing */
.symbol-triple { 
  color:#ff6b6b; 
  text-shadow:0 0 20px rgba(255,107,107,.9);
  font-weight:900;
  animation:glow 2s ease-in-out infinite;
}
.symbol-pair { 
  color:#4ecdc4; 
  text-shadow:0 0 20px rgba(78,205,196,.9);
  font-weight:900;
}
.symbol-single { 
  color:#ffd700; 
  text-shadow:0 0 20px rgba(255,215,0,.9);
  font-weight:900;
}
.operation-compound { 
  color:#26de81; 
  font-style:italic;
  background:rgba(38,222,129,0.1);
  padding:2px 8px;
  border-radius:4px;
  text-decoration:underline dotted;
}
.relation-complex { 
  color:#b19cd9; 
  font-weight:900;
  text-shadow:0 0 15px rgba(177,156,217,.9);
}
.modifier { 
  color:#ff00ff; 
  font-weight:bold;
  text-transform:uppercase;
}
.numeric-constraint { 
  color:#00ffff; 
  text-shadow:0 0 20px rgba(0,255,255,.9);
  font-weight:900;
}

.feedback {
  margin-top:25px;
  padding:20px;
  border-radius:10px;
  font-size:18px;
  font-weight:600;
  animation:fadeIn 0.4s ease-out;
}
.feedback.correct {
  background:linear-gradient(135deg, rgba(38,222,129,0.2), rgba(38,222,129,0.1));
  border:2px solid var(--success);
  color:var(--success);
}
.feedback.incorrect {
  background:linear-gradient(135deg, rgba(255,85,85,0.2), rgba(255,85,85,0.1));
  border:2px solid var(--error);
  color:var(--error);
}
.feedback.missed {
  background:linear-gradient(135deg, rgba(255,170,0,0.2), rgba(255,170,0,0.1));
  border:2px solid var(--warning);
  color:var(--warning);
}

@keyframes fadeIn { from{opacity:0; transform:translateY(20px)} to{opacity:1; transform:translateY(0)} }

.status-row {
  display:flex;
  justify-content:space-between;
  margin:15px 0;
  padding:15px;
  background:rgba(0,0,0,0.3);
  border-radius:8px;
  border:1px solid rgba(0,212,255,0.1);
}

.status-item {
  font-size:15px;
  font-weight:600;
}
.status-value {
  color:var(--accent);
  font-weight:800;
}

/* Modal */
.modal {
  display:none;
  position:fixed;
  z-index:9999;
  left:0;
  top:0;
  width:100%;
  height:100%;
  background:rgba(0,0,0,0.95);
  backdrop-filter:blur(20px);
}

.modal-content {
  background:linear-gradient(135deg, #0a0c0f, #0f1215);
  margin:10px auto;
  padding:40px;
  border:2px solid var(--accent);
  border-radius:20px;
  width:95%;
  max-width:1000px;
  max-height:95vh;
  overflow-y:auto;
  box-shadow:0 0 60px rgba(0,212,255,.4);
}

.modal h2 { 
  color:var(--accent); 
  margin:30px 0; 
  font-size:28px;
  text-align:center;
}
.modal h3 { 
  color:var(--secondary); 
  margin:25px 0; 
  font-size:20px;
}
.modal p { line-height:1.8; margin:15px 0; font-size:16px; }
.modal ul { line-height:2; padding-left:30px; }
.modal li { margin:8px 0; }

.example-box {
  background:rgba(0,0,0,0.6);
  border-left:5px solid var(--accent);
  padding:20px;
  margin:25px 0;
  font-family:'Courier New',monospace;
  border-radius:8px;
  font-size:15px;
}

.complexity-diagram {
  background:rgba(0,0,0,0.8);
  border:2px solid var(--accent);
  padding:30px;
  margin:30px 0;
  border-radius:10px;
  text-align:center;
  font-family:monospace;
  font-size:14px;
  color:var(--accent);
}

.close-modal {
  color:var(--accent);
  float:right;
  font-size:36px;
  font-weight:bold;
  cursor:pointer;
  transition:all 0.3s;
}
.close-modal:hover { 
  color:var(--error);
  transform:rotate(90deg);
}
</style>
</head>
<body>
<div class="container">
  <div class="grid">
    <div class="panel">
      <div class="panel-title">‚öõÔ∏è Quantum Configuration</div>
      
      <label>N-Back Level: <span id="nbackValue" class="status-value">2</span></label>
      <input type="range" id="nbackLevel" min="1" max="5" value="2">
      
      <label>Trials per Block: <span id="trialsValue" class="status-value">40</span></label>
      <input type="range" id="totalTrials" min="20" max="100" step="10" value="40">
      
      <label>Match Probability: <span id="matchProbValue" class="status-value">30%</span></label>
      <input type="range" id="matchProbability" min="0" max="100" step="5" value="30">
      
      <label>Response Window: <span id="windowValue" class="status-value">10.0s</span></label>
      <input type="range" id="responseWindow" min="1" max="60" step="0.5" value="10">
      
      <label style="margin-top:20px">
        <input type="checkbox" id="voiceEnabled" checked> Voice Synthesis
      </label>
      
      <button id="instructionsBtn" class="btn btn-instructions" style="width:100%; margin-top:25px">
        üìö Instructions & Theory
      </button>
    </div>
    
    <div class="panel">
      <div class="panel-title">üéØ Control Center</div>
      
      <div style="display:flex; gap:12px; margin-bottom:25px">
        <button id="startBtn" class="btn" style="flex:1">‚ñ∂ START</button>
        <button id="pauseBtn" class="btn" style="flex:1" disabled>‚è∏ PAUSE</button>
        <button id="resetBtn" class="btn" style="flex:1" disabled>üîÑ RESET</button>
      </div>
      
      <div style="padding:20px; background:linear-gradient(135deg, rgba(0,212,255,0.1), rgba(0,212,255,0.05)); border-radius:10px; text-align:center; margin-bottom:20px; border:1px solid rgba(0,212,255,0.3)">
        <div style="font-size:16px; margin-bottom:10px">Match Detection Protocol</div>
        <strong>Press <span class="kbd">SPACEBAR</span> when you detect a deep structural match!</strong>
      </div>
      
      <div class="status-row">
        <div class="status-item">Trial: <span id="currentTrial" class="status-value">0</span>/<span id="maxTrials" class="status-value">40</span></div>
        <div class="status-item">Timer: <span id="countdown" class="status-value">‚Äî</span></div>
      </div>
      
      <div class="status-row">
        <div class="status-item" style="color:var(--success)">Correct: <span id="correctHits">0</span></div>
        <div class="status-item" style="color:var(--error)">False: <span id="falseAlarms">0</span></div>
        <div class="status-item" style="color:var(--warning)">Missed: <span id="misses">0</span></div>
      </div>
    </div>
    
    <div class="panel">
      <div class="panel-title">üìä Performance Metrics</div>
      
      <div class="status-row">
        <div class="status-item">Accuracy:</div>
        <div class="status-value" id="accuracy">‚Äî</div>
      </div>
      
      <div class="status-row">
        <div class="status-item">Avg Response:</div>
        <div class="status-value" id="avgResponse">‚Äî</div>
      </div>
      
      <div class="status-row">
        <div class="status-item">G-Load:</div>
        <div class="status-value">0.95+</div>
      </div>
      
      <div style="margin-top:25px; padding:15px; background:rgba(138,43,226,0.1); border-radius:8px; border:1px solid rgba(138,43,226,0.3)">
        <div style="font-size:13px; color:var(--secondary); text-align:center; line-height:1.6">
          <strong>MAXIMUM COGNITIVE LOAD</strong><br>
          Quantum Symbol Packing Protocol<br>
          Recursive Interference Cascades<br>
          Bidirectional Temporal Constraints
        </div>
      </div>
    </div>
  </div>
  
  <div class="panel">
    <div class="panel-title">üß† Quantum Relational N-Back ‚Ä¢ G-Load 0.95+ ‚Ä¢ Maximum Fluid Intelligence</div>
    <div id="premiseDisplay">
      <div style="text-align:center; color:var(--secondary); font-size:22px; font-weight:normal">
        Initialize quantum cognitive engine...<br>
        Press START to begin maximum g-load protocol
      </div>
    </div>
    <div id="feedbackArea"></div>
  </div>
</div>

<!-- Instructions Modal -->
<div id="instructionsModal" class="modal">
  <div class="modal-content">
    <span class="close-modal">&times;</span>
    <h2>‚öõÔ∏è QUANTUM RELATIONAL N-BACK: MAXIMUM G-LOAD PROTOCOL</h2>
    
    <div style="text-align:center; padding:20px; background:rgba(0,212,255,0.05); border-radius:10px; margin:20px 0">
      <strong style="color:var(--accent); font-size:20px">COGNITIVE SINGULARITY: G-LOAD 0.95+</strong><br>
      <span style="color:var(--secondary)">Operating at 95% of theoretical maximum human working memory capacity</span>
    </div>
    
    <h3>üî¨ The Science: Quantum Symbol Packing</h3>
    <p>Each 5-word premise encodes 6-9 symbols through quantum superposition. Your brain must simultaneously track multiple interfering transformational cascades that create recursive loops and bidirectional temporal constraints.</p>
    
    <div class="complexity-diagram">
      PREMISE ARCHITECTURE (Exactly 5 Words)
      ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
      
      Word 1: "ABC" = 3 symbols in superposition
      Word 2: "transforms-through" = operation + medium
      Word 3: "XY-affecting-Z" = 3 symbols + relation
      Word 4: "inversely" = modifier
      Word 5: "123" = 3 numeric constraints
      
      TOTAL: 9 symbols, multiple operations, recursive loops
    </div>
    
    <h3>üß© Understanding Quantum Premises</h3>
    
    <div class="example-box">
      EXAMPLE: "ABC transforms-through XY-affecting-Z inversely 123"
      
      This single premise requires you to:
      ‚Ä¢ Track 9 symbols simultaneously (A,B,C,X,Y,Z,1,2,3)
      ‚Ä¢ Simulate ABC as bound triple moving together
      ‚Ä¢ Compute transformation passing through XY medium
      ‚Ä¢ Track XY simultaneously affecting Z (interference)
      ‚Ä¢ Apply inverse operation to entire cascade
      ‚Ä¢ Verify numeric constraints 1,2,3 are satisfied
    </div>
    
    <h3>üéØ What Constitutes a TRUE MATCH?</h3>
    
    <p>A match is NOT about similar words or symbols. It's about <strong>deep structural equivalence</strong> across five dimensions:</p>
    
    <ol>
      <li><strong>Isomorphic Transformation Graphs:</strong> The pattern of who-affects-whom must be topologically equivalent</li>
      <li><strong>Conservation Under Permutation:</strong> Swapping any two symbols maintains the match</li>
      <li><strong>Equivalent Convergence:</strong> Recursive loops reach the same attractor state</li>
      <li><strong>Phase-Aligned Interference:</strong> Transformations interfere constructively/destructively identically</li>
      <li><strong>Bidirectional Causality:</strong> Future constrains past interpretation consistently</li>
    </ol>
    
    <div class="example-box">
      MATCH EXAMPLE:
      
      Trial 1: "ABC transforms-through XY-affecting-Z inversely 123"
      Trial 3: "RGB collapses-into UV-becoming-W until 456"
      
      THESE MATCH BECAUSE:
      ‚Ä¢ Both have triple‚Üípair‚Üísingle cascade (ABC‚ÜíXY‚ÜíZ ‚âà RGB‚ÜíUV‚ÜíW)
      ‚Ä¢ Both create recursive interference loops
      ‚Ä¢ Both have backward temporal constraints ("inversely" ‚âà "until")
      ‚Ä¢ Both converge to same attractor state after 3 iterations
      ‚Ä¢ Conservation laws preserved (9 symbols ‚Üí 9 symbols)
      
      CRITICAL: You cannot detect this match without mentally simulating 
      the full recursive cascade and verifying convergence!
    </div>
    
    <h3>üîÑ Recursive Interference Cascades</h3>
    
    <div class="complexity-diagram">
      MENTAL SIMULATION REQUIRED:
      
      Step 1: A affects B, B affects C, C affects A (loop closure)
      Step 2: Loop modifies itself each iteration
      Step 3: Continue until stable state emerges (3+ iterations)
      Step 4: Verify conservation laws satisfied
      Step 5: Check bidirectional temporal consistency
      
      Pattern matching is IMPOSSIBLE - only full simulation works!
    </div>
    
    <h3>‚ö†Ô∏è Critical Concepts</h3>
    
    <h4>Bidirectional Temporal Constraints</h4>
    <p>Future states determine valid past interpretations. When you see "until 123" or "inversely", these constrain what happened BEFORE, requiring backward simulation after forward pass.</p>
    
    <h4>Conservation Paradoxes</h4>
    <p>Premises like "doubles-while-halving" appear to violate conservation but require discovering hidden dimensions where conservation holds.</p>
    
    <h4>Phase Interference</h4>
    <p>Operations can constructively or destructively interfere. "Transforms-through" + "affecting" might amplify or cancel depending on phase alignment.</p>
    
    <h3>üí° Strategic Approach</h3>
    
    <ol>
      <li><strong>Parse Symbol Density:</strong> Identify all 6-9 symbols packed in 5 words</li>
      <li><strong>Map Interference Pattern:</strong> Determine how operations affect each other</li>
      <li><strong>Iterate Recursion:</strong> Mentally run loop 3+ times until stable</li>
      <li><strong>Verify Conservation:</strong> Check energy/information preserved</li>
      <li><strong>Test Bidirectionality:</strong> Confirm future‚Üípast constraints satisfied</li>
      <li><strong>Compare Deep Structure:</strong> Match topology, not surface features</li>
    </ol>
    
    <h3>üéÆ Settings Guide</h3>
    
    <ul>
      <li><strong>N-Back Level:</strong> Start at 2, increase as you improve (3+ is extreme)</li>
      <li><strong>Match Probability:</strong> 30% optimal for learning; increase to practice match detection</li>
      <li><strong>Response Window:</strong> 10-15 seconds recommended for full mental simulation</li>
    </ul>
    
    <div style="background:rgba(255,170,0,0.1); padding:20px; border-radius:10px; border:1px solid var(--warning); margin-top:30px">
      <strong style="color:var(--warning)">‚ö†Ô∏è WARNING: MAXIMUM COGNITIVE LOAD</strong><br>
      This operates at the theoretical limit of human working memory. Expect initial accuracy of 30-35%. 
      Improvement indicates genuine fluid intelligence development, not pattern learning.
    </div>
  </div>
</div>

<script>
/* ============================================================
   QUANTUM RELATIONAL N-BACK: MAXIMUM G-LOAD IMPLEMENTATION
   Theoretical Maximum: 0.95+ through quantum symbol packing,
   recursive interference cascades, and bidirectional constraints
   ============================================================ */

const $ = id => document.getElementById(id);
const setText = (id, text) => { const el = $(id); if(el) el.textContent = text; };

/* ===== QUANTUM SYMBOL PACKING ENGINE ===== */
class QuantumSymbolEngine {
  constructor() {
    // Multi-symbol encoding pools
    this.tripleSymbols = ['ABC', 'XYZ', 'RGB', 'DEF', 'UVW', 'PQR'];
    this.pairSymbols = ['XY', 'AB', 'UV', 'CD', 'RS', 'MN'];
    this.singleSymbols = ['Z', 'W', 'Q', 'K', 'T', 'L'];
    this.numericTriples = ['123', '456', '789', '012', '345', '678'];
    
    // Compound operations creating interference
    this.compoundOps = [
      'transforms-through',
      'collapses-into', 
      'doubles-while-halving',
      'rotates-becoming',
      'splits-then-merges',
      'expands-contracting'
    ];
    
    // Complex relations with cascades
    this.complexRelations = [
      'affecting',
      'becoming', 
      'inverting',
      'modulating',
      'cascading',
      'interfering'
    ];
    
    // Temporal/phase modifiers
    this.modifiers = [
      'inversely',
      'recursively',
      'until',
      'through',
      'beyond',
      'within'
    ];
    
    // Track quantum state for conservation
    this.quantumState = {
      totalSymbols: 0,
      totalEnergy: 100,
      totalInformation: 50,
      phaseParity: 0
    };
  }
  
  parseQuantumPremise(text) {
    const words = text.split(' ');
    if (words.length !== 5) return null;
    
    // Extract all symbols (6-9 total)
    const symbols = [];
    
    // Word 1: Triple symbols
    if (this.tripleSymbols.includes(words[0])) {
      symbols.push(...words[0].split(''));
    }
    
    // Word 3: Complex relation with embedded symbols
    if (words[2].includes('-')) {
      const parts = words[2].split('-');
      parts.forEach(part => {
        if (part.length <= 2 && /[A-Z]/.test(part)) {
          symbols.push(...part.split(''));
        }
      });
    }
    
    // Word 5: Numeric constraints
    if (this.numericTriples.includes(words[4])) {
      symbols.push(...words[4].split(''));
    }
    
    return {
      symbols: symbols,
      symbolCount: symbols.length,
      operation: words[1],
      relation: words[2],
      modifier: words[3],
      constraints: words[4]
    };
  }
  
  computeInterference(op1, op2) {
    // Operations interfere based on phase alignment
    const interference = {
      'transforms-through': { 'affecting': 0.8, 'becoming': 0.6, 'inverting': -0.8 },
      'collapses-into': { 'affecting': -0.6, 'becoming': 0.9, 'inverting': 0.3 },
      'doubles-while-halving': { 'affecting': 0.0, 'becoming': -1.0, 'inverting': 1.0 }
    };
    
    return interference[op1]?.[op2] || 0.5;
  }
  
  simulateRecursiveCascade(parsed, iterations = 3) {
    let state = {
      symbols: [...parsed.symbols],
      energy: 100,
      phase: 0,
      converged: false
    };
    
    for (let i = 0; i < iterations; i++) {
      // Apply operation creating cascade
      state = this.applyQuantumOperation(state, parsed.operation);
      
      // Apply relation creating interference
      state = this.applyRelation(state, parsed.relation);
      
      // Apply modifier (may reverse time)
      state = this.applyModifier(state, parsed.modifier);
      
      // Check convergence
      if (this.hasConverged(state)) {
        state.converged = true;
        break;
      }
    }
    
    return state;
  }
  
  applyQuantumOperation(state, operation) {
    switch(operation) {
      case 'transforms-through':
        state.phase += Math.PI/4;
        state.energy *= 0.9;
        break;
      case 'collapses-into':
        state.symbols = state.symbols.slice(0, Math.ceil(state.symbols.length / 2));
        state.energy *= 1.5;
        break;
      case 'doubles-while-halving':
        // Paradox: must find hidden dimension
        state.phase += Math.PI;
        state.energy = state.energy; // Conservation required
        break;
    }
    return state;
  }
  
  applyRelation(state, relation) {
    if (relation.includes('-')) {
      // Complex relation with embedded symbols
      const parts = relation.split('-');
      state.phase += parts.length * Math.PI/6;
    }
    return state;
  }
  
  applyModifier(state, modifier) {
    switch(modifier) {
      case 'inversely':
        // Reverse temporal flow
        state.phase = -state.phase;
        state.energy = 100 / state.energy;
        break;
      case 'recursively':
        // Create self-reference loop
        state.symbols = [...state.symbols, ...state.symbols.slice(0, 1)];
        break;
      case 'until':
        // Future boundary condition
        state.converged = state.energy < 50;
        break;
    }
    return state;
  }
  
  hasConverged(state) {
    // Check if reached stable attractor
    return Math.abs(state.phase % (2 * Math.PI)) < 0.1 && 
           Math.abs(state.energy - 100) < 10;
  }
}

/* ===== MAXIMUM G-LOAD PREMISE GENERATOR ===== */
class MaxGLoadPremiseGenerator {
  constructor() {
    this.engine = new QuantumSymbolEngine();
    this.usedPremises = new Set();
    this.premiseHistory = [];
  }
  
  generateQuantumPremise() {
    let attempts = 0;
    let premise;
    
    do {
      // Pattern selection based on true randomness
      const pattern = this.selectPattern();
      premise = this.buildQuantumPremise(pattern);
      attempts++;
    } while (this.usedPremises.has(premise) && attempts < 100);
    
    this.usedPremises.add(premise);
    this.premiseHistory.push(premise);
    
    // Maintain reasonable history size
    if (this.usedPremises.size > 200) {
      const premises = Array.from(this.usedPremises);
      this.usedPremises = new Set(premises.slice(-100));
    }
    
    return premise;
  }
  
  selectPattern() {
    const patterns = [
      'alpha', // Triple cascade with recursion
      'beta',  // Phase-shifted bidirectional
      'gamma', // Conservation paradox
      'delta', // Interference cascade
      'epsilon' // Temporal inversion
    ];
    return patterns[Math.floor(Math.random() * patterns.length)];
  }
  
  buildQuantumPremise(pattern) {
    switch(pattern) {
      case 'alpha':
        return this.buildTripleCascade();
      case 'beta':
        return this.buildPhaseShifted();
      case 'gamma':
        return this.buildConservationParadox();
      case 'delta':
        return this.buildInterferenceCascade();
      case 'epsilon':
        return this.buildTemporalInversion();
      default:
        return this.buildTripleCascade();
    }
  }
  
  buildTripleCascade() {
    const triple = this.engine.tripleSymbols[Math.floor(Math.random() * this.engine.tripleSymbols.length)];
    const op = this.engine.compoundOps[Math.floor(Math.random() * this.engine.compoundOps.length)];
    const pair = this.engine.pairSymbols[Math.floor(Math.random() * this.engine.pairSymbols.length)];
    const single = this.engine.singleSymbols[Math.floor(Math.random() * this.engine.singleSymbols.length)];
    const relation = `${pair}-affecting-${single}`;
    const modifier = this.engine.modifiers[Math.floor(Math.random() * this.engine.modifiers.length)];
    const numeric = this.engine.numericTriples[Math.floor(Math.random() * this.engine.numericTriples.length)];
    
    return `${triple} ${op} ${relation} ${modifier} ${numeric}`;
  }
  
  buildPhaseShifted() {
    const triple = 'RGB';
    const op = 'collapses-into';
    const complex = 'UV-becoming-W';
    const modifier = 'until';
    const numeric = this.engine.numericTriples[Math.floor(Math.random() * this.engine.numericTriples.length)];
    
    return `${triple} ${op} ${complex} ${modifier} ${numeric}`;
  }
  
  buildConservationParadox() {
    const triple = this.engine.tripleSymbols[Math.floor(Math.random() * this.engine.tripleSymbols.length)];
    const op = 'doubles-while-halving';
    const complex = `${this.engine.pairSymbols[0]}-inverting-${this.engine.singleSymbols[0]}`;
    const modifier = 'through';
    const numeric = 'NOTHING'; // Special case: zero medium
    
    return `${triple} ${op} ${complex} ${modifier} ${numeric}`;
  }
  
  buildInterferenceCascade() {
    const triple = 'XYZ';
    const op = 'transforms-through';
    const complex = 'AB-cascading-C';
    const modifier = 'recursively';
    const numeric = this.engine.numericTriples[Math.floor(Math.random() * this.engine.numericTriples.length)];
    
    return `${triple} ${op} ${complex} ${modifier} ${numeric}`;
  }
  
  buildTemporalInversion() {
    const triple = this.engine.tripleSymbols[Math.floor(Math.random() * this.engine.tripleSymbols.length)];
    const op = 'rotates-becoming';
    const complex = `${this.engine.pairSymbols[1]}-modulating-${this.engine.singleSymbols[1]}`;
    const modifier = 'inversely';
    const numeric = this.engine.numericTriples[Math.floor(Math.random() * this.engine.numericTriples.length)];
    
    return `${triple} ${op} ${complex} ${modifier} ${numeric}`;
  }
  
  generateDeepMatch(reference) {
    // Generate premise with same deep structure but different symbols
    const refParsed = this.engine.parseQuantumPremise(reference);
    const refState = this.engine.simulateRecursiveCascade(refParsed);
    
    let attempts = 0;
    let matchPremise;
    let matchFound = false;
    
    do {
      matchPremise = this.generateQuantumPremise();
      const matchParsed = this.engine.parseQuantumPremise(matchPremise);
      const matchState = this.engine.simulateRecursiveCascade(matchParsed);
      
      // Check deep structural equivalence
      matchFound = this.checkDeepEquivalence(refState, matchState);
      attempts++;
    } while (!matchFound && attempts < 50);
    
    return matchPremise;
  }
  
  checkDeepEquivalence(state1, state2) {
    // Check all dimensions of deep equivalence
    const symbolCountMatch = Math.abs(state1.symbols.length - state2.symbols.length) <= 1;
    const convergenceMatch = state1.converged === state2.converged;
    const phaseAligned = Math.abs(state1.phase - state2.phase) % Math.PI < 0.5;
    const energyConserved = Math.abs(state1.energy - state2.energy) < 20;
    
    return symbolCountMatch && convergenceMatch && phaseAligned && energyConserved;
  }
}

/* ===== GAME CONTROLLER ===== */
class QuantumNBackGame {
  constructor() {
    this.generator = new MaxGLoadPremiseGenerator();
    this.engine = new QuantumSymbolEngine();
    this.history = [];
    this.matchSchedule = [];
    
    // Configuration
    this.nLevel = 2;
    this.totalTrials = 40;
    this.matchProbability = 0.3;
    this.responseWindow = 10000;
    this.voiceEnabled = true;
    
    // State
    this.currentTrial = 0;
    this.isRunning = false;
    this.isPaused = false;
    this.awaitingResponse = false;
    this.responseTimer = null;
    this.countdownInterval = null;
    
    // Scoring
    this.correctHits = 0;
    this.falseAlarms = 0;
    this.misses = 0;
    this.responseTimes = [];
    
    // Timing
    this.trialStartTime = 0;
  }
  
  initialize(config) {
    this.nLevel = config.nLevel;
    this.totalTrials = config.totalTrials;
    this.matchProbability = config.matchProbability;
    this.responseWindow = config.responseWindow;
    this.voiceEnabled = config.voiceEnabled;
    
    this.reset();
    this.planMatchSchedule();
  }
  
  reset() {
    this.history = [];
    this.matchSchedule = [];
    this.currentTrial = 0;
    this.correctHits = 0;
    this.falseAlarms = 0;
    this.misses = 0;
    this.responseTimes = [];
    this.awaitingResponse = false;
  }
  
  planMatchSchedule() {
    this.matchSchedule = new Array(this.totalTrials).fill(false);
    
    // Only allow matches after n-back threshold
    for (let i = this.nLevel; i < this.totalTrials; i++) {
      if (Math.random() < this.matchProbability) {
        this.matchSchedule[i] = true;
      }
    }
  }
  
  async runTrial() {
    if (!this.isRunning || this.isPaused) return;
    
    this.awaitingResponse = true;
    const shouldMatch = this.matchSchedule[this.currentTrial];
    
    let premise;
    
    if (shouldMatch && this.currentTrial >= this.nLevel) {
      // Generate deep structural match (never identical)
      const reference = this.history[this.currentTrial - this.nLevel];
      premise = this.generator.generateDeepMatch(reference);
    } else {
      // Generate novel premise
      premise = this.generator.generateQuantumPremise();
    }
    
    // Store in history
    this.history[this.currentTrial] = premise;
    
    // Display premise
    this.displayQuantumPremise(premise);
    
    // Start timers
    this.trialStartTime = Date.now();
    this.startResponseTimer();
    
    // Voice synthesis
    if (this.voiceEnabled) {
      await this.speak(premise);
    }
  }
  
  displayQuantumPremise(premise) {
    const display = $('premiseDisplay');
    display.innerHTML = '';
    
    const div = document.createElement('div');
    div.className = 'premise-text';
    
    const words = premise.split(' ');
    words.forEach((word, idx) => {
      const span = document.createElement('span');
      
      // Apply quantum styling based on word type
      if (this.engine.tripleSymbols.includes(word)) {
        span.className = 'symbol-triple';
      } else if (this.engine.numericTriples.includes(word) || word === 'NOTHING') {
        span.className = 'numeric-constraint';
      } else if (word.includes('-')) {
        if (word.includes('affecting') || word.includes('becoming') || 
            word.includes('inverting') || word.includes('modulating') ||
            word.includes('cascading')) {
          span.className = 'relation-complex';
        } else {
          span.className = 'operation-compound';
        }
      } else if (this.engine.modifiers.includes(word)) {
        span.className = 'modifier';
      } else {
        span.className = 'symbol-single';
      }
      
      span.textContent = word;
      div.appendChild(span);
      
      if (idx < words.length - 1) {
        div.appendChild(document.createTextNode(' '));
      }
    });
    
    display.appendChild(div);
    
    // Update trial counter
    setText('currentTrial', this.currentTrial + 1);
  }
  
  startResponseTimer() {
    let timeLeft = this.responseWindow;
    
    this.countdownInterval = setInterval(() => {
      timeLeft -= 100;
      setText('countdown', (timeLeft / 1000).toFixed(1) + 's');
      
      if (timeLeft <= 0) {
        clearInterval(this.countdownInterval);
        setText('countdown', '0.0s');
      }
    }, 100);
    
    this.responseTimer = setTimeout(() => {
      this.endTrial();
    }, this.responseWindow);
  }
  
  handleResponse() {
    if (!this.awaitingResponse || !this.isRunning) return;
    
    const responseTime = Date.now() - this.trialStartTime;
    this.responseTimes.push(responseTime);
    this.awaitingResponse = false;
    
    // Clear timers
    if (this.responseTimer) clearTimeout(this.responseTimer);
    if (this.countdownInterval) clearInterval(this.countdownInterval);
    
    // Evaluate response
    const shouldHaveResponded = this.matchSchedule[this.currentTrial] && this.currentTrial >= this.nLevel;
    
    if (shouldHaveResponded) {
      this.correctHits++;
      this.showFeedback('correct', 'Correct! Deep structural match detected through quantum cascade convergence.');
    } else {
      this.falseAlarms++;
      this.showFeedback('incorrect', 'Incorrect. The quantum topologies differed in phase or convergence.');
    }
    
    setTimeout(() => {
      this.nextTrial();
    }, 2500);
  }
  
  endTrial() {
    this.awaitingResponse = false;
    
    if (this.responseTimer) clearTimeout(this.responseTimer);
    if (this.countdownInterval) clearInterval(this.countdownInterval);
    
    const shouldHaveResponded = this.matchSchedule[this.currentTrial] && this.currentTrial >= this.nLevel;
    
    if (shouldHaveResponded) {
      this.misses++;
      this.showFeedback('missed', 'Missed match! The recursive cascades had identical convergence topology.');
    } else {
      // Correct rejection - no feedback needed
      this.correctHits++;
    }
    
    setTimeout(() => {
      this.nextTrial();
    }, 2500);
  }
  
  showFeedback(type, message) {
    const area = $('feedbackArea');
    area.innerHTML = '';
    
    const div = document.createElement('div');
    div.className = `feedback ${type}`;
    div.textContent = message;
    area.appendChild(div);
    
    // Update scores
    setText('correctHits', this.correctHits);
    setText('falseAlarms', this.falseAlarms);
    setText('misses', this.misses);
    
    // Update accuracy
    const total = this.correctHits + this.falseAlarms + this.misses;
    if (total > 0) {
      const accuracy = (this.correctHits / total * 100).toFixed(1);
      setText('accuracy', accuracy + '%');
    }
    
    // Update average response time
    if (this.responseTimes.length > 0) {
      const avg = this.responseTimes.reduce((a,b) => a+b, 0) / this.responseTimes.length;
      setText('avgResponse', (avg / 1000).toFixed(2) + 's');
    }
  }
  
  nextTrial() {
    $('feedbackArea').innerHTML = '';
    this.currentTrial++;
    
    if (this.currentTrial >= this.totalTrials) {
      this.endSession();
    } else {
      this.runTrial();
    }
  }
  
  endSession() {
    this.isRunning = false;
    
    const display = $('premiseDisplay');
    const total = this.correctHits + this.falseAlarms + this.misses;
    const accuracy = total > 0 ? (this.correctHits / total * 100).toFixed(1) : 0;
    
    display.innerHTML = `
      <div style="text-align:center; padding:50px;">
        <h2 style="color:var(--accent); margin-bottom:30px">Quantum Session Complete</h2>
        <div style="font-size:20px; line-height:2.5">
          <div>Correct Detections: <span style="color:var(--success); font-weight:bold">${this.correctHits}</span></div>
          <div>False Alarms: <span style="color:var(--error); font-weight:bold">${this.falseAlarms}</span></div>
          <div>Missed Matches: <span style="color:var(--warning); font-weight:bold">${this.misses}</span></div>
          <div style="margin-top:30px; font-size:24px">
            Final Accuracy: <strong style="color:var(--accent)">${accuracy}%</strong>
          </div>
          <div style="margin-top:20px; color:var(--secondary); font-size:16px">
            G-Load Achievement: ${accuracy > 35 ? 'üèÜ EXCEPTIONAL' : accuracy > 25 ? '‚≠ê STRONG' : 'üí™ DEVELOPING'}
          </div>
        </div>
      </div>
    `;
    
    // Reset buttons
    $('startBtn').disabled = false;
    $('pauseBtn').disabled = true;
    $('resetBtn').disabled = true;
  }
  
  async speak(text) {
    if (!this.voiceEnabled || !window.speechSynthesis) return;
    
    return new Promise(resolve => {
      const utterance = new SpeechSynthesisUtterance(text);
      utterance.lang = 'en-US';
      utterance.rate = 0.75;
      utterance.pitch = 1.0;
      utterance.volume = 1.0;
      utterance.onend = resolve;
      utterance.onerror = resolve;
      
      if (window.speechSynthesis.speaking) {
        window.speechSynthesis.cancel();
      }
      
      window.speechSynthesis.speak(utterance);
    });
  }
  
  pause() {
    this.isPaused = true;
    if (this.responseTimer) clearTimeout(this.responseTimer);
    if (this.countdownInterval) clearInterval(this.countdownInterval);
  }
  
  resume() {
    this.isPaused = false;
    this.runTrial();
  }
}

// Initialize game instance
const game = new QuantumNBackGame();

// Control functions
function start() {
  const config = {
    nLevel: parseInt($('nbackLevel').value),
    totalTrials: parseInt($('totalTrials').value),
    matchProbability: parseInt($('matchProbability').value) / 100,
    responseWindow: parseFloat($('responseWindow').value) * 1000,
    voiceEnabled: $('voiceEnabled').checked
  };
  
  game.initialize(config);
  game.isRunning = true;
  
  // Update displays
  setText('maxTrials', config.totalTrials);
  setText('correctHits', '0');
  setText('falseAlarms', '0');
  setText('misses', '0');
  setText('accuracy', '‚Äî');
  setText('avgResponse', '‚Äî');
  
  // Update buttons
  $('startBtn').disabled = true;
  $('pauseBtn').disabled = false;
  $('resetBtn').disabled = false;
  
  // Start first trial
  game.runTrial();
}

function pause() {
  if (game.isPaused) {
    game.resume();
    $('pauseBtn').textContent = '‚è∏ PAUSE';
  } else {
    game.pause();
    $('pauseBtn').textContent = '‚ñ∂ RESUME';
  }
}

function reset() {
  game.isRunning = false;
  game.reset();
  
  if (game.responseTimer) clearTimeout(game.responseTimer);
  if (game.countdownInterval) clearInterval(game.countdownInterval);
  
  $('premiseDisplay').innerHTML = `
    <div style="text-align:center; color:var(--secondary); font-size:22px; font-weight:normal">
      Initialize quantum cognitive engine...<br>
      Press START to begin maximum g-load protocol
    </div>
  `;
  $('feedbackArea').innerHTML = '';
  
  setText('currentTrial', '0');
  setText('correctHits', '0');
  setText('falseAlarms', '0');
  setText('misses', '0');
  setText('accuracy', '‚Äî');
  setText('avgResponse', '‚Äî');
  setText('countdown', '‚Äî');
  
  $('startBtn').disabled = false;
  $('pauseBtn').disabled = true;
  $('resetBtn').disabled = true;
  $('pauseBtn').textContent = '‚è∏ PAUSE';
  
  if (window.speechSynthesis) {
    window.speechSynthesis.cancel();
  }
}

// Event listeners
document.addEventListener('DOMContentLoaded', () => {
  // Settings controls
  $('nbackLevel').oninput = (e) => {
    setText('nbackValue', e.target.value);
  };
  
  $('totalTrials').oninput = (e) => {
    setText('trialsValue', e.target.value);
    setText('maxTrials', e.target.value);
  };
  
  $('matchProbability').oninput = (e) => {
    setText('matchProbValue', e.target.value + '%');
  };
  
  $('responseWindow').oninput = (e) => {
    setText('windowValue', parseFloat(e.target.value).toFixed(1) + 's');
  };
  
  // Control buttons
  $('startBtn').onclick = start;
  $('pauseBtn').onclick = pause;
  $('resetBtn').onclick = reset;
  
  // Spacebar for response
  window.addEventListener('keydown', (e) => {
    if (e.code === 'Space' && game.isRunning && !game.isPaused && game.awaitingResponse) {
      e.preventDefault();
      game.handleResponse();
    }
  });
  
  // Instructions modal
  const modal = $('instructionsModal');
  const btn = $('instructionsBtn');
  const closeBtn = document.querySelector('.close-modal');
  
  btn.onclick = () => modal.style.display = 'block';
  closeBtn.onclick = () => modal.style.display = 'none';
  window.onclick = (e) => {
    if (e.target === modal) modal.style.display = 'none';
  };
});
</script>
</body>
</html>
