<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>Canonical State-Vector N-Back (0.95+ G-Load)</title>
<style>
:root { 
  --bg:#0a0a0f; 
  --fg:#e6fbff; 
  --accent:#00ccff; 
  --mut:#8fe7ff; 
  --success:#26de81;
  --error:#ff6b6b;
  --warning:#ffd700;
}

* { box-sizing:border-box; margin:0; padding:0; }
html, body { height:100%; overflow-x:hidden; }
body { 
  background:linear-gradient(135deg, #0a0a0f 0%, #0f1419 100%); 
  color:var(--fg); 
  font-family:system-ui,-apple-system,Segoe UI,Roboto,sans-serif;
}

.container { max-width:1280px; margin:0 auto; padding:20px; }
.grid { display:grid; grid-template-columns:repeat(auto-fit, minmax(350px, 1fr)); gap:20px; margin-bottom:20px; }

.panel { 
  background:rgba(16,20,24,0.95); 
  border:1px solid rgba(0,200,255,.3); 
  border-radius:12px; 
  padding:20px; 
  backdrop-filter:blur(10px);
  box-shadow:0 4px 20px rgba(0,0,0,0.4);
}

.panel-title { 
  font-weight:800; 
  margin-bottom:15px; 
  color:var(--accent);
  text-shadow:0 0 10px rgba(0,200,255,0.3);
  font-size:18px;
}

.btn { 
  background:rgba(0,200,255,0.1); 
  color:var(--accent); 
  border:1px solid var(--accent); 
  border-radius:8px; 
  padding:12px 20px; 
  font-weight:700; 
  cursor:pointer; 
  transition:all 0.3s;
  font-size:14px;
}
.btn:hover:not(:disabled) { 
  background:rgba(0,200,255,0.25); 
  box-shadow:0 0 20px rgba(0,200,255,.5);
  transform:translateY(-1px);
}
.btn:disabled { opacity:0.4; cursor:not-allowed; }

.btn.instructions { 
  background:rgba(95,39,205,0.2); 
  border-color:#5f27cd; 
  color:#a55eea;
}
.btn.instructions:hover { 
  background:rgba(95,39,205,0.4); 
  box-shadow:0 0 20px rgba(95,39,205,.6);
}

label { 
  font-size:13px; 
  color:var(--mut); 
  display:block; 
  margin:12px 0 6px 0;
  font-weight:600;
  text-transform:uppercase;
  letter-spacing:0.5px;
}

input[type=range] { 
  width:100%; 
  height:6px;
  background:rgba(0,200,255,0.1);
  border-radius:3px;
  outline:none;
  -webkit-appearance:none;
}
input[type=range]::-webkit-slider-thumb {
  -webkit-appearance:none;
  width:18px;
  height:18px;
  background:var(--accent);
  border-radius:50%;
  cursor:pointer;
  box-shadow:0 0 10px rgba(0,200,255,0.5);
}
input[type=range]::-moz-range-thumb {
  width:18px;
  height:18px;
  background:var(--accent);
  border-radius:50%;
  cursor:pointer;
  box-shadow:0 0 10px rgba(0,200,255,0.5);
}

.kbd { 
  display:inline-block;
  padding:4px 8px; 
  border-radius:4px; 
  background:rgba(0,0,0,0.5); 
  border:1px solid rgba(255,255,255,.3);
  font-size:12px;
  font-weight:bold;
  box-shadow:0 2px 4px rgba(0,0,0,0.3);
}

#premiseDisplay { 
  min-height:180px; 
  background:linear-gradient(135deg, rgba(14,17,19,0.98), rgba(19,22,25,0.98));
  border:2px solid rgba(0,200,255,.4); 
  border-radius:12px; 
  padding:30px; 
  font-size:34px; 
  line-height:2.0; 
  font-family:'Courier New',monospace; 
  font-weight:900; 
  letter-spacing:1px;
  position:relative;
  overflow:hidden;
  box-shadow:inset 0 0 30px rgba(0,200,255,0.05);
}

@keyframes pulse { 0%,100%{opacity:1} 50%{opacity:0.8} }
@keyframes fadeIn { from{opacity:0; transform:translateY(10px)} to{opacity:1; transform:translateY(0)} }

.premise-text { 
  padding:20px; 
  margin:10px 0;
  border-left:6px solid var(--accent); 
  background:linear-gradient(90deg, rgba(0,200,255,.1), transparent); 
  border-radius:4px; 
  animation:fadeIn 0.5s ease-out;
}

/* Symbol highlighting */
.sym-primary { color:#ff6b6b; text-shadow:0 0 15px rgba(255,107,107,.8); }
.sym-secondary { color:#4ecdc4; text-shadow:0 0 15px rgba(78,205,196,.8); }
.sym-number { color:#ff00ff; text-shadow:0 0 15px rgba(255,0,255,.8); }
.sym-color { text-shadow:0 0 15px currentColor; font-weight:900; }
.operation { color:#26de81; font-style:italic; }
.relation { color:#a55eea; font-weight:900; text-decoration:underline dotted; }
.state { color:#ffd700; font-weight:bold; }
.compound { background:rgba(0,210,211,0.15); padding:2px 6px; border-radius:3px; }

.feedback {
  margin-top:20px;
  padding:15px;
  border-radius:8px;
  font-size:16px;
  font-weight:600;
  animation:fadeIn 0.5s ease-out;
}
.feedback.correct {
  background:rgba(38,222,129,0.2);
  border:1px solid var(--success);
  color:var(--success);
}
.feedback.incorrect {
  background:rgba(255,107,107,0.2);
  border:1px solid var(--error);
  color:var(--error);
}
.feedback.missed {
  background:rgba(255,215,0,0.2);
  border:1px solid var(--warning);
  color:var(--warning);
}

.status-display {
  display:flex;
  justify-content:space-between;
  margin-top:15px;
  padding:10px;
  background:rgba(0,0,0,0.3);
  border-radius:6px;
}
.status-item {
  font-size:14px;
  font-weight:600;
}

.state-tracker {
  margin-top:10px;
  padding:10px;
  background:rgba(0,0,0,0.4);
  border-radius:6px;
  font-size:11px;
  font-family:'Courier New',monospace;
  color:var(--mut);
  display:none;
}

.state-tracker.active {
  display:block;
}

/* Modal */
.modal {
  display:none;
  position:fixed;
  z-index:1000;
  left:0;
  top:0;
  width:100%;
  height:100%;
  background:rgba(0,0,0,0.95);
  backdrop-filter:blur(10px);
}

.modal-content {
  background:linear-gradient(135deg, #0f1419, #1a1f25);
  margin:20px auto;
  padding:30px;
  border:2px solid var(--accent);
  border-radius:15px;
  width:90%;
  max-width:900px;
  max-height:90vh;
  overflow-y:auto;
  box-shadow:0 0 50px rgba(0,200,255,.5);
}

.modal h2 { color:var(--accent); margin:25px 0; }
.modal h3 { color:var(--mut); margin:20px 0; }
.modal p { line-height:1.8; margin:15px 0; }
.modal ul { line-height:1.8; padding-left:30px; }

.example-box {
  background:rgba(0,0,0,0.5);
  border-left:4px solid var(--accent);
  padding:15px;
  margin:20px 0;
  font-family:'Courier New',monospace;
  border-radius:5px;
}

.close-modal {
  color:var(--accent);
  float:right;
  font-size:32px;
  font-weight:bold;
  cursor:pointer;
  transition:all 0.3s;
}
.close-modal:hover { 
  color:var(--error);
  transform:rotate(90deg);
}

.meta-line {
  font-size:10px;
  color:#666;
  margin-top:5px;
  font-family:'Courier New',monospace;
}

.proof-trace {
  background:rgba(0,0,0,0.3);
  border:1px solid rgba(0,200,255,0.2);
  padding:10px;
  margin-top:10px;
  font-size:11px;
  font-family:'Courier New',monospace;
  color:var(--mut);
  border-radius:4px;
}
</style>
</head>
<body>
<div class="container">
  <div class="grid">
    <div class="panel">
      <div class="panel-title">‚öôÔ∏è Configuration</div>
      
      <label>N-Back Level: <span id="nbackValue">2</span></label>
      <input type="range" id="nbackLevel" min="1" max="5" value="2">
      
      <label>Statements per Trial: <span id="stmtValue">1</span></label>
      <input type="range" id="statementsPerTrial" min="1" max="3" value="1">
      
      <label>Match Probability: <span id="matchProbValue">30%</span></label>
      <input type="range" id="matchProbability" min="0" max="100" step="5" value="30">
      
      <label>Response Window: <span id="windowValue">8.0s</span></label>
      <input type="range" id="responseWindow" min="1" max="60" step="0.5" value="8">
      
      <label style="margin-top:15px">
        <input type="checkbox" id="voiceEnabled" checked> Voice Synthesis
      </label>
      
      <button id="instructionsBtn" class="btn instructions" style="width:100%; margin-top:20px">
        üìñ Instructions
      </button>
    </div>
    
    <div class="panel">
      <div class="panel-title">üéÆ Controls</div>
      
      <div style="display:flex; gap:10px; margin-bottom:20px">
        <button id="startBtn" class="btn" style="flex:1">‚ñ∂ Start</button>
        <button id="pauseBtn" class="btn" style="flex:1" disabled>‚è∏ Pause</button>
        <button id="resetBtn" class="btn" style="flex:1" disabled>üîÑ Reset</button>
      </div>
      
      <div style="padding:15px; background:rgba(0,200,255,0.1); border-radius:8px; text-align:center; margin-bottom:15px">
        <strong>Press <span class="kbd">SPACEBAR</span> when you detect a match!</strong>
      </div>
      
      <div class="status-display">
        <div class="status-item">Trial: <span id="currentTrial">0</span>/<span id="totalTrials">50</span></div>
        <div class="status-item">Timer: <span id="countdown" style="color:var(--accent)">‚Äî</span></div>
      </div>
      
      <div class="status-display">
        <div class="status-item" style="color:var(--success)">Hits: <span id="correctHits">0</span></div>
        <div class="status-item" style="color:var(--error)">False: <span id="falseAlarms">0</span></div>
        <div class="status-item" style="color:var(--warning)">Missed: <span id="misses">0</span></div>
      </div>
    </div>
    
    <div class="panel">
      <div class="panel-title">üìä Performance</div>
      
      <div style="font-size:14px; line-height:2">
        <div>Accuracy: <span id="accuracy" style="font-weight:bold">‚Äî</span></div>
        <div>Avg Response Time: <span id="avgResponse" style="font-weight:bold">‚Äî</span></div>
        <div>Session Progress: <span id="progress" style="font-weight:bold">0%</span></div>
      </div>
      
      <div style="margin-top:20px; padding:10px; background:rgba(0,0,0,0.3); border-radius:6px">
        <div style="font-size:12px; color:var(--mut)">
          G-Load: <span style="color:var(--accent); font-weight:bold">0.95+</span><br>
          Mode: Canonical State-Vector Tracking
        </div>
      </div>
      
      <div class="state-tracker" id="stateTracker">
        <div style="color:var(--accent); font-weight:bold; margin-bottom:5px">Active Symbol States:</div>
        <div id="stateTrackerContent"></div>
      </div>
    </div>
  </div>
  
  <div class="panel">
    <div class="panel-title">üß† Canonical State-Vector N-Back ‚Ä¢ Maximum G-Load (0.95+)</div>
    <div id="premiseDisplay">
      <div style="text-align:center; color:var(--mut); font-size:20px; font-weight:normal">
        Press START to begin canonical state-vector tracking
      </div>
    </div>
    <div id="feedbackArea"></div>
  </div>
</div>

<!-- Instructions Modal -->
<div id="instructionsModal" class="modal">
  <div class="modal-content">
    <span class="close-modal">&times;</span>
    <h2>Canonical State-Vector N-Back (0.95+ G-Load)</h2>
    
    <p>This is the most cognitively demanding n-back variant: tracking persistent symbol identities through accumulating state transformations across time, with conservation laws and scheduled effects.</p>
    
    <h3>Core Concept: Persistent Identity & State Evolution</h3>
    <p>Each symbol has a <strong>canonical identity (ID)</strong> that persists across ALL trials. Surface words may vary (DOG, HOUND, CANINE) but map to the same underlying ID. You must track:</p>
    <ul>
      <li><strong>Identity mapping:</strong> Which surface words refer to which canonical symbols</li>
      <li><strong>State accumulation:</strong> Symbols carry their state forward (position, energy, momentum)</li>
      <li><strong>Scheduled effects:</strong> Operations may execute in future trials (delayed cascades)</li>
      <li><strong>Conservation laws:</strong> Total energy, momentum must balance</li>
    </ul>
    
    <h3>What Makes a True Match?</h3>
    <p>A match requires <strong>identical state trajectories</strong> for all shared symbols‚Äînot just similar patterns. The system simulates forward in time to verify that symbol states evolve identically.</p>
    
    <h3>Example 1: Basic Identity Tracking</h3>
    <div class="example-box">
      Trial 1: "CIRCLE pushes SQUARE moving rightward"
      Internal: C1 pushes S1, C1{x:-1, energy:9}, S1{x:+2, energy:11}
      
      Trial 3: "SPHERE pushes SQUARE moving rightward"
      Internal: C1 pushes S1 (SPHERE maps to same C1!)
      
      MATCH! CIRCLE and SPHERE both map to canonical ID "C1"
      SQUARE remains S1. Same operation, same state changes.
    </div>
    
    <h3>Example 2: State Accumulation Across Trials</h3>
    <div class="example-box">
      Setup: DOG starts at position (0,0), energy 10
      
      Trial 1: "DOG runs toward CAT quickly"
      After: DOG{x:+3, energy:8}, CAT{x:0, energy:10}
      
      Trial 2: [unrelated premise]
      
      Trial 3: "HOUND sprints toward FELINE rapidly"
      Must check: Does HOUND (=DOG) start from x:3, energy:8?
      If yes, and changes match ‚Üí MATCH with Trial 1!
      
      Note: DOG's state from Trial 1 carries forward!
    </div>
    
    <h3>Example 3: Conservation Laws</h3>
    <div class="example-box">
      Trial 1: "ENGINE pushes CART forward strongly"
      Internal: E1{momentum:-2}, C1{momentum:+2}
      Total momentum: 0 ‚úì (conserved)
      
      Trial 3: "MOTOR pushes WAGON forward strongly"
      Internal: M1{momentum:-1}, W1{momentum:+3}
      Total momentum: +2 ‚úó (violation!)
      
      NO MATCH - conservation law broken!
      Even though pattern looks identical.
    </div>
    
    <h3>Example 4: Scheduled/Delayed Effects</h3>
    <div class="example-box">
      Trial 1: "TRIGGER activates TIMER counting down"
      Schedules: TIMER will explode at Trial 3 (t+2)
      
      Trial 2: [unrelated - but TIMER still counting]
      
      Trial 3: [TIMER explodes automatically!]
      You must remember this was scheduled, not new.
      
      Trial 5: "SWITCH activates CLOCK counting down"
      Also schedules explosion at Trial 7 (t+2)
      
      MATCH with Trial 1! Same delayed effect pattern.
    </div>
    
    <h3>Example 5: Complex State Evolution</h3>
    <div class="example-box">
      Trial 1: "WAVE-AND-PARTICLE merge creating QUANTUM"
      W1{energy:5} + P1{energy:5} ‚Üí Q1{energy:10}
      W1 and P1 cease to exist, Q1 created
      
      Trial 3: "QUANTUM splits into WAVE-AND-PARTICLE"
      Q1{energy:10} ‚Üí W1{energy:5} + P1{energy:5}
      Q1 ceases, W1 and P1 recreated with original IDs
      
      Trial 5: "FIELD-AND-PHOTON merge creating BOSON"
      F1{energy:5} + P2{energy:5} ‚Üí B1{energy:10}
      
      Does Trial 5 match Trial 1?
      Check: Same merge pattern? ‚úì
      Conservation satisfied? ‚úì
      Symbol count changes match? ‚úì
      ‚Üí YES, MATCH!
    </div>
    
    <h3>Example 6: Complete Worked Example</h3>
    <div class="example-box">
      Trial 1: "RED-ATOM splits forming TWO-PARTICLES"
      
      Canonical representation:
      - RED-ATOM ‚Üí A1{x:0, y:0, energy:20, momentum:0}
      - Operation: SPLIT
      - Result: P1{energy:10}, P2{energy:10}
      - A1 consumed, P1 and P2 created
      - Conservation: 20 = 10 + 10 ‚úì
      
      Trial 2: "PARTICLES collide and bounce apart"
      - P1 and P2 exchange momentum
      - Both still exist after collision
      
      Trial 3: "BLUE-MOLECULE splits forming TWO-FRAGMENTS"
      
      Checking match with Trial 1:
      1. Map symbols: BLUE-MOLECULE ‚Üí M1, FRAGMENTS ‚Üí F1, F2
      2. Check operation: SPLIT ‚úì
      3. Verify conservation: M1{20} ‚Üí F1{10} + F2{10} ‚úì
      4. Symbol count: 1 ‚Üí 2 ‚úì
      5. Compare trajectories: identical evolution ‚úì
      
      MATCH CONFIRMED!
      
      Proof trace:
      - Mapping: {BLUE-MOLECULE:M1, TWO-FRAGMENTS:F1,F2}
      - States: M1{energy:20} ‚Üí F1{energy:10}, F2{energy:10}
      - Conservation: Energy before=20, after=20 ‚úì
      - Confidence: 0.95
      - Result: MATCH
    </div>
    
    <h3>Key Mental Strategies</h3>
    <ul>
      <li><strong>Maintain a mental ledger</strong> of which surface words map to which IDs</li>
      <li><strong>Track state vectors</strong> for each active symbol (position, energy, momentum)</li>
      <li><strong>Remember scheduled effects</strong> that will trigger in future trials</li>
      <li><strong>Verify conservation</strong> - if energy appears/disappears, it's not a match</li>
      <li><strong>Simulate forward</strong> - mentally run the state evolution to check compatibility</li>
    </ul>
    
    <h3>Why This Achieves 0.95+ G-Load</h3>
    <p>Your working memory must simultaneously:</p>
    <ul>
      <li>Maintain identity mappings (surface ‚Üí canonical)</li>
      <li>Track multi-dimensional state vectors</li>
      <li>Hold n-back history while processing current</li>
      <li>Simulate temporal evolution</li>
      <li>Verify conservation constraints</li>
      <li>Check for scheduled effects</li>
    </ul>
    
    <p><strong>Remember:</strong> Pattern matching won't work. You must track actual symbol states through time. This is pure fluid intelligence at its limit.</p>
  </div>
</div>

<script>
/* ============================================================
   CANONICAL STATE-VECTOR N-BACK WITH PERSISTENT IDENTITY
   True deterministic simulation with conservation laws
   ============================================================ */

// DOM helpers
const $ = id => document.getElementById(id);
const setText = (id, text) => { const el = $(id); if(el) el.textContent = text; };

/* ===== CANONICAL SYMBOL REGISTRY ===== */
class CanonicalRegistry {
  constructor() {
    this.surfaceToId = new Map();  // Surface token ‚Üí canonical ID
    this.idToState = new Map();     // Canonical ID ‚Üí current state
    this.idCounter = 0;
    this.sessionHistory = [];       // Track all mappings
  }
  
  getOrCreateId(surface) {
    // Check if this surface token already mapped
    if (this.surfaceToId.has(surface)) {
      return this.surfaceToId.get(surface);
    }
    
    // Check for synonyms
    const synonyms = this.findSynonyms(surface);
    for (const syn of synonyms) {
      if (this.surfaceToId.has(syn)) {
        const id = this.surfaceToId.get(syn);
        this.surfaceToId.set(surface, id);
        return id;
      }
    }
    
    // Create new canonical ID
    this.idCounter++;
    const id = `${surface[0]}${this.idCounter}`;
    this.surfaceToId.set(surface, id);
    
    // Initialize state vector
    this.idToState.set(id, {
      x: 0,
      y: 0,
      z: 0,
      energy: 10,
      momentum: { x: 0, y: 0, z: 0 },
      phase: 0,
      information: 5,
      exists: true
    });
    
    return id;
  }
  
  findSynonyms(surface) {
    const synonymGroups = [
      ['DOG', 'HOUND', 'CANINE', 'PUP'],
      ['CAT', 'FELINE', 'KITTEN'],
      ['CIRCLE', 'SPHERE', 'BALL', 'ORB'],
      ['SQUARE', 'BOX', 'CUBE', 'BLOCK'],
      ['WAVE', 'RIPPLE', 'SURGE', 'PULSE'],
      ['PARTICLE', 'QUANTUM', 'PHOTON', 'ELECTRON'],
      ['ATOM', 'MOLECULE', 'COMPOUND', 'ELEMENT'],
      ['RED', 'CRIMSON', 'SCARLET', 'RUBY'],
      ['BLUE', 'AZURE', 'COBALT', 'NAVY'],
      ['GREEN', 'EMERALD', 'JADE', 'OLIVE']
    ];
    
    for (const group of synonymGroups) {
      if (group.includes(surface)) {
        return group;
      }
    }
    
    return [];
  }
  
  getState(id) {
    return this.idToState.get(id) || null;
  }
  
  setState(id, newState) {
    this.idToState.set(id, { ...newState });
  }
  
  cloneState(id) {
    const state = this.getState(id);
    if (!state) return null;
    return {
      ...state,
      momentum: { ...state.momentum }
    };
  }
}

/* ===== STATE VECTOR SIMULATION ENGINE ===== */
class StateVectorEngine {
  constructor(registry) {
    this.registry = registry;
    this.scheduledEffects = [];  // Effects to apply in future trials
    this.conservationBaseline = {
      totalEnergy: 100,
      totalMomentum: { x: 0, y: 0, z: 0 },
      totalInformation: 50,
      symbolCount: 0
    };
  }
  
  parseAndSimulate(premise, currentTrial) {
    const parsed = this.parsePremise(premise);
    if (!parsed) return null;
    
    // Map surface tokens to canonical IDs
    const canonicalParsed = this.canonicalize(parsed);
    
    // Apply any scheduled effects for this trial
    this.applyScheduledEffects(currentTrial);
    
    // Apply the current operation
    this.applyOperation(canonicalParsed);
    
    // Check conservation
    const violations = this.checkConservation();
    
    return {
      parsed: canonicalParsed,
      violations: violations,
      stateSnapshot: this.captureStateSnapshot()
    };
  }
  
  parsePremise(text) {
    const words = text.split(' ').filter(w => w.length > 0);
    if (words.length !== 5) return null;
    
    // Extract components based on position and keywords
    const result = {
      subjects: [],
      operation: null,
      relation: null,
      objects: [],
      modifier: null
    };
    
    // Parse based on common patterns
    if (words[1] === 'pushes' || words[1] === 'pulls' || words[1] === 'splits' || 
        words[1] === 'merges' || words[1] === 'triggers' || words[1] === 'activates') {
      // Pattern: SUBJECT VERB OBJECT MODIFIER DIRECTION
      result.subjects = this.extractSymbols(words[0]);
      result.operation = words[1];
      result.objects = this.extractSymbols(words[2]);
      result.modifier = words[3];
      result.direction = words[4];
    } else if (words[2] === 'forming' || words[2] === 'creating' || words[2] === 'into') {
      // Pattern: SUBJECT VERB RELATION OBJECT MODIFIER
      result.subjects = this.extractSymbols(words[0]);
      result.operation = words[1];
      result.relation = words[2];
      result.objects = this.extractSymbols(words[3]);
      result.modifier = words[4];
    } else {
      // Generic pattern
      result.subjects = this.extractSymbols(words[0]);
      result.operation = words[1];
      result.objects = this.extractSymbols(words[2]);
      result.modifier = words[3];
      result.direction = words[4];
    }
    
    return result;
  }
  
  extractSymbols(word) {
    // Handle compound symbols (X-AND-Y, X-WITH-Y)
    if (word.includes('-AND-')) {
      return word.split('-AND-');
    } else if (word.includes('-WITH-')) {
      return word.split('-WITH-');
    } else if (word === 'TWO-PARTICLES' || word === 'TWO-FRAGMENTS') {
      return ['PARTICLE1', 'PARTICLE2'];
    } else if (word === 'TWO-ATOMS') {
      return ['ATOM1', 'ATOM2'];
    }
    return [word];
  }
  
  canonicalize(parsed) {
    const canonical = { ...parsed };
    
    // Map all surface symbols to canonical IDs
    canonical.subjectIds = parsed.subjects.map(s => this.registry.getOrCreateId(s));
    canonical.objectIds = parsed.objects.map(o => this.registry.getOrCreateId(o));
    
    // Map operation to canonical operation
    canonical.canonicalOp = this.mapToCanonicalOp(parsed.operation);
    
    return canonical;
  }
  
  mapToCanonicalOp(operation) {
    const opMap = {
      'pushes': 'PUSH',
      'pulls': 'PULL',
      'splits': 'SPLIT',
      'merges': 'MERGE',
      'triggers': 'CASCADE',
      'activates': 'CASCADE',
      'rotates': 'ROTATE',
      'transforms': 'TRANSFORM',
      'collides': 'COLLIDE',
      'bounces': 'BOUNCE'
    };
    return opMap[operation] || 'UNKNOWN';
  }
  
  applyOperation(canonical) {
    const { subjectIds, objectIds, canonicalOp } = canonical;
    
    switch(canonicalOp) {
      case 'PUSH':
        this.applyPush(subjectIds, objectIds);
        break;
      case 'PULL':
        this.applyPull(subjectIds, objectIds);
        break;
      case 'SPLIT':
        this.applySplit(subjectIds, objectIds);
        break;
      case 'MERGE':
        this.applyMerge(subjectIds, objectIds);
        break;
      case 'CASCADE':
        this.applyCascade(subjectIds, objectIds);
        break;
      case 'ROTATE':
        this.applyRotate(subjectIds);
        break;
    }
  }
  
  applyPush(subjectIds, objectIds) {
    // Conservation: momentum transfer
    for (const subjId of subjectIds) {
      const subj = this.registry.getState(subjId);
      if (!subj || !subj.exists) continue;
      
      subj.momentum.x -= 2;
      subj.energy -= 1;
      this.registry.setState(subjId, subj);
    }
    
    for (const objId of objectIds) {
      const obj = this.registry.getState(objId);
      if (!obj || !obj.exists) continue;
      
      obj.momentum.x += 2;
      obj.energy += 1;
      obj.x += 2;
      this.registry.setState(objId, obj);
    }
  }
  
  applyPull(subjectIds, objectIds) {
    for (const subjId of subjectIds) {
      const subj = this.registry.getState(subjId);
      if (!subj || !subj.exists) continue;
      
      subj.momentum.x += 2;
      subj.energy -= 1;
      this.registry.setState(subjId, subj);
    }
    
    for (const objId of objectIds) {
      const obj = this.registry.getState(objId);
      if (!obj || !obj.exists) continue;
      
      obj.momentum.x -= 2;
      obj.energy += 1;
      obj.x -= 2;
      this.registry.setState(objId, obj);
    }
  }
  
  applySplit(subjectIds, objectIds) {
    // One subject splits into multiple objects
    if (subjectIds.length !== 1 || objectIds.length < 2) return;
    
    const subjId = subjectIds[0];
    const subj = this.registry.getState(subjId);
    if (!subj || !subj.exists) return;
    
    const totalEnergy = subj.energy;
    const energyPerObject = totalEnergy / objectIds.length;
    
    // Mark subject as consumed
    subj.exists = false;
    this.registry.setState(subjId, subj);
    
    // Create/update objects with split energy
    for (const objId of objectIds) {
      let obj = this.registry.getState(objId);
      if (!obj) {
        obj = {
          x: subj.x,
          y: subj.y,
          z: subj.z,
          energy: energyPerObject,
          momentum: { x: subj.momentum.x / objectIds.length, y: 0, z: 0 },
          phase: 0,
          information: subj.information * 2,
          exists: true
        };
      } else {
        obj.energy = energyPerObject;
        obj.exists = true;
      }
      this.registry.setState(objId, obj);
    }
  }
  
  applyMerge(subjectIds, objectIds) {
    // Multiple subjects merge into one object
    if (subjectIds.length < 2 || objectIds.length !== 1) return;
    
    const objId = objectIds[0];
    let totalEnergy = 0;
    let totalMomentum = { x: 0, y: 0, z: 0 };
    
    // Sum energy and momentum from subjects
    for (const subjId of subjectIds) {
      const subj = this.registry.getState(subjId);
      if (!subj || !subj.exists) continue;
      
      totalEnergy += subj.energy;
      totalMomentum.x += subj.momentum.x;
      totalMomentum.y += subj.momentum.y;
      totalMomentum.z += subj.momentum.z;
      
      // Mark subject as consumed
      subj.exists = false;
      this.registry.setState(subjId, subj);
    }
    
    // Create/update merged object
    let obj = this.registry.getState(objId);
    if (!obj) {
      obj = {
        x: 0, y: 0, z: 0,
        energy: totalEnergy,
        momentum: totalMomentum,
        phase: 0,
        information: 10,
        exists: true
      };
    } else {
      obj.energy = totalEnergy;
      obj.momentum = totalMomentum;
      obj.exists = true;
    }
    this.registry.setState(objId, obj);
  }
  
  applyCascade(subjectIds, objectIds, delay = 0) {
    // Schedule future effect
    if (delay > 0) {
      this.scheduledEffects.push({
        trial: delay,
        operation: 'CASCADE',
        subjects: subjectIds,
        objects: objectIds
      });
      return;
    }
    
    // Apply immediate cascade
    for (const subjId of subjectIds) {
      const subj = this.registry.getState(subjId);
      if (!subj || !subj.exists) continue;
      
      subj.energy -= 2;
      this.registry.setState(subjId, subj);
    }
    
    for (const objId of objectIds) {
      const obj = this.registry.getState(objId);
      if (!obj || !obj.exists) continue;
      
      obj.energy += 2;
      obj.phase = (obj.phase + Math.PI/4) % (2 * Math.PI);
      this.registry.setState(objId, obj);
    }
  }
  
  applyRotate(subjectIds) {
    for (const subjId of subjectIds) {
      const subj = this.registry.getState(subjId);
      if (!subj || !subj.exists) continue;
      
      // Rotation swaps momentum components
      const temp = subj.momentum.x;
      subj.momentum.x = subj.momentum.y;
      subj.momentum.y = subj.momentum.z;
      subj.momentum.z = temp;
      
      subj.phase = (subj.phase + Math.PI/2) % (2 * Math.PI);
      this.registry.setState(subjId, subj);
    }
  }
  
  applyScheduledEffects(currentTrial) {
    const toApply = this.scheduledEffects.filter(e => e.trial === currentTrial);
    
    for (const effect of toApply) {
      switch(effect.operation) {
        case 'CASCADE':
          this.applyCascade(effect.subjects, effect.objects, 0);
          break;
      }
    }
    
    // Remove applied effects
    this.scheduledEffects = this.scheduledEffects.filter(e => e.trial !== currentTrial);
  }
  
  checkConservation() {
    const violations = [];
    
    // Calculate current totals
    let totalEnergy = 0;
    let totalMomentum = { x: 0, y: 0, z: 0 };
    let activeSymbols = 0;
    
    for (const [id, state] of this.registry.idToState) {
      if (state.exists) {
        totalEnergy += state.energy;
        totalMomentum.x += state.momentum.x;
        totalMomentum.y += state.momentum.y;
        totalMomentum.z += state.momentum.z;
        activeSymbols++;
      }
    }
    
    // Check conservation violations (with tolerance)
    const tolerance = 0.1;
    
    if (Math.abs(totalMomentum.x) > tolerance || 
        Math.abs(totalMomentum.y) > tolerance ||
        Math.abs(totalMomentum.z) > tolerance) {
      violations.push('momentum');
    }
    
    // Energy can change but should be tracked
    // Information should generally increase (entropy)
    
    return violations;
  }
  
  captureStateSnapshot() {
    const snapshot = {};
    
    for (const [id, state] of this.registry.idToState) {
      if (state.exists) {
        snapshot[id] = { ...state, momentum: { ...state.momentum } };
      }
    }
    
    return snapshot;
  }
  
  compareStates(state1, state2) {
    // Deep comparison of state vectors
    const tolerance = 0.01;
    
    const keys1 = Object.keys(state1).sort();
    const keys2 = Object.keys(state2).sort();
    
    if (keys1.length !== keys2.length) return false;
    
    for (let i = 0; i < keys1.length; i++) {
      if (keys1[i] !== keys2[i]) return false;
      
      const s1 = state1[keys1[i]];
      const s2 = state2[keys2[i]];
      
      if (Math.abs(s1.x - s2.x) > tolerance) return false;
      if (Math.abs(s1.y - s2.y) > tolerance) return false;
      if (Math.abs(s1.energy - s2.energy) > tolerance) return false;
      if (Math.abs(s1.momentum.x - s2.momentum.x) > tolerance) return false;
    }
    
    return true;
  }
}

/* ===== PREMISE GENERATOR ===== */
class CanonicalPremiseGenerator {
  constructor() {
    this.symbols = {
      primary: ['DOG', 'CAT', 'CIRCLE', 'SQUARE', 'ATOM', 'WAVE', 'PARTICLE'],
      secondary: ['HOUND', 'FELINE', 'SPHERE', 'BOX', 'MOLECULE', 'RIPPLE', 'QUANTUM'],
      colors: ['RED', 'BLUE', 'GREEN', 'YELLOW'],
      numbers: ['ONE', 'TWO', 'THREE']
    };
    
    this.operations = ['pushes', 'pulls', 'splits', 'merges', 'triggers', 'activates', 'rotates'];
    this.modifiers = ['forming', 'creating', 'into', 'toward', 'with'];
    this.directions = ['upward', 'downward', 'leftward', 'rightward', 'forward', 'backward', 'quickly', 'slowly', 'strongly'];
    
    this.usedPremises = new Set();
    this.premiseHistory = [];
  }
  
  generate(shouldMatch = false, referenceIndex = null, registry = null) {
    let premise;
    
    if (shouldMatch && referenceIndex !== null && registry) {
      // Generate matching premise with same canonical IDs
      premise = this.generateMatching(referenceIndex, registry);
    } else {
      // Generate new premise
      premise = this.generateNew();
    }
    
    // Avoid exact duplicates
    let attempts = 0;
    while (this.usedPremises.has(premise) && attempts < 50) {
      premise = shouldMatch ? 
        this.generateMatching(referenceIndex, registry) : 
        this.generateNew();
      attempts++;
    }
    
    this.usedPremises.add(premise);
    this.premiseHistory.push(premise);
    
    // Keep history size manageable
    if (this.usedPremises.size > 100) {
      const premises = Array.from(this.usedPremises);
      this.usedPremises = new Set(premises.slice(-50));
    }
    
    return premise;
  }
  
  generateNew() {
    const pattern = Math.floor(Math.random() * 4);
    
    switch(pattern) {
      case 0:
        // Pattern: SUBJECT VERB OBJECT MODIFIER DIRECTION
        return this.pattern1();
      case 1:
        // Pattern: SUBJECT VERB RELATION OBJECT MODIFIER
        return this.pattern2();
      case 2:
        // Pattern: COMPOUND-SUBJECT VERB OBJECT MODIFIER DIRECTION
        return this.pattern3();
      case 3:
        // Pattern: SUBJECT VERB-MODIFIER OBJECT DIRECTION
        return this.pattern4();
      default:
        return this.pattern1();
    }
  }
  
  pattern1() {
    // SUBJECT VERB OBJECT MODIFIER DIRECTION
    const subject = this.randomFrom(this.symbols.primary);
    const verb = this.randomFrom(this.operations);
    const object = this.randomFrom(this.symbols.primary);
    const modifier = this.randomFrom(['moving', 'flowing', 'spinning', 'turning']);
    const direction = this.randomFrom(this.directions);
    
    return `${subject} ${verb} ${object} ${modifier} ${direction}`;
  }
  
  pattern2() {
    // SUBJECT VERB RELATION OBJECT MODIFIER
    const subject = this.randomFrom(this.symbols.primary);
    const verb = 'splits';
    const relation = 'forming';
    const object = 'TWO-PARTICLES';
    const modifier = this.randomFrom(['equally', 'rapidly', 'slowly', 'completely']);
    
    return `${subject} ${verb} ${relation} ${object} ${modifier}`;
  }
  
  pattern3() {
    // COMPOUND-SUBJECT VERB OBJECT MODIFIER DIRECTION
    const subj1 = this.randomFrom(this.symbols.primary);
    const subj2 = this.randomFrom(this.symbols.primary);
    const verb = this.randomFrom(['merges', 'combines']);
    const relation = 'creating';
    const object = this.randomFrom(this.symbols.primary);
    const modifier = this.randomFrom(['instantly', 'gradually', 'completely']);
    
    return `${subj1}-AND-${subj2} ${verb} ${relation} ${object} ${modifier}`;
  }
  
  pattern4() {
    // SUBJECT VERB OBJECT MODIFIER DIRECTION
    const color = this.randomFrom(this.symbols.colors);
    const subject = this.randomFrom(this.symbols.primary);
    const verb = this.randomFrom(this.operations);
    const object = this.randomFrom(this.symbols.primary);
    const direction = this.randomFrom(this.directions);
    
    return `${color}-${subject} ${verb} ${object} ${this.randomFrom(['while', 'when', 'as'])} ${direction}`;
  }
  
  generateMatching(referenceIndex, registry) {
    const reference = this.premiseHistory[referenceIndex];
    if (!reference) return this.generateNew();
    
    // Parse reference to get canonical structure
    const words = reference.split(' ');
    
    // Generate premise with same canonical IDs but varied surface
    // Use synonyms for the same canonical symbols
    const newWords = [];
    
    for (let i = 0; i < words.length; i++) {
      const word = words[i];
      
      // Check if this word is a symbol with a canonical ID
      if (registry.surfaceToId.has(word)) {
        // Find a synonym that maps to same ID
        const id = registry.surfaceToId.get(word);
        const synonyms = registry.findSynonyms(word);
        const validSynonyms = synonyms.filter(s => 
          !registry.surfaceToId.has(s) || registry.surfaceToId.get(s) === id
        );
        
        if (validSynonyms.length > 0 && Math.random() > 0.5) {
          const newWord = this.randomFrom(validSynonyms);
          registry.surfaceToId.set(newWord, id);  // Map synonym to same ID
          newWords.push(newWord);
        } else {
          newWords.push(word);  // Keep original
        }
      } else if (this.operations.includes(word)) {
        // Keep same operation for true match
        newWords.push(word);
      } else {
        // Vary other words freely
        if (this.directions.includes(word)) {
          newWords.push(this.randomFrom(this.directions));
        } else if (this.modifiers.includes(word)) {
          newWords.push(this.randomFrom(this.modifiers));
        } else {
          newWords.push(word);
        }
      }
    }
    
    return newWords.join(' ');
  }
  
  randomFrom(array) {
    return array[Math.floor(Math.random() * array.length)];
  }
}

/* ===== GAME CONTROLLER ===== */
class CanonicalStateVectorNBack {
  constructor() {
    this.registry = new CanonicalRegistry();
    this.engine = new StateVectorEngine(this.registry);
    this.generator = new CanonicalPremiseGenerator();
    
    this.history = [];
    this.stateHistory = [];
    this.schedule = [];
    
    // Settings
    this.nLevel = 2;
    this.totalTrials = 50;
    this.matchProbability = 0.3;
    this.responseWindow = 8000;
    this.statementsPerTrial = 1;
    this.voiceEnabled = true;
    
    // State
    this.currentTrial = 0;
    this.isRunning = false;
    this.isPaused = false;
    this.awaitingResponse = false;
    this.responseTimer = null;
    this.countdownInterval = null;
    
    // Scoring
    this.correctHits = 0;
    this.falseAlarms = 0;
    this.misses = 0;
    this.responseTimes = [];
    
    // Timing
    this.trialStartTime = 0;
  }
  
  initialize(settings) {
    this.nLevel = settings.nLevel;
    this.totalTrials = settings.totalTrials;
    this.matchProbability = settings.matchProbability;
    this.responseWindow = settings.responseWindow;
    this.statementsPerTrial = settings.statementsPerTrial;
    this.voiceEnabled = settings.voiceEnabled;
    
    this.reset();
    this.generateSchedule();
  }
  
  reset() {
    this.registry = new CanonicalRegistry();
    this.engine = new StateVectorEngine(this.registry);
    this.generator = new CanonicalPremiseGenerator();
    
    this.history = [];
    this.stateHistory = [];
    this.schedule = [];
    this.currentTrial = 0;
    this.correctHits = 0;
    this.falseAlarms = 0;
    this.misses = 0;
    this.responseTimes = [];
    this.awaitingResponse = false;
  }
  
  generateSchedule() {
    this.schedule = new Array(this.totalTrials).fill(false);
    
    for (let i = this.nLevel; i < this.totalTrials; i++) {
      if (Math.random() < this.matchProbability) {
        this.schedule[i] = true;
      }
    }
  }
  
  async runTrial() {
    if (!this.isRunning || this.isPaused) return;
    
    this.awaitingResponse = true;
    const shouldMatch = this.schedule[this.currentTrial];
    
    const premises = [];
    const states = [];
    
    for (let i = 0; i < this.statementsPerTrial; i++) {
      let premise;
      
      if (shouldMatch && this.currentTrial >= this.nLevel) {
        const referenceIndex = this.currentTrial - this.nLevel;
        premise = this.generator.generate(true, referenceIndex, this.registry);
      } else {
        premise = this.generator.generate(false);
      }
      
      premises.push(premise);
      
      // Simulate and capture state
      const result = this.engine.parseAndSimulate(premise, this.currentTrial);
      states.push(result);
    }
    
    this.history[this.currentTrial] = premises;
    this.stateHistory[this.currentTrial] = states;
    
    // Display premise and state
    this.displayPremise(premises);
    this.updateStateTracker();
    
    // Start response timer
    this.trialStartTime = Date.now();
    this.startResponseTimer();
    
    // Voice synthesis
    if (this.voiceEnabled) {
      await this.speak(premises.join('. '));
    }
  }
  
  displayPremise(premises) {
    const display = $('premiseDisplay');
    display.innerHTML = '';
    
    premises.forEach(premise => {
      const div = document.createElement('div');
      div.className = 'premise-text';
      
      const words = premise.split(' ');
      words.forEach((word, idx) => {
        const span = document.createElement('span');
        
        // Style based on word type
        if (word.includes('-AND-') || word.includes('-WITH-')) {
          span.className = 'compound';
        } else if (['pushes', 'pulls', 'splits', 'merges', 'triggers', 'activates', 'rotates'].includes(word)) {
          span.className = 'operation';
        } else if (['forming', 'creating', 'into', 'toward'].includes(word)) {
          span.className = 'relation';
        } else if (this.generator.directions.includes(word)) {
          span.className = 'state';
        } else if (word.startsWith('RED') || word.startsWith('BLUE') || word.startsWith('GREEN')) {
          span.className = 'sym-color';
          if (word.startsWith('RED')) span.style.color = '#ff6b6b';
          if (word.startsWith('BLUE')) span.style.color = '#4ecdc4';
          if (word.startsWith('GREEN')) span.style.color = '#26de81';
        } else if (this.registry.surfaceToId.has(word)) {
          span.className = 'sym-primary';
        }
        
        span.textContent = word;
        div.appendChild(span);
        
        if (idx < words.length - 1) {
          div.appendChild(document.createTextNode(' '));
        }
      });
      
      display.appendChild(div);
    });
    
    setText('currentTrial', this.currentTrial + 1);
    setText('progress', Math.round((this.currentTrial / this.totalTrials) * 100) + '%');
  }
  
  updateStateTracker() {
    const tracker = $('stateTracker');
    const content = $('stateTrackerContent');
    
    tracker.classList.add('active');
    content.innerHTML = '';
    
    // Show active symbol states
    for (const [id, state] of this.registry.idToState) {
      if (!state.exists) continue;
      
      const div = document.createElement('div');
      div.style.marginBottom = '3px';
      div.innerHTML = `<span style="color:#00ccff">${id}:</span> ` +
        `pos(${state.x.toFixed(1)},${state.y.toFixed(1)}) ` +
        `E:${state.energy.toFixed(1)} ` +
        `p:(${state.momentum.x.toFixed(1)},${state.momentum.y.toFixed(1)})`;
      content.appendChild(div);
    }
  }
  
  startResponseTimer() {
    let timeLeft = this.responseWindow;
    this.countdownInterval = setInterval(() => {
      timeLeft -= 100;
      setText('countdown', (timeLeft / 1000).toFixed(1) + 's');
      
      if (timeLeft <= 0) {
        clearInterval(this.countdownInterval);
        setText('countdown', '0.0s');
      }
    }, 100);
    
    this.responseTimer = setTimeout(() => {
      this.endTrial();
    }, this.responseWindow);
  }
  
  registerResponse() {
    if (!this.awaitingResponse || !this.isRunning) return;
    
    const responseTime = Date.now() - this.trialStartTime;
    this.responseTimes.push(responseTime);
    
    this.awaitingResponse = false;
    
    if (this.responseTimer) clearTimeout(this.responseTimer);
    if (this.countdownInterval) clearInterval(this.countdownInterval);
    
    // Evaluate response
    const shouldHaveResponded = this.schedule[this.currentTrial] && this.currentTrial >= this.nLevel;
    const isMatch = this.verifyMatch();
    
    if (shouldHaveResponded && isMatch) {
      this.correctHits++;
      this.showFeedback('correct', 'Correct! State trajectories match.');
    } else if (!shouldHaveResponded && !isMatch) {
      this.correctHits++;
      this.showFeedback('correct', 'Correct! No match detected.');
    } else if (shouldHaveResponded && !isMatch) {
      this.misses++;
      this.showFeedback('missed', 'Missed! The state trajectories matched.');
    } else {
      this.falseAlarms++;
      this.showFeedback('incorrect', 'Incorrect. Different state evolution.');
    }
    
    setTimeout(() => {
      this.nextTrial();
    }, 2000);
  }
  
  verifyMatch() {
    if (this.currentTrial < this.nLevel) return false;
    
    const currentStates = this.stateHistory[this.currentTrial];
    const referenceStates = this.stateHistory[this.currentTrial - this.nLevel];
    
    if (!currentStates || !referenceStates) return false;
    
    // Compare state snapshots
    for (let i = 0; i < currentStates.length; i++) {
      if (!currentStates[i] || !referenceStates[i]) return false;
      
      const current = currentStates[i].stateSnapshot;
      const reference = referenceStates[i].stateSnapshot;
      
      // Check if states evolve identically
      if (!this.engine.compareStates(current, reference)) {
        return false;
      }
      
      // Check conservation violations
      if (currentStates[i].violations.length !== referenceStates[i].violations.length) {
        return false;
      }
    }
    
    return true;
  }
  
  endTrial() {
    this.awaitingResponse = false;
    
    if (this.responseTimer) clearTimeout(this.responseTimer);
    if (this.countdownInterval) clearInterval(this.countdownInterval);
    
    const shouldHaveResponded = this.schedule[this.currentTrial] && this.currentTrial >= this.nLevel;
    
    if (shouldHaveResponded) {
      this.misses++;
      this.showFeedback('missed', 'Missed match! State trajectories were identical.');
    } else {
      this.correctHits++;
    }
    
    setTimeout(() => {
      this.nextTrial();
    }, 2000);
  }
  
  showFeedback(type, message) {
    const area = $('feedbackArea');
    area.innerHTML = '';
    
    const div = document.createElement('div');
    div.className = `feedback ${type}`;
    div.textContent = message;
    
    // Add proof trace for matches
    if (type === 'correct' && this.currentTrial >= this.nLevel) {
      const proof = document.createElement('div');
      proof.className = 'proof-trace';
      proof.innerHTML = `<strong>Proof:</strong> Symbol states evolved identically. Conservation verified.`;
      div.appendChild(proof);
    }
    
    area.appendChild(div);
    
    setText('correctHits', this.correctHits);
    setText('falseAlarms', this.falseAlarms);
    setText('misses', this.misses);
    
    const total = this.correctHits + this.falseAlarms + this.misses;
    if (total > 0) {
      const accuracy = (this.correctHits / total * 100).toFixed(1);
      setText('accuracy', accuracy + '%');
    }
    
    if (this.responseTimes.length > 0) {
      const avg = this.responseTimes.reduce((a,b) => a+b, 0) / this.responseTimes.length;
      setText('avgResponse', (avg / 1000).toFixed(2) + 's');
    }
  }
  
  nextTrial() {
    $('feedbackArea').innerHTML = '';
    
    this.currentTrial++;
    
    if (this.currentTrial >= this.totalTrials) {
      this.endSession();
    } else {
      this.runTrial();
    }
  }
  
  endSession() {
    this.isRunning = false;
    
    const display = $('premiseDisplay');
    display.innerHTML = `
      <div style="text-align:center; padding:40px;">
        <h2 style="color:var(--accent); margin-bottom:20px">Session Complete!</h2>
        <div style="font-size:18px; font-weight:normal; line-height:2">
          <div>Correct Hits: <span style="color:var(--success)">${this.correctHits}</span></div>
          <div>False Alarms: <span style="color:var(--error)">${this.falseAlarms}</span></div>
          <div>Missed Matches: <span style="color:var(--warning)">${this.misses}</span></div>
          <div style="margin-top:20px">
            Final Accuracy: <strong>${((this.correctHits / this.totalTrials) * 100).toFixed(1)}%</strong>
          </div>
        </div>
      </div>
    `;
    
    $('stateTracker').classList.remove('active');
    $('startBtn').disabled = false;
    $('pauseBtn').disabled = true;
    $('resetBtn').disabled = true;
  }
  
  async speak(text) {
    if (!this.voiceEnabled || !window.speechSynthesis) return;
    
    return new Promise(resolve => {
      const utterance = new SpeechSynthesisUtterance(text);
      utterance.lang = 'en-US';
      utterance.rate = 0.75;
      utterance.pitch = 1.0;
      utterance.volume = 1.0;
      utterance.onend = resolve;
      utterance.onerror = resolve;
      
      if (window.speechSynthesis.speaking) {
        window.speechSynthesis.cancel();
      }
      
      window.speechSynthesis.speak(utterance);
    });
  }
  
  pause() {
    this.isPaused = true;
    if (this.responseTimer) clearTimeout(this.responseTimer);
    if (this.countdownInterval) clearInterval(this.countdownInterval);
  }
  
  resume() {
    this.isPaused = false;
    this.runTrial();
  }
}

/* ===== MAIN GAME INSTANCE ===== */
const game = new CanonicalStateVectorNBack();

// UI Event Handlers
function start() {
  const settings = {
    nLevel: parseInt($('nbackLevel').value),
    totalTrials: 50,
    matchProbability: parseInt($('matchProbability').value) / 100,
    responseWindow: parseFloat($('responseWindow').value) * 1000,
    statementsPerTrial: parseInt($('statementsPerTrial').value),
    voiceEnabled: $('voiceEnabled').checked
  };
  
  game.initialize(settings);
  game.isRunning = true;
  
  setText('totalTrials', settings.totalTrials);
  setText('correctHits', '0');
  setText('falseAlarms', '0');
  setText('misses', '0');
  setText('accuracy', '‚Äî');
  setText('avgResponse', '‚Äî');
  setText('progress', '0%');
  
  $('startBtn').disabled = true;
  $('pauseBtn').disabled = false;
  $('resetBtn').disabled = false;
  
  game.runTrial();
}

function pause() {
  if (game.isPaused) {
    game.resume();
    $('pauseBtn').textContent = '‚è∏ Pause';
  } else {
    game.pause();
    $('pauseBtn').textContent = '‚ñ∂ Resume';
  }
}

function reset() {
  game.isRunning = false;
  game.reset();
  
  if (game.responseTimer) clearTimeout(game.responseTimer);
  if (game.countdownInterval) clearInterval(game.countdownInterval);
  
  $('premiseDisplay').innerHTML = `
    <div style="text-align:center; color:var(--mut); font-size:20px; font-weight:normal">
      Press START to begin canonical state-vector tracking
    </div>
  `;
  $('feedbackArea').innerHTML = '';
  $('stateTracker').classList.remove('active');
  
  setText('currentTrial', '0');
  setText('correctHits', '0');
  setText('falseAlarms', '0');
  setText('misses', '0');
  setText('accuracy', '‚Äî');
  setText('avgResponse', '‚Äî');
  setText('progress', '0%');
  setText('countdown', '‚Äî');
  
  $('startBtn').disabled = false;
  $('pauseBtn').disabled = true;
  $('resetBtn').disabled = true;
  $('pauseBtn').textContent = '‚è∏ Pause';
  
  if (window.speechSynthesis) {
    window.speechSynthesis.cancel();
  }
}

// Initialize event listeners
document.addEventListener('DOMContentLoaded', () => {
  $('nbackLevel').oninput = (e) => {
    setText('nbackValue', e.target.value);
  };
  
  $('statementsPerTrial').oninput = (e) => {
    setText('stmtValue', e.target.value);
  };
  
  $('matchProbability').oninput = (e) => {
    setText('matchProbValue', e.target.value + '%');
  };
  
  $('responseWindow').oninput = (e) => {
    setText('windowValue', parseFloat(e.target.value).toFixed(1) + 's');
  };
  
  $('startBtn').onclick = start;
  $('pauseBtn').onclick = pause;
  $('resetBtn').onclick = reset;
  
  window.addEventListener('keydown', (e) => {
    if (e.code === 'Space' && game.isRunning && !game.isPaused) {
      e.preventDefault();
      game.registerResponse();
    }
  });
  
  const modal = $('instructionsModal');
  const btn = $('instructionsBtn');
  const closeBtn = document.querySelector('.close-modal');
  
  btn.onclick = () => modal.style.display = 'block';
  closeBtn.onclick = () => modal.style.display = 'none';
  window.onclick = (e) => {
    if (e.target === modal) modal.style.display = 'none';
  };
});
</script>
</body>
</html>
