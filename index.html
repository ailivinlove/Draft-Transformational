<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>Quantum Semantic N-Back ‚Äî Maximum G-Load 0.90+ (5 Words)</title>
<style>
:root { --bg:#0b0d10; --fg:#e6fbff; --a:#00ccff; --mut:#8fe7ff }
*{ box-sizing:border-box }
html,body{ height:100% }
body{ margin:0; background:#0b0d10; color:#e6fbff; font-family:system-ui,-apple-system,Segoe UI,Roboto,sans-serif }
.wrap{ max-width:1280px; margin:0 auto; padding:16px }
.row{ display:flex; gap:12px; flex-wrap:wrap }
.col{ flex:1 1 360px }
.box{ background:#101418; border:1px solid rgba(0,200,255,.25); border-radius:14px; padding:12px }
.title{ font-weight:800; margin-bottom:6px; letter-spacing:.3px }
.btn{ background:#0b0d10; color:#00ccff; border:1px solid #00ccff; border-radius:10px; padding:10px 14px; font-weight:700; cursor:pointer }
.btn:disabled{ opacity:.5; cursor:not-allowed }
label{ font-size:12px; color:#8fe7ff; display:block; margin:6px 0 }
input[type=range], input[type=number]{ width:100% }
.kbd{ border:1px solid rgba(255,255,255,.25); padding:2px 6px; border-radius:6px; background:#0b0d10 }
.mut{ color:#8fe7ff; font-size:12px }
hr.hr{border:none;border-top:1px solid rgba(0,200,255,.25);margin:8px 0}
#premiseContainer{ margin-top:12px; min-height:140px; background:#0e1113; border:1px solid rgba(0,200,255,.25); border-radius:12px; padding:12px; font-size:30px; line-height:2.1; word-break:break-word; font-family:'Courier New',monospace; font-weight:900; letter-spacing:2px }
.premise-line{ margin:14px 0; padding:16px; border-left:7px solid rgba(0,200,255,.7); background:linear-gradient(90deg, rgba(0,200,255,.2), rgba(0,200,255,.05)); border-radius:4px; position:relative }
.premise-number{ position:absolute; left:-40px; top:50%; transform:translateY(-50%); color:#00ccff; font-size:20px; font-weight:bold }
.badge{ display:inline-block; padding:2px 8px; border:1px solid rgba(0,200,255,.35); border-radius:999px; font-size:12px; color:#8fe7ff; margin-left:6px }
#countdown{ font-weight:800; color:#00ccff }
.entity{ color:#ff6b6b; text-shadow:0 0 14px rgba(255,107,107,.8) }
.operation{ color:#4ecdc4; text-shadow:0 0 12px rgba(78,205,196,.8) }
.direction{ color:#f7b731; text-shadow:0 0 12px rgba(247,183,49,.8) }
.state{ color:#5f27cd; text-shadow:0 0 12px rgba(95,39,205,.8) }
.mediator{ color:#a55eea; font-weight:900; text-shadow:0 0 16px rgba(165,94,234,.9) }
.temporal{ color:#26de81; text-shadow:0 0 12px rgba(38,222,129,.8) }
.quant{ color:#fd79a8; text-shadow:0 0 12px rgba(253,121,168,.8) }
.compound{ color:#00d2d3; text-decoration:underline; text-shadow:0 0 10px rgba(0,210,211,.7) }
.slash{ color:#ff9ff3; font-weight:900; font-size:110% }
.paradox{ color:#ffd700; font-weight:bold; text-shadow:0 0 15px rgba(255,215,0,.9) }
.meta{ color:#00ff88; font-weight:bold; text-decoration:overline }
.quantum{ color:#b19cd9; font-style:italic; text-shadow:0 0 12px rgba(177,156,217,.8) }
.meta-info{ font-size:13px; color:#4a8aff; margin-top:12px; opacity:0.9; font-weight:normal }
</style>
</head>
<body>
<div class="wrap">
  <div class="row">
    <div class="col">
      <div class="box">
        <div class="title">Quantum Configuration</div>
        <div class="mut" id="diffExplain">Quantum Semantic Compression ‚Ä¢ G-Load: ~0.90+</div>
        <hr class="hr">
        <label>N-Back level: <span id="nVal">1</span></label>
        <input id="nback" type="range" min="1" max="5" step="1" value="1">
        <hr class="hr">
        <label>Statements per trial: <span id="stmtVal">1</span></label>
        <input id="statements" type="range" min="1" max="5" step="1" value="1">
        <div class="mut small">Multiple statements create quantum interference patterns</div>
      </div>
    </div>

    <div class="col">
      <div class="box">
        <div class="title">Timing & Block</div>
        <div class="mut">Solve window: <strong><span id="solveLabel">5.0</span>s</strong> after speaking.</div>
        <label>Solve window (1‚Äì30s): <span id="solveVal">5.0s</span></label>
        <input id="solveWindow" type="range" min="1" max="30" step="0.1" value="5">
        <label>Trials per block: <span id="tVal">200</span></label>
        <input id="trials" type="range" min="20" max="500" step="10" value="200">
        <label>Target match rate: <span id="rVal">25%</span></label>
        <input id="rate" type="range" min="0" max="100" step="1" value="25">
        <label><input id="speakEnabled" type="checkbox" checked> Speak sentences</label>
      </div>
    </div>

    <div class="col">
      <div class="box">
        <div class="title">Controls / Status</div>
        <div style="display:flex; gap:8px; flex-wrap:wrap; margin-top:6px">
          <button id="start" class="btn">‚ñ∂ Start</button>
          <button id="pause" class="btn" disabled>‚è∏ Pause</button>
          <button id="reset" class="btn" disabled>üîÑ Reset</button>
          <button id="hit" class="btn" disabled>‚úì Match (<span class="kbd">Space</span>)</button>
          <button id="skip" class="btn" disabled>‚è≠ Skip</button>
        </div>
        <div class="mut" style="margin-top:8px">
          Trial <span id="idx">0</span>/<span id="max">200</span>
          <span class="badge">Planned: <span id="ptype">‚Äî</span></span>
          <span class="badge">Actual: <span id="isMatch">‚Äî</span></span>
          <span class="badge">Countdown: <span id="countdown">‚Äî</span></span>
        </div>
        <div class="mut">Correct: <span id="corr">0</span> ‚Ä¢ Errors: <span id="err">0</span></div>
        <div class="mut small" id="modeLine">Quantum Semantic ‚Ä¢ G-Load: ~0.90+ ‚Ä¢ N=1</div>
      </div>
    </div>
  </div>

  <div class="box" style="margin-top:12px">
    <div class="title">Quantum Semantic N-Back <span class="badge">‚â§5 words</span> <span class="badge">Maximum g-load</span></div>
    <div id="premiseContainer" aria-live="polite">‚Äî</div>
  </div>

  <div id="log" style="display:none" aria-hidden="true">‚Äî</div>
</div>

<script>
/* ============================================================
   QUANTUM SEMANTIC N-BACK
   Maximum g-load through 5-word quantum compression
   ============================================================ */

const $ = id => document.getElementById(id);
function setText(id,v){ const el=$(id); if(el) el.textContent=v; }
function shuffle(a){ for(let i=a.length-1;i>0;i--){ const j=(Math.random()*(i+1))|0; [a[i],a[j]]=[a[j],a[i]] } return a; }

/* ===== QUANTUM SEMANTIC GENERATOR ===== */
class QuantumSemanticGenerator {
    constructor() {
        // Phase entities with transformation properties
        this.phaseEntities = [
            'WAVE', 'PARTICLE', 'FIELD', 'VOID', 'FLUX',
            'SOLID', 'LIQUID', 'PLASMA', 'VAPOR', 'CRYSTAL',
            'ORDER', 'CHAOS', 'ENTROPY', 'SYMMETRY', 'FRACTAL',
            'LIGHT', 'SHADOW', 'PRISM', 'SPECTRUM', 'PHOTON',
            'SPIN', 'CHARGE', 'MASS', 'ENERGY', 'MOMENTUM'
        ];

        // Paradox nodes
        this.paradoxNodes = [
            'BOTH', 'NEITHER', 'ALL', 'NONE', 'ALWAYS', 'NEVER',
            'EVERYWHERE', 'NOWHERE', 'INFINITE', 'ZERO', 'NULL',
            'TRUE', 'FALSE', 'MAYBE', 'CERTAIN', 'UNCERTAIN'
        ];

        // Transformation operators
        this.transformOps = [
            'dissolves', 'crystallizes', 'inverts', 'recurses', 'cascades',
            'fragments', 'coalesces', 'oscillates', 'resonates', 'interferes',
            'collapses', 'expands', 'contracts', 'rotates', 'reflects',
            'refracts', 'diffracts', 'tunnels', 'entangles', 'superimposes'
        ];

        // Meta operators
        this.metaOps = [
            'through', 'becomes', 'negates', 'affirms', 'via',
            'within', 'beyond', 'across', 'between', 'without'
        ];

        // Compound modifiers for hyphenation
        this.modifiers = [
            'inversely', 'fractally', 'quantumly', 'eternally', 'infinitely',
            'paradoxically', 'recursively', 'dimensionally', 'temporally', 'spatially'
        ];

        // Directional paradoxes
        this.directions = [
            'INWARD', 'OUTWARD', 'UPWARD', 'DOWNWARD', 'FORWARD', 'BACKWARD',
            'LEFTWARD', 'RIGHTWARD', 'NOWHERE', 'EVERYWHERE'
        ];

        // Mathematical symbols as semantic modifiers
        this.mathSymbols = ['¬≤', '¬≥', '‚àû', '‚àÖ', '√ó', '√∑', '¬±', '‚âà'];

        // Meta references
        this.metaRefs = ['IT', 'THAT', 'THIS', 'ITSELF', 'OTHER'];

        // Taboo list to prevent repetition
        this.tabooList = [];
        this.maxTaboo = 50;

        // Session entropy for true randomization
        this.sessionEntropy = Date.now();
        this.trialCounter = 0;
    }

    // Generate cryptographic hash for true randomization
    generateHash(trial, seed = 0) {
        const input = `${this.sessionEntropy}-${trial}-${seed}-${Date.now()}-${Math.random()}`;
        let hash = 0;
        for (let i = 0; i < input.length; i++) {
            const char = input.charCodeAt(i);
            hash = ((hash << 5) - hash) + char;
            hash = hash & hash;
        }
        return Math.abs(hash);
    }

    // Generate unique premise ensuring no repetition
    generatePremise(trial, nback, count = 1) {
        const premises = [];
        this.trialCounter++;
        
        for (let i = 0; i < count; i++) {
            let premise;
            let attempts = 0;
            
            do {
                premise = this.buildQuantumPremise(trial + i, i, count);
                attempts++;
            } while (this.isInTaboo(premise.text) && attempts < 100);
            
            this.addToTaboo(premise.text);
            premises.push(premise);
        }
        
        return premises;
    }

    // Build quantum semantic premise (5 words max)
    buildQuantumPremise(trial, index, total) {
        const hash = this.generateHash(trial, index);
        const pattern = hash % 4;
        
        let text = '';
        let structure = {};
        
        switch(pattern) {
            case 0: // Pattern Œ±: [ENTITY‚ÇÅ] [TRANS-OP] [ENTITY‚ÇÇ] [META-OP] [ENTITY‚ÇÉ]
                text = this.patternAlpha(hash);
                break;
            case 1: // Pattern Œ≤: [PARADOX] [RECURSIVE-OP] [ENTITY√óENTITY] [DIMENSIONAL-FOLD]
                text = this.patternBeta(hash);
                break;
            case 2: // Pattern Œ≥: [META-REF] [QUANTUM-OP] [COMPOUND-STATE] [TRANSFORM]
                text = this.patternGamma(hash, index);
                break;
            case 3: // Pattern Œ¥: [ENTITY] [BECOMES] [ANTI-ENTITY] [VIA] [PARADOX]
                text = this.patternDelta(hash);
                break;
        }
        
        // Inject entropy every 7th premise
        if (trial % 7 === 0) {
            text = this.injectEntropy(text, hash);
        }
        
        structure = this.extractStructure(text);
        
        return {
            text: text,
            structure: structure,
            hash: hash,
            pattern: pattern
        };
    }

    // Pattern Œ±: Entity transformation chain
    patternAlpha(hash) {
        const e1 = this.getUnique(this.phaseEntities, hash);
        const op = this.getUnique(this.transformOps, hash + 1);
        const e2 = this.getUnique(this.phaseEntities, hash + 2);
        const meta = this.getUnique(this.metaOps, hash + 3);
        const e3 = this.getUnique(this.phaseEntities, hash + 4);
        
        // Create compound operation for compression
        const mod = this.getUnique(this.modifiers, hash + 5);
        const compoundOp = `${mod}-${op}`;
        
        return `${e1} ${compoundOp} ${e2} ${meta} ${e3}`;
    }

    // Pattern Œ≤: Paradox recursion
    patternBeta(hash) {
        const paradox1 = this.getUnique(this.paradoxNodes, hash);
        const paradox2 = this.getUnique(this.paradoxNodes, hash + 1);
        const paradoxPair = `${paradox1}/${paradox2}`;
        
        const op = this.getUnique(this.transformOps, hash + 2);
        const e1 = this.getUnique(this.phaseEntities, hash + 3);
        const e2 = this.getUnique(this.phaseEntities, hash + 4);
        const entityPair = `${e1}√ó${e2}`;
        
        const mod = this.getUnique(this.modifiers, hash + 5);
        
        return `${paradoxPair} ${op} ${entityPair} ${mod}`;
    }

    // Pattern Œ≥: Meta-recursive reference
    patternGamma(hash, index) {
        const metaRef = index > 0 ? 'IT' : this.getUnique(this.metaRefs, hash);
        const symbol = this.getUnique(this.mathSymbols, hash + 1);
        const metaCompound = `${metaRef}${symbol}`;
        
        const op1 = this.getUnique(this.transformOps, hash + 2);
        const op2 = this.getUnique(this.transformOps, hash + 3);
        const quantumOp = `${op1}-${op2}`;
        
        const e1 = this.getUnique(this.phaseEntities, hash + 4);
        const e2 = this.getUnique(this.phaseEntities, hash + 5);
        const state = `${e1}‚ü∑${e2}`;
        
        const mod = this.getUnique(this.modifiers, hash + 6);
        
        return `${metaCompound} ${quantumOp} ${state} ${mod}`;
    }

    // Pattern Œ¥: Entity inversion
    patternDelta(hash) {
        const e1 = this.getUnique(this.phaseEntities, hash);
        const antiE = this.getAntiEntity(e1, hash + 1);
        const paradox = this.getUnique(this.paradoxNodes, hash + 2);
        
        const via = 'becomes';
        const through = 'via';
        
        return `${e1} ${via} ${antiE} ${through} ${paradox}`;
    }

    // Get anti-entity (opposite)
    getAntiEntity(entity, hash) {
        const opposites = {
            'WAVE': 'PARTICLE', 'PARTICLE': 'WAVE',
            'ORDER': 'CHAOS', 'CHAOS': 'ORDER',
            'LIGHT': 'SHADOW', 'SHADOW': 'LIGHT',
            'SOLID': 'PLASMA', 'PLASMA': 'SOLID',
            'EVERYWHERE': 'NOWHERE', 'NOWHERE': 'EVERYWHERE',
            'ALWAYS': 'NEVER', 'NEVER': 'ALWAYS',
            'ALL': 'NONE', 'NONE': 'ALL',
            'TRUE': 'FALSE', 'FALSE': 'TRUE',
            'INFINITE': 'ZERO', 'ZERO': 'INFINITE'
        };
        
        return opposites[entity] || this.getUnique(this.phaseEntities.filter(e => e !== entity), hash);
    }

    // Inject maximum entropy for every 7th premise
    injectEntropy(text, hash) {
        const entropyOps = [
            'freezes-while-boiling',
            'shrinks-while-expanding', 
            'exists-without-being',
            'moves-while-still',
            'creates-by-destroying'
        ];
        
        const words = text.split(' ');
        if (words.length >= 2) {
            words[1] = this.getUnique(entropyOps, hash);
            return words.slice(0, 5).join(' ');
        }
        return text;
    }

    // Get unique item avoiding recent usage
    getUnique(pool, hash) {
        const available = pool.filter(item => {
            // Check if item was used in last 10 premises
            const recentText = this.tabooList.slice(-10).join(' ');
            return !recentText.includes(item);
        });
        
        const selection = available.length > 0 ? available : pool;
        return selection[Math.abs(hash) % selection.length];
    }

    // Taboo list management
    isInTaboo(text) {
        return this.tabooList.some(t => {
            // Check Levenshtein distance
            return this.levenshteinDistance(t, text) < 3;
        });
    }

    addToTaboo(text) {
        this.tabooList.push(text);
        if (this.tabooList.length > this.maxTaboo) {
            this.tabooList.shift();
        }
    }

    // Levenshtein distance for similarity checking
    levenshteinDistance(a, b) {
        const matrix = [];
        for (let i = 0; i <= b.length; i++) {
            matrix[i] = [i];
        }
        for (let j = 0; j <= a.length; j++) {
            matrix[0][j] = j;
        }
        for (let i = 1; i <= b.length; i++) {
            for (let j = 1; j <= a.length; j++) {
                if (b.charAt(i - 1) === a.charAt(j - 1)) {
                    matrix[i][j] = matrix[i - 1][j - 1];
                } else {
                    matrix[i][j] = Math.min(
                        matrix[i - 1][j - 1] + 1,
                        matrix[i][j - 1] + 1,
                        matrix[i - 1][j] + 1
                    );
                }
            }
        }
        return matrix[b.length][a.length];
    }

    // Deep structure extraction for compatibility checking
    extractStructure(text) {
        const s = {
            transformations: [],
            entities: [],
            paradoxes: [],
            operations: [],
            dimensionalFold: 0,
            recursionDepth: 0,
            quantumState: '',
            topology: ''
        };

        // Extract transformations
        this.transformOps.forEach(op => {
            if (text.includes(op)) s.transformations.push(op);
        });

        // Extract entities
        this.phaseEntities.forEach(e => {
            if (text.includes(e)) s.entities.push(e);
        });

        // Extract paradoxes
        this.paradoxNodes.forEach(p => {
            if (text.includes(p)) s.paradoxes.push(p);
        });

        // Count dimensional folds (hyphens, slashes, compounds)
        s.dimensionalFold = (text.match(/[-\/√ó‚ü∑]/g) || []).length;

        // Check recursion depth
        s.recursionDepth = (text.match(/IT¬≤|ITSELF|recurse/gi) || []).length;

        // Determine quantum state
        if (text.includes('‚ü∑')) s.quantumState = 'superposition';
        else if (text.includes('/')) s.quantumState = 'entangled';
        else if (text.includes('√ó')) s.quantumState = 'interfering';
        else s.quantumState = 'collapsed';

        // Determine topology
        if (s.transformations.length > 1) s.topology = 'branching';
        else if (s.recursionDepth > 0) s.topology = 'looping';
        else if (s.paradoxes.length > 0) s.topology = 'inverting';
        else s.topology = 'linear';

        return s;
    }

    // Deep compatibility checking for n-back matching
    checkCompatibility(p1, p2) {
        const s1 = typeof p1 === 'object' ? p1.structure : this.extractStructure(p1);
        const s2 = typeof p2 === 'object' ? p2.structure : this.extractStructure(p2);

        let score = 0;

        // Check transformational topology isomorphism
        if (s1.topology === s2.topology) score += 0.3;

        // Check dimensional fold similarity (¬±1)
        if (Math.abs(s1.dimensionalFold - s2.dimensionalFold) <= 1) score += 0.2;

        // Check paradox resolution branch
        const paradoxMatch = s1.paradoxes.some(p1 => s2.paradoxes.some(p2 => 
            this.areOpposites(p1, p2) || p1 === p2
        ));
        if (paradoxMatch) score += 0.2;

        // Check recursion depth equivalence
        if (s1.recursionDepth === s2.recursionDepth) score += 0.15;

        // Check quantum state compatibility
        const quantumCompatible = 
            (s1.quantumState === s2.quantumState) ||
            (s1.quantumState === 'superposition' && s2.quantumState === 'collapsed') ||
            (s2.quantumState === 'superposition' && s1.quantumState === 'collapsed');
        if (quantumCompatible) score += 0.15;

        return score >= 0.5;
    }

    // Check if two elements are opposites
    areOpposites(a, b) {
        const pairs = [
            ['ALWAYS', 'NEVER'], ['ALL', 'NONE'], ['EVERYWHERE', 'NOWHERE'],
            ['TRUE', 'FALSE'], ['ORDER', 'CHAOS'], ['WAVE', 'PARTICLE'],
            ['LIGHT', 'SHADOW'], ['INFINITE', 'ZERO'], ['BOTH', 'NEITHER']
        ];
        
        return pairs.some(([x, y]) => 
            (a === x && b === y) || (a === y && b === x)
        );
    }

    // Force incompatibility for non-matches
    forceIncompatibility(premise, reference) {
        const hash = this.generateHash(this.trialCounter, 999);
        let incompatible = this.buildQuantumPremise(this.trialCounter, 0, 1);
        
        // Invert the reference structure
        const refStruct = typeof reference === 'object' ? reference.structure : this.extractStructure(reference);
        
        // Create opposite topology
        if (refStruct.topology === 'linear') {
            incompatible = this.patternGamma(hash, 0); // Force recursion
        } else if (refStruct.topology === 'looping') {
            incompatible = this.patternAlpha(hash); // Force linear
        }
        
        return {
            text: incompatible,
            structure: this.extractStructure(incompatible),
            hash: hash,
            forced: true
        };
    }
}

/* ===== Global state ===== */
const premiseGenerator = new QuantumSemanticGenerator();
let MAX=200, RATE=25, N=1, SPEAK=true, SOLVE_WINDOW=5.0, STATEMENTS=1;

/* ===== Session management ===== */
let idx=0, correct=0, errors=0, planned=[], history=[], SESSION={running:false, paused:false};
let currentTruth=false, responded=false, solveTimer=null, countdownTimer=null, countdownLeft=0;

function planSequence(){ 
  planned.length=MAX; 
  for(let i=0;i<MAX;i++) planned[i]=false; 
  const elig=[]; 
  for(let i=N;i<MAX;i++) elig.push(i); 
  const k=Math.round((RATE/100)*elig.length); 
  shuffle(elig); 
  for(let i=0;i<k;i++) planned[elig[i]]=true; 
}

function showPremises(premises) {
  const container = $('premiseContainer');
  container.innerHTML = '';
  
  const arr = Array.isArray(premises) ? premises : [premises];
  
  arr.forEach((p, i) => {
    const div = document.createElement('div');
    div.className = 'premise-line';
    
    if (arr.length > 1) {
      const num = document.createElement('span');
      num.className = 'premise-number';
      num.textContent = (i+1).toString();
      div.appendChild(num);
    }
    
    if (typeof p === 'object' && p.text) {
      let html = p.text;
      
      // Highlight mathematical symbols
      html = html.replace(/[¬≤¬≥‚àû‚àÖ√ó√∑¬±‚âà]/g, '<span class="quantum">$&</span>');
      
      // Highlight slash combinations
      html = html.replace(/\//g, '<span class="slash">/</span>');
      
      // Highlight bidirectional arrows
      html = html.replace(/‚ü∑/g, '<span class="quantum">‚ü∑</span>');
      
      // Highlight paradoxes
      premiseGenerator.paradoxNodes.forEach(p => {
        html = html.replace(new RegExp(`\\b${p}\\b`, 'g'), `<span class="paradox">${p}</span>`);
      });
      
      // Highlight meta references
      html = html.replace(/\b(IT|THAT|THIS|ITSELF|OTHER)\b/g, '<span class="meta">$1</span>');
      
      // Highlight compounds with hyphens
      html = html.replace(/\b(\w+(-\w+)+)\b/g, '<span class="compound">$1</span>');
      
      // Highlight transformations
      premiseGenerator.transformOps.forEach(op => {
        if (!html.includes(`>${op}<`)) {
          html = html.replace(new RegExp(`\\b${op}\\b`, 'g'), `<span class="operation">${op}</span>`);
        }
      });
      
      // Highlight remaining entities
      premiseGenerator.phaseEntities.forEach(e => {
        if (!html.includes(`>${e}<`)) {
          html = html.replace(new RegExp(`\\b${e}\\b`, 'g'), `<span class="entity">${e}</span>`);
        }
      });
      
      div.innerHTML = html;
      
      // Add meta info
      if (p.structure) {
        const meta = document.createElement('div');
        meta.className = 'meta-info';
        const words = p.text.split(' ').length;
        meta.textContent = `[${words} words, topology: ${p.structure.topology}, quantum: ${p.structure.quantumState}, folds: ${p.structure.dimensionalFold}]`;
        div.appendChild(meta);
      }
    } else {
      div.textContent = p;
    }
    
    container.appendChild(div);
  });
}

function updateUI(){ 
  setText('idx', idx); 
  setText('max', MAX); 
  setText('ptype', (idx<MAX && idx>=N && planned[idx])?'MATCH':'NON-match'); 
  setText('corr', correct); 
  setText('err', errors); 
  setText('isMatch','‚Äî'); 
}

async function speak(text){
  if(!SPEAK) return Promise.resolve();
  if(typeof window==='undefined'||!('speechSynthesis' in window)) return Promise.resolve();
  
  // Only speak the actual premises, no introduction
  const speakText = Array.isArray(text) ? 
    text.map(p => p.text || p).join('. ') : 
    (text.text || text);
    
  return new Promise(res=>{ 
    try{ 
      const u=new SpeechSynthesisUtterance(speakText); 
      u.lang='en-GB'; 
      u.rate=0.65; 
      u.pitch=1.0; 
      u.volume=1.0; 
      u.onend=()=>res(); 
      u.onerror=()=>res(); 
      if(window.speechSynthesis.speaking) window.speechSynthesis.cancel(); 
      window.speechSynthesis.speak(u); 
    }catch{ 
      res(); 
    } 
  });
}

function scheduleCountdown(sec){ 
  countdownLeft=sec; 
  setText('countdown', countdownLeft.toFixed(1)+'s'); 
  if(countdownTimer) clearInterval(countdownTimer); 
  countdownTimer=setInterval(()=>{ 
    countdownLeft=Math.max(0,countdownLeft-0.1); 
    setText('countdown', countdownLeft.toFixed(1)+'s'); 
    if(countdownLeft<=0){ 
      clearInterval(countdownTimer); 
      countdownTimer=null; 
    } 
  },100); 
}

function evaluateAndAdvance(){ 
  const resp=responded, truth=currentTruth; 
  if(resp===truth) correct++; 
  else errors++; 
  setText('corr',correct); 
  setText('err',errors); 
  setText('isMatch', String(truth).toUpperCase()); 
  idx++; 
  if(idx>=MAX){ 
    stop(); 
    return; 
  } 
  runTrial(); 
}

function runTrial(){
  if(!SESSION.running || SESSION.paused) return;
  
  const mustMatch=(idx>=N)&&planned[idx];
  
  let premises;
  
  if(mustMatch && idx >= N) {
    // For planned matches, generate compatible premise
    const reference = history[idx-N];
    premises = premiseGenerator.generatePremise(idx, N, STATEMENTS);
    
    // Ensure compatibility with n-back reference
    if (STATEMENTS === 1) {
      let attempts = 0;
      while (!premiseGenerator.checkCompatibility(premises[0], reference[0]) && attempts < 10) {
        premises = premiseGenerator.generatePremise(idx + attempts * 1000, N, STATEMENTS);
        attempts++;
      }
    }
  } else if (idx >= N && !mustMatch) {
    // For planned non-matches, force incompatibility
    premises = premiseGenerator.generatePremise(idx, N, STATEMENTS);
    
    if (STATEMENTS === 1) {
      const reference = history[idx-N];
      if (premiseGenerator.checkCompatibility(premises[0], reference[0])) {
        // Force incompatibility
        premises = [premiseGenerator.forceIncompatibility(premises[0], reference[0])];
      }
    }
  } else {
    // Before n-back threshold
    premises = premiseGenerator.generatePremise(idx, N, STATEMENTS);
  }
  
  history[idx] = premises;
  showPremises(premises); 
  responded=false; 
  
  if(idx >= N) {
    currentTruth = premiseGenerator.checkCompatibility(premises[0], history[idx-N][0]);
    if(mustMatch) currentTruth = true;
    if(!mustMatch && currentTruth) currentTruth = false;
  } else {
    currentTruth = false;
  }
  
  setText('isMatch','‚Äî'); 
  setText('ptype', (idx<MAX && idx>=N && planned[idx])?'MATCH':'NON-match');

  speak(premises).then(()=>{ 
    scheduleCountdown(SOLVE_WINDOW); 
    if(solveTimer) clearTimeout(solveTimer); 
    solveTimer=setTimeout(()=>{ 
      evaluateAndAdvance(); 
    }, SOLVE_WINDOW*1000); 
  });
}

/* Controls */
function start(){
  MAX=+$('trials').value||200; 
  RATE=+$('rate').value||25; 
  N=+$('nback').value||1; 
  STATEMENTS=+$('statements').value||1;
  SPEAK=!!$('speakEnabled').checked;
  SOLVE_WINDOW=+($('solveWindow').value||5); 
  setText('solveLabel', SOLVE_WINDOW.toFixed(1)); 
  setText('solveVal', SOLVE_WINDOW.toFixed(1)+'s');
  
  // Reset generator entropy for new session
  premiseGenerator.sessionEntropy = Date.now();
  premiseGenerator.trialCounter = 0;
  premiseGenerator.tabooList = [];

  idx=0; 
  correct=0; 
  errors=0; 
  planned=[]; 
  history=[]; 
  planSequence(); 
  updateUI();
  SESSION.running=true; 
  SESSION.paused=false;
  $('pause').disabled=false; 
  $('reset').disabled=false; 
  $('hit').disabled=false; 
  $('skip').disabled=false;
  runTrial();
}

function stop(){ 
  SESSION.running=false; 
  SESSION.paused=false; 
  if(solveTimer) clearTimeout(solveTimer); 
  if(countdownTimer) clearInterval(countdownTimer); 
  setText('countdown','‚Äî'); 
  try{ 
    if(window.speechSynthesis) window.speechSynthesis.cancel(); 
  }catch{} 
}

function togglePause(){
  if(!SESSION.running) return;
  SESSION.paused=!SESSION.paused; 
  $('pause').textContent=SESSION.paused?'‚ñ∂ Resume':'‚è∏ Pause';
  if(SESSION.paused){ 
    if(solveTimer) clearTimeout(solveTimer); 
    if(countdownTimer) clearInterval(countdownTimer); 
    try{ 
      if(window.speechSynthesis) window.speechSynthesis.cancel(); 
    }catch{} 
  }
  else{
    scheduleCountdown(countdownLeft>0?countdownLeft:SOLVE_WINDOW);
    if(solveTimer) clearTimeout(solveTimer);
    solveTimer=setTimeout(()=>{ 
      evaluateAndAdvance(); 
    }, (countdownLeft>0?countdownLeft:SOLVE_WINDOW)*1000);
  }
}

function reset(){ 
  stop(); 
  // Reset generator for fresh premises
  premiseGenerator.sessionEntropy = Date.now();
  premiseGenerator.trialCounter = 0;
  premiseGenerator.tabooList = [];
  
  $('premiseContainer').innerHTML='‚Äî'; 
  setText('idx',0); 
  setText('corr',0); 
  setText('err',0); 
  setText('ptype','‚Äî'); 
  setText('isMatch','‚Äî'); 
}

function registerHit(){ 
  if(!SESSION.running || SESSION.paused) return; 
  responded=true; 
}

function skip(){ 
  if(!SESSION.running || SESSION.paused) return; 
  if(solveTimer) clearTimeout(solveTimer); 
  if(countdownTimer) clearInterval(countdownTimer); 
  setText('countdown','‚Äî'); 
  evaluateAndAdvance(); 
}

/* Event bindings */
document.addEventListener('DOMContentLoaded', ()=>{
  const sw=$('solveWindow'); 
  const updateSW=()=>{ 
    const v=+sw.value; 
    setText('solveVal', v.toFixed(1)+'s'); 
    setText('solveLabel', v.toFixed(1)); 
  };
  updateSW(); 
  sw.oninput=e=>{ 
    if(!SESSION.running){ 
      updateSW(); 
    } 
  };
  
  $('nback').oninput=e=>{ 
    if(!SESSION.running){ 
      N=+e.target.value; 
      setText('nVal',N); 
      const currentText = $('modeLine').textContent;
      $('modeLine').textContent=currentText.replace(/N=\d+$/,`N=${N}`); 
    } 
  };
  
  $('statements').oninput=e=>{ 
    if(!SESSION.running){ 
      STATEMENTS=+e.target.value; 
      setText('stmtVal',STATEMENTS); 
    } 
  };
  
  $('trials').oninput=e=>{ 
    if(!SESSION.running){ 
      MAX=+e.target.value; 
      setText('tVal',MAX); 
      setText('max',MAX); 
    } 
  };
  
  $('rate').oninput=e=>{ 
    if(!SESSION.running){ 
      RATE=+e.target.value; 
      setText('rVal',RATE+'%'); 
    } 
  };
  
  $('speakEnabled').onchange=e=>{ 
    SPEAK=!!e.target.checked; 
  };

  $('start').onclick=start; 
  $('pause').onclick=togglePause; 
  $('reset').onclick=reset; 
  $('hit').onclick=registerHit; 
  $('skip').onclick=skip;
  
  window.addEventListener('keydown', e=>{ 
    if(!SESSION.running) return; 
    if(e.code==='Space'){ 
      registerHit(); 
      e.preventDefault(); 
    } 
  });

  setText('nVal',N); 
  setText('stmtVal',STATEMENTS);
  setText('tVal',MAX); 
  setText('rVal',RATE+'%');
  setText('modeLine',`Quantum Semantic ‚Ä¢ G-Load: ~0.90+ ‚Ä¢ N=${N}`);
  updateUI();
});
</script>
</body>
</html>
