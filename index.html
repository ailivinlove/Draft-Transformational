<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>Quantum Semantic N-Back ‚Äî Cognitive Singularity v2.0</title>
<style>
:root { --bg:#0b0d10; --fg:#e6fbff; --a:#00ccff; --mut:#8fe7ff; --glow:#00ffff40 }
*{ box-sizing:border-box }
html,body{ height:100%; overflow-x:hidden }
body{ margin:0; background:#0b0d10; color:#e6fbff; font-family:system-ui,-apple-system,Segoe UI,Roboto,sans-serif }
.wrap{ max-width:1280px; margin:0 auto; padding:16px }
.row{ display:flex; gap:12px; flex-wrap:wrap }
.col{ flex:1 1 360px }
.box{ background:#101418; border:1px solid rgba(0,200,255,.25); border-radius:14px; padding:12px; backdrop-filter:blur(10px) }
.title{ font-weight:800; margin-bottom:6px; letter-spacing:.3px }
.btn{ background:#0b0d10; color:#00ccff; border:1px solid #00ccff; border-radius:10px; padding:10px 14px; font-weight:700; cursor:pointer; transition:all 0.3s }
.btn:hover:not(:disabled){ background:#00ccff20; box-shadow:0 0 15px rgba(0,200,255,.5) }
.btn:disabled{ opacity:.5; cursor:not-allowed }
.btn.instructions{ background:#5f27cd; border-color:#5f27cd; color:#fff }
.btn.instructions:hover{ background:#6c35db; box-shadow:0 0 15px rgba(95,39,205,.6) }
label{ font-size:12px; color:#8fe7ff; display:block; margin:6px 0 }
input[type=range], input[type=number]{ width:100% }
.kbd{ border:1px solid rgba(255,255,255,.25); padding:2px 6px; border-radius:6px; background:#0b0d10; font-size:11px }
.mut{ color:#8fe7ff; font-size:12px }
hr.hr{border:none;border-top:1px solid rgba(0,200,255,.25);margin:8px 0}

#premiseContainer{ 
  margin-top:12px; 
  min-height:140px; 
  background:linear-gradient(135deg, #0e1113, #131619);
  border:1px solid rgba(0,200,255,.25); 
  border-radius:12px; 
  padding:12px; 
  font-size:30px; 
  line-height:2.1; 
  word-break:break-word; 
  font-family:'Courier New',monospace; 
  font-weight:900; 
  letter-spacing:2px;
  position:relative;
  overflow:hidden;
}

#premiseContainer::before{
  content:'';
  position:absolute;
  top:-50%;
  left:-50%;
  width:200%;
  height:200%;
  background:radial-gradient(circle, rgba(0,200,255,0.05) 0%, transparent 70%);
  animation:rotate 20s linear infinite;
  pointer-events:none;
}

@keyframes rotate{ from{transform:rotate(0deg)} to{transform:rotate(360deg)} }

.premise-line{ 
  margin:14px 0; 
  padding:16px; 
  border-left:7px solid rgba(0,200,255,.7); 
  background:linear-gradient(90deg, rgba(0,200,255,.2), rgba(0,200,255,.05)); 
  border-radius:4px; 
  position:relative;
  z-index:1;
}

.premise-number{ 
  position:absolute; 
  left:-40px; 
  top:50%; 
  transform:translateY(-50%); 
  color:#00ccff; 
  font-size:20px; 
  font-weight:bold 
}

.badge{ 
  display:inline-block; 
  padding:2px 8px; 
  border:1px solid rgba(0,200,255,.35); 
  border-radius:999px; 
  font-size:12px; 
  color:#8fe7ff; 
  margin-left:6px 
}

#countdown{ font-weight:800; color:#00ccff }

/* Semantic highlighting */
.entity{ color:#ff6b6b; text-shadow:0 0 14px rgba(255,107,107,.8) }
.transform{ color:#4ecdc4; text-shadow:0 0 12px rgba(78,205,196,.8) }
.paradox{ color:#ffd700; font-weight:bold; text-shadow:0 0 15px rgba(255,215,0,.9) }
.meta{ color:#00ff88; font-weight:bold; text-decoration:overline }
.quantum{ color:#b19cd9; font-style:italic; text-shadow:0 0 12px rgba(177,156,217,.8) }
.compound{ color:#00d2d3; text-decoration:underline; text-shadow:0 0 10px rgba(0,210,211,.7) }
.mediator{ color:#a55eea; font-weight:900; text-shadow:0 0 16px rgba(165,94,234,.9) }
.modifier{ color:#ff00ff; font-weight:bold; text-shadow:0 0 12px rgba(255,0,255,.8) }
.axis{ color:#26de81; text-shadow:0 0 12px rgba(38,222,129,.8) }

.meta-info{ 
  font-size:13px; 
  color:#4a8aff; 
  margin-top:12px; 
  opacity:0.9; 
  font-weight:normal;
  font-family:system-ui;
}

/* Modal for instructions */
.modal{
  display:none;
  position:fixed;
  z-index:1000;
  left:0;
  top:0;
  width:100%;
  height:100%;
  background:rgba(0,0,0,0.8);
  backdrop-filter:blur(5px);
}

.modal-content{
  background:#101418;
  margin:2% auto;
  padding:20px;
  border:2px solid #00ccff;
  border-radius:15px;
  width:90%;
  max-width:800px;
  max-height:90vh;
  overflow-y:auto;
  box-shadow:0 0 30px rgba(0,200,255,.5);
}

.modal-content h2{ color:#00ccff; margin-top:20px }
.modal-content h3{ color:#8fe7ff; margin-top:15px }
.modal-content p{ line-height:1.6; color:#e6fbff }
.modal-content .example{
  background:#0b0d10;
  border-left:3px solid #00ccff;
  padding:10px;
  margin:10px 0;
  font-family:'Courier New',monospace;
  font-size:14px;
}
.modal-content .explanation{
  color:#8fe7ff;
  font-style:italic;
  margin-top:5px;
}

.close{
  color:#00ccff;
  float:right;
  font-size:28px;
  font-weight:bold;
  cursor:pointer;
  transition:color 0.3s;
}
.close:hover{ color:#ff6b6b }
</style>
</head>
<body>
<div class="wrap">
  <div class="row">
    <div class="col">
      <div class="box">
        <div class="title">Quantum Configuration</div>
        <div class="mut" id="diffExplain">Cognitive Singularity v2.0 ‚Ä¢ G-Load: ~0.90+</div>
        <hr class="hr">
        <label>N-Back level: <span id="nVal">1</span></label>
        <input id="nback" type="range" min="1" max="5" step="1" value="1">
        <hr class="hr">
        <label>Statements per trial: <span id="stmtVal">1</span></label>
        <input id="statements" type="range" min="1" max="5" step="1" value="1">
        <div class="mut small">Multiple statements create quantum interference patterns</div>
        <hr class="hr">
        <button id="instructionsBtn" class="btn instructions" style="width:100%; margin-top:10px">üìñ How to Play</button>
      </div>
    </div>

    <div class="col">
      <div class="box">
        <div class="title">Timing & Block</div>
        <div class="mut">Solve window: <strong><span id="solveLabel">5.0</span>s</strong> after speaking.</div>
        <label>Solve window (1‚Äì30s): <span id="solveVal">5.0s</span></label>
        <input id="solveWindow" type="range" min="1" max="30" step="0.1" value="5">
        <label>Trials per block: <span id="tVal">200</span></label>
        <input id="trials" type="range" min="20" max="500" step="10" value="200">
        <label>Target match rate: <span id="rVal">25%</span></label>
        <input id="rate" type="range" min="0" max="100" step="1" value="25">
        <label><input id="speakEnabled" type="checkbox" checked> Speak sentences</label>
      </div>
    </div>

    <div class="col">
      <div class="box">
        <div class="title">Controls / Status</div>
        <div style="display:flex; gap:8px; flex-wrap:wrap; margin-top:6px">
          <button id="start" class="btn">‚ñ∂ Start</button>
          <button id="pause" class="btn" disabled>‚è∏ Pause</button>
          <button id="reset" class="btn" disabled>üîÑ Reset</button>
          <button id="hit" class="btn" disabled>‚úì Match (<span class="kbd">Space</span>)</button>
          <button id="skip" class="btn" disabled>‚è≠ Skip</button>
        </div>
        <div class="mut" style="margin-top:8px">
          Trial <span id="idx">0</span>/<span id="max">200</span>
          <span class="badge">Planned: <span id="ptype">‚Äî</span></span>
          <span class="badge">Actual: <span id="isMatch">‚Äî</span></span>
          <span class="badge">Countdown: <span id="countdown">‚Äî</span></span>
        </div>
        <div class="mut">Correct: <span id="corr">0</span> ‚Ä¢ Errors: <span id="err">0</span></div>
        <div class="mut small" id="modeLine">Cognitive Singularity v2.0 ‚Ä¢ G-Load: ~0.90+ ‚Ä¢ N=1</div>
      </div>
    </div>
  </div>

  <div class="box" style="margin-top:12px">
    <div class="title">Quantum Semantic N-Back <span class="badge">‚â§5 words</span> <span class="badge">Maximum g-load</span></div>
    <div id="premiseContainer" aria-live="polite">‚Äî</div>
  </div>
</div>

<!-- Instructions Modal -->
<div id="instructionsModal" class="modal">
  <div class="modal-content">
    <span class="close">&times;</span>
    <h2>üß† Quantum Semantic N-Back Instructions</h2>
    
    <p>This game tests your ability to recognize <strong>deep structural patterns in transformations</strong>, not surface-level word matching. You must mentally simulate what each transformation does to understand if premises match.</p>
    
    <h3>Core Concept: Transformation Compatibility</h3>
    <p>A <strong>MATCH</strong> occurs when two premises share compatible transformation topologies - they change states in harmonious ways, even using completely different words.</p>
    <p>A <strong>NON-MATCH</strong> occurs when transformations conflict - they lead to incompatible end states or create logical paradoxes.</p>
    
    <h3>How Matching Works</h3>
    <p>Matches are determined by:</p>
    <ol>
      <li><strong>Transformation Topology</strong> - Do the changes follow the same pattern?</li>
      <li><strong>Energy Conservation</strong> - Do states balance energetically?</li>
      <li><strong>Phase Compatibility</strong> - Can resulting phases coexist?</li>
      <li><strong>Causal Consistency</strong> - Do transformations avoid paradoxes?</li>
      <li><strong>Structural Alignment</strong> - Do end states have compatible order?</li>
    </ol>
    
    <h3>N-Back 1 Examples</h3>
    
    <h4>Single Premise per Trial:</h4>
    <div class="example">
      Trial 1: WAVE dissolves-through VOID recursively
      Trial 2: LIGHT crystallizes ORDER via ENTROPY
      Trial 3: PARTICLE fragments-into FLUX eternally
    </div>
    <div class="explanation">
      Decision for Trial 3: MATCH with Trial 2 (1-back) 
      Why: Both move from coherent to dispersed states with similar energy loss. "Crystallizes" and "fragments-into" are opposite processes that balance energetically.
    </div>
    
    <h4>Double Premise per Trial:</h4>
    <div class="example">
      Trial 1: 
        [P1] CHAOS inverts PATTERN fractally
        [P2] VOID becomes ORDER through ITSELF
      
      Trial 2:
        [P1] ENTROPY cascades-through FLUX infinitely
        [P2] NULL transforms STRUCTURE via PARADOX
    </div>
    <div class="explanation">
      Decision: MATCH 
      Why: Both statement pairs create order from disorder through paradoxical self-reference. The transformation topology is isomorphic.
    </div>
    
    <h3>N-Back 2 Example</h3>
    <div class="example">
      Trial 1: WAVE dissolves PARTICLE quantumly
      Trial 2: ORDER crystallizes CHAOS eternally  
      Trial 3: FLUX disperses QUANTUM fractally
    </div>
    <div class="explanation">
      Decision for Trial 3: MATCH with Trial 1 (2-back)
      Why: Both involve dissolution transformations with quantum modulation. The energy delta and coherence changes align.
    </div>
    
    <h3>N-Back 3 Example</h3>
    <div class="example">
      Trial 1: LIGHT‚ÜíSHADOW inverts recursively NOW
      Trial 2: PATTERN coalesces VOID through ENTROPY
      Trial 3: CHAOS structures NULL via ORDER
      Trial 4: PHOTON‚ÜíDARKNESS recurses inversely ALWAYS
    </div>
    <div class="explanation">
      Decision for Trial 4: MATCH with Trial 1 (3-back)
      Why: Phase transitions with recursive inversion - same transformation applied to light/dark duality across time.
    </div>
    
    <h3>Triple Premise per Trial</h3>
    <div class="example">
      Trial 1:
        [P1] WAVE oscillates-between PARTICLE eternally
        [P2] BOTH dissolves NEITHER through PARADOX
        [P3] IT¬≤ re-crystallizes PRIOR inversely
        
      Trial 2:
        [P1] FLUX alternates-through QUANTUM infinitely
        [P2] ALL fragments NONE via CONTRADICTION
        [P3] ITSELF¬≥ reconstructs PREVIOUS oppositely
    </div>
    <div class="explanation">
      Decision: MATCH
      Why: All three premises in each trial follow the same meta-pattern: oscillation, paradoxical dissolution, and recursive reconstruction. The third premise in each modifies the results of the first two.
    </div>
    
    <h3>Key Strategy</h3>
    <p><strong>You must MENTALLY SIMULATE each transformation</strong> to determine compatibility. Ask yourself:</p>
    <ul>
      <li>What state does this transformation produce?</li>
      <li>How much energy does it consume or release?</li>
      <li>Can the resulting phase exist alongside the comparison premise?</li>
      <li>Does this create a causal paradox when combined?</li>
    </ul>
    
    <p><strong>Pattern matching keywords will fail!</strong> The same word can represent different transformations based on context, and different words can represent the same deep structure.</p>
  </div>
</div>

<script>
/* ============================================================
   COGNITIVE SINGULARITY v2.0
   True quantum semantic compression with computational transformations
   ============================================================ */

const $ = id => document.getElementById(id);
function setText(id,v){ const el=$(id); if(el) el.textContent=v; }
function shuffle(a){ for(let i=a.length-1;i>0;i--){ const j=(Math.random()*(i+1))|0; [a[i],a[j]]=[a[j],a[i]] } return a; }

/* ===== MOUSE TRACKING FOR ENTROPY ===== */
window.lastMouseX = 0;
window.lastMouseY = 0;
document.addEventListener('mousemove', (e) => {
  window.lastMouseX = e.clientX;
  window.lastMouseY = e.clientY;
});

/* ===== COMPUTATIONAL TRANSFORMATION ENGINE ===== */
class ComputationalTransform {
  constructor() {
    // Transformations as FUNCTIONS requiring mental computation
    this.transforms = {
      'dissolve': (state) => {
        const entropy = state.order * -0.8;
        const dispersion = Math.exp(entropy);
        const newCoherence = state.coherence * (1 - dispersion);
        return {
          ...state,
          order: state.order * 0.2,
          coherence: Math.max(0, newCoherence),
          phase: 'dispersed',
          energy: state.energy - 2,
          reversible: newCoherence > 0.1
        };
      },
      
      'crystallize': (state) => {
        const orderGain = (1 - state.order) * 0.7;
        const energyCost = orderGain * 3;
        if(state.energy < energyCost) {
          return {...state, failed: true};
        }
        return {
          ...state,
          order: Math.min(1, state.order + orderGain),
          energy: state.energy - energyCost,
          phase: 'solid',
          coherence: 0.9,
          structure: 'lattice'
        };
      },
      
      'cascade': (state) => {
        let current = {...state};
        const steps = Math.max(1, Math.floor(state.energy / 2));
        for(let i = 0; i < steps; i++) {
          current = {
            ...current,
            energy: current.energy * 0.7,
            propagation: (current.propagation || 1) * 1.5,
            order: current.order * 0.85
          };
        }
        return {...current, phase: 'cascading'};
      },
      
      'invert': (state) => ({
        ...state,
        order: 1 - state.order,
        coherence: 1 - state.coherence,
        phase: state.phase === 'solid' ? 'dispersed' : 'solid',
        polarity: -(state.polarity || 1)
      }),
      
      'oscillate': (state) => ({
        ...state,
        phase: 'superposition',
        frequency: (state.frequency || 1) * 2,
        energy: state.energy * 0.9,
        order: 0.5 + Math.sin(state.time || 0) * 0.3
      }),
      
      'fragment': (state) => ({
        ...state,
        order: state.order * 0.1,
        coherence: state.coherence * 0.2,
        fragments: (state.fragments || 1) * 8,
        energy: state.energy - 3,
        phase: 'shattered'
      }),
      
      'coalesce': (state) => ({
        ...state,
        order: Math.min(1, state.order * 2),
        coherence: Math.min(1, state.coherence * 1.5),
        fragments: Math.max(1, (state.fragments || 8) / 2),
        energy: state.energy - 1,
        phase: 'coalescing'
      }),
      
      'tunnel': (state) => ({
        ...state,
        phase: 'quantum-tunneled',
        energy: state.energy - 1,
        coherence: state.coherence * 0.7,
        position: 'non-local'
      }),
      
      'entangle': (state) => ({
        ...state,
        phase: 'entangled',
        correlation: 1,
        energy: state.energy + 1,
        non_local: true
      }),
      
      'annihilate': (state) => ({
        ...state,
        energy: 0,
        order: 0,
        coherence: 0,
        phase: 'void',
        exists: false
      })
    };
  }
  
  compose(transformChain, initialState) {
    let state = {...initialState};
    for(const t of transformChain) {
      if(this.transforms[t]) {
        state = this.transforms[t](state);
        if(state.failed) break;
      }
    }
    return state;
  }
  
  areCompatible(result1, result2) {
    // Check phase compatibility
    const phaseConflict = (result1.phase === 'void' && result2.phase !== 'void') ||
                         (result1.phase === 'solid' && result2.phase === 'dispersed');
    
    // Check energy conservation (with tolerance)
    const energyViolation = Math.abs(result1.energy + result2.energy) > 20;
    
    // Check structural alignment
    const structureConflict = result1.structure === 'lattice' && result2.phase === 'shattered';
    
    return !phaseConflict && !energyViolation && !structureConflict;
  }
}

/* ===== SEMANTIC EQUIVALENCE TRACKER ===== */
class SemanticEquivalenceTracker {
  constructor() {
    this.equivalenceClasses = {
      'dissolution': ['dissolve', 'melt', 'liquify', 'disperse', 'dissipate', 'scatter', 'diffuse'],
      'crystallization': ['crystallize', 'solidify', 'freeze', 'coalesce', 'congeal', 'structure', 'order'],
      'oscillation': ['oscillate', 'vibrate', 'fluctuate', 'waver', 'alternate', 'pulse', 'resonate'],
      'fragmentation': ['fragment', 'shatter', 'break', 'split', 'fracture', 'divide', 'separate'],
      'inversion': ['invert', 'reverse', 'flip', 'negate', 'oppose', 'contra', 'anti'],
      'cascade': ['cascade', 'flow', 'pour', 'stream', 'propagate', 'spread', 'ripple'],
      'tunneling': ['tunnel', 'penetrate', 'phase', 'transit', 'traverse', 'cross', 'breach'],
      'entanglement': ['entangle', 'correlate', 'link', 'bind', 'couple', 'connect', 'mesh'],
      'annihilation': ['annihilate', 'destroy', 'erase', 'void', 'nullify', 'eliminate', 'cancel']
    };
    
    this.usedConcepts = new Set();
    this.sessionWords = new Set();
    
    // Neologism components
    this.prefixes = {
      'dissolution': ['de', 'dis', 'un', 'dys'],
      'crystallization': ['re', 'con', 'syn', 'cryo'],
      'oscillation': ['alt', 'vib', 'wav', 'osc'],
      'fragmentation': ['frag', 'shat', 'frac', 'schiz'],
      'inversion': ['anti', 'contra', 'inv', 'neg'],
      'cascade': ['cas', 'flow', 'flux', 'stream'],
      'tunneling': ['trans', 'phas', 'tun', 'pen'],
      'entanglement': ['ent', 'cor', 'link', 'mesh'],
      'annihilation': ['ann', 'void', 'null', 'erad']
    };
    
    this.roots = ['morph', 'form', 'struct', 'plex', 'state', 'phase', 'mode', 'cast'];
    this.suffixes = ['ify', 'ate', 'ize', 'ose', 'ene', 'on', 'ex', 'is'];
  }
  
  getUnusedTransform(conceptClass) {
    // Check if we've used this concept class recently
    const recentConcepts = Array.from(this.usedConcepts).slice(-5);
    if(recentConcepts.includes(conceptClass)) {
      // Generate neologism instead
      return this.generateSemanticNeologism(conceptClass);
    }
    
    // Find unused word from equivalence class
    const words = this.equivalenceClasses[conceptClass];
    if(!words) return this.generateRandomNeologism();
    
    const unused = words.filter(w => !this.sessionWords.has(w));
    if(unused.length === 0) {
      return this.generateSemanticNeologism(conceptClass);
    }
    
    const selected = unused[Math.floor(Math.random() * unused.length)];
    this.sessionWords.add(selected);
    this.usedConcepts.add(conceptClass);
    
    // Trim history if too large
    if(this.usedConcepts.size > 20) {
      const concepts = Array.from(this.usedConcepts);
      this.usedConcepts = new Set(concepts.slice(-15));
    }
    
    return selected;
  }
  
  generateSemanticNeologism(concept) {
    const pre = this.prefixes[concept];
    if(!pre) return this.generateRandomNeologism();
    
    const prefix = pre[Math.floor(Math.random() * pre.length)];
    const root = this.roots[Math.floor(Math.random() * this.roots.length)];
    const suffix = this.suffixes[Math.floor(Math.random() * this.suffixes.length)];
    
    const neo = `${prefix}${root}${suffix}`;
    this.sessionWords.add(neo);
    return neo;
  }
  
  generateRandomNeologism() {
    const consonants = 'bcdfghjklmnpqrstvwxyz';
    const vowels = 'aeiou';
    let neo = '';
    
    for(let i = 0; i < 3; i++) {
      neo += consonants[Math.floor(Math.random() * consonants.length)];
      neo += vowels[Math.floor(Math.random() * vowels.length)];
    }
    neo += 'fy';
    
    this.sessionWords.add(neo);
    return neo;
  }
  
  reset() {
    this.usedConcepts.clear();
    this.sessionWords.clear();
  }
}

/* ===== QUANTUM SEMANTIC GENERATOR v2.0 ===== */
class QuantumSemanticGeneratorV2 {
  constructor() {
    this.transformEngine = new ComputationalTransform();
    this.semanticTracker = new SemanticEquivalenceTracker();
    
    // Entity pools with semantic weight
    this.entityPools = {
      quantum: ['WAVE', 'PARTICLE', 'QUANTUM', 'PHOTON', 'FIELD', 'SPIN', 'CHARGE'],
      void: ['VOID', 'NULL', 'VACUUM', 'EMPTY', 'ABSENCE', 'ZERO', 'NIL'],
      order: ['ORDER', 'CHAOS', 'PATTERN', 'ENTROPY', 'STRUCTURE', 'RANDOM', 'FORM'],
      energy: ['LIGHT', 'SHADOW', 'ENERGY', 'DARK', 'RADIANCE', 'GLOW', 'DIM'],
      state: ['SOLID', 'LIQUID', 'PLASMA', 'GAS', 'CRYSTAL', 'FLUX', 'PHASE'],
      paradox: ['BOTH', 'NEITHER', 'ALL', 'NONE', 'ALWAYS', 'NEVER', 'ETERNAL'],
      meta: ['IT', 'ITSELF', 'PRIOR', 'THIS', 'THAT', 'OTHER', 'SELF']
    };
    
    this.mediators = ['through', 'via', 'within', 'across', 'between', 'beyond'];
    this.modifiers = ['quantumly', 'fractally', 'inversely', 'recursively', 'eternally', 'infinitely'];
    
    // Transformation axes for variation
    this.axes = ['spatial', 'temporal', 'energetic', 'informational', 'causal'];
    this.currentAxis = null;
    
    // Session tracking
    this.generatedHashes = new Set();
    this.premiseHistory = [];
    this.seedHistory = new Set();
  }
  
  // True quantum random generation
  generateQuantumSeed() {
    const sources = [];
    
    // Crypto API for true randomness
    if(window.crypto && window.crypto.getRandomValues) {
      const arr = new Uint32Array(3);
      window.crypto.getRandomValues(arr);
      sources.push(...arr);
    }
    
    // Time-based entropy
    sources.push(
      performance.now() * Math.random() * 1000000,
      Date.now() + Math.random() * 999999,
      Math.sin(Date.now() * Math.random()) * 1e9
    );
    
    // Mouse position entropy
    sources.push(
      (window.lastMouseX || Math.random() * 1000) * 
      (window.lastMouseY || Math.random() * 1000) *
      Math.random()
    );
    
    // Bit rotation hash
    let hash = 0;
    for(const source of sources) {
      hash = ((hash << 7) | (hash >>> 25)) ^ Math.floor(source);
      hash = (hash * 0x5bd1e995) ^ (hash >>> 15);
    }
    
    return Math.abs(hash);
  }
  
  getUniqueSeed() {
    let seed;
    let attempts = 0;
    
    do {
      seed = this.generateQuantumSeed();
      attempts++;
    } while(this.seedHistory.has(seed) && attempts < 100);
    
    this.seedHistory.add(seed);
    
    // Trim history if too large
    if(this.seedHistory.size > 1000) {
      const seeds = Array.from(this.seedHistory);
      this.seedHistory = new Set(seeds.slice(-500));
    }
    
    return seed;
  }
  
  // Generate unique premise with no repetition
  generatePremise(trial, nback, count = 1) {
    // Select random axis for this trial
    this.currentAxis = this.axes[Math.floor(Math.random() * this.axes.length)];
    
    const premises = [];
    
    for(let i = 0; i < count; i++) {
      let premise;
      let attempts = 0;
      
      do {
        const seed = this.getUniqueSeed();
        premise = this.buildComputationalPremise(seed, i, count);
        attempts++;
      } while(this.isDuplicate(premise) && attempts < 50);
      
      this.premiseHistory.push(premise);
      premises.push(premise);
    }
    
    // Trim history
    if(this.premiseHistory.length > 200) {
      this.premiseHistory = this.premiseHistory.slice(-100);
    }
    
    return premises;
  }
  
  isDuplicate(premise) {
    const hash = this.hashPremise(premise.text);
    if(this.generatedHashes.has(hash)) return true;
    
    this.generatedHashes.add(hash);
    
    // Also check semantic similarity
    for(const prev of this.premiseHistory.slice(-10)) {
      if(this.semanticallySimilar(premise.text, prev.text)) {
        return true;
      }
    }
    
    return false;
  }
  
  hashPremise(text) {
    let hash = 0;
    for(let i = 0; i < text.length; i++) {
      const char = text.charCodeAt(i);
      hash = ((hash << 5) - hash) + char;
      hash = hash & hash;
    }
    return hash;
  }
  
  semanticallySimilar(text1, text2) {
    const words1 = text1.split(' ');
    const words2 = text2.split(' ');
    
    if(words1.length !== words2.length) return false;
    
    let matches = 0;
    for(let i = 0; i < words1.length; i++) {
      if(words1[i] === words2[i]) matches++;
    }
    
    return matches > words1.length * 0.6;
  }
  
  buildComputationalPremise(seed, index, total) {
    const pattern = seed % 6;
    let text = '';
    
    switch(pattern) {
      case 0: // Transform cascade
        text = this.buildTransformCascade(seed);
        break;
      case 1: // Paradox resolution
        text = this.buildParadoxResolution(seed);
        break;
      case 2: // Meta-recursive
        text = this.buildMetaRecursive(seed, index, total);
        break;
      case 3: // Phase transition
        text = this.buildPhaseTransition(seed);
        break;
      case 4: // Quantum superposition
        text = this.buildQuantumSuperposition(seed);
        break;
      case 5: // Axis-specific transformation
        text = this.buildAxisTransformation(seed);
        break;
    }
    
    // Ensure exactly 5 words
    text = this.normalizeToFiveWords(text, seed);
    
    // Extract computational structure
    const structure = this.extractComputationalStructure(text);
    
    return {
      text: text,
      structure: structure,
      seed: seed,
      pattern: pattern,
      axis: this.currentAxis
    };
  }
  
  buildTransformCascade(seed) {
    const e1 = this.getUniqueEntity(seed);
    const t1 = this.getUniqueTransform('dissolution', seed);
    const e2 = this.getUniqueEntity(seed + 1);
    const med = this.mediators[seed % this.mediators.length];
    const e3 = this.getUniqueEntity(seed + 2);
    
    return `${e1} ${t1} ${e2} ${med} ${e3}`;
  }
  
  buildParadoxResolution(seed) {
    const p1 = this.getUniqueEntity(seed, 'paradox');
    const t = this.getUniqueTransform('inversion', seed);
    const e = this.getUniqueEntity(seed + 1);
    const mod = this.modifiers[seed % this.modifiers.length];
    
    return `${p1} ${t} ${e} ${mod} NOW`;
  }
  
  buildMetaRecursive(seed, index, total) {
    const ref = index > 0 ? 'IT' : 'ITSELF';
    const power = index > 1 ? '¬≤' : '';
    const t1 = this.getUniqueTransform('oscillation', seed);
    const t2 = this.getUniqueTransform('cascade', seed + 1);
    const compound = `${t1}-${t2}`;
    
    return `${ref}${power} ${compound} PRIOR through PARADOX`;
  }
  
  buildPhaseTransition(seed) {
    const e1 = this.getUniqueEntity(seed, 'state');
    const arrow = '‚Üí';
    const e2 = this.getUniqueEntity(seed + 1, 'state');
    const t = this.getUniqueTransform('crystallization', seed);
    const mod = this.modifiers[seed % this.modifiers.length];
    
    return `${e1}${arrow}${e2} ${t} ${mod} BECOMING`;
  }
  
  buildQuantumSuperposition(seed) {
    const e1 = this.getUniqueEntity(seed, 'quantum');
    const e2 = this.getUniqueEntity(seed + 1, 'quantum');
    const superposed = `${e1}|${e2}`;
    const t = this.getUniqueTransform('entanglement', seed);
    const state = seed % 2 === 0 ? 'COLLAPSING' : 'EXPANDING';
    
    return `${superposed} ${t} ${state} quantum-field`;
  }
  
  buildAxisTransformation(seed) {
    const transformsByAxis = {
      'spatial': ['tunneling', 'cascade', 'fragmentation'],
      'temporal': ['oscillation', 'cascade', 'crystallization'],
      'energetic': ['annihilation', 'dissolution', 'crystallization'],
      'informational': ['entanglement', 'inversion', 'fragmentation'],
      'causal': ['inversion', 'cascade', 'entanglement']
    };
    
    const validTransforms = transformsByAxis[this.currentAxis];
    const t = this.getUniqueTransform(validTransforms[seed % 3], seed);
    const e1 = this.getUniqueEntity(seed);
    const e2 = this.getUniqueEntity(seed + 1);
    const mod = `${this.currentAxis}ly`;
    
    return `${e1} ${t} ${e2} ${mod} ALWAYS`;
  }
  
  getUniqueEntity(seed, poolName = null) {
    const pools = poolName ? [this.entityPools[poolName]] : Object.values(this.entityPools);
    const pool = pools[seed % pools.length];
    return pool[seed % pool.length];
  }
  
  getUniqueTransform(conceptClass, seed) {
    return this.semanticTracker.getUnusedTransform(conceptClass);
  }
  
  normalizeToFiveWords(text, seed) {
    const words = text.split(' ').filter(w => w.length > 0);
    
    if(words.length === 5) return text;
    
    if(words.length > 5) {
      return words.slice(0, 5).join(' ');
    }
    
    // Pad with appropriate words
    const padding = ['quantumly', 'fractally', 'eternally', 'recursively', 'infinitely'];
    while(words.length < 5) {
      words.push(padding[(seed + words.length) % padding.length]);
    }
    
    return words.join(' ');
  }
  
  extractComputationalStructure(text) {
    // Parse text for transformations
    const transforms = [];
    const transformWords = Object.keys(this.transformEngine.transforms);
    
    for(const word of text.split(/[\s\-]+/)) {
      for(const t of transformWords) {
        if(word.toLowerCase().includes(t)) {
          transforms.push(t);
        }
      }
    }
    
    // Simulate transformation chain
    const initialState = {
      energy: 10,
      coherence: 1,
      order: 0.5,
      phase: 'neutral',
      time: 0
    };
    
    const finalState = this.transformEngine.compose(transforms, initialState);
    
    return {
      transforms: transforms,
      initialEnergy: initialState.energy,
      finalEnergy: finalState.energy,
      energyDelta: finalState.energy - initialState.energy,
      coherence: finalState.coherence,
      order: finalState.order,
      phase: finalState.phase,
      failed: finalState.failed || false,
      axis: this.currentAxis,
      complexity: transforms.length * 2 + (text.includes('¬≤') ? 3 : 0)
    };
  }
  
  // Deep compatibility checking through simulation
  checkDeepCompatibility(p1, p2) {
    const s1 = p1.structure;
    const s2 = p2.structure;
    
    if(!s1 || !s2) return false;
    
    // Simulate both transformations
    const result1 = this.transformEngine.compose(s1.transforms, {
      energy: 10, coherence: 1, order: 0.5, phase: 'neutral'
    });
    
    const result2 = this.transformEngine.compose(s2.transforms, {
      energy: 10, coherence: 1, order: 0.5, phase: 'neutral'
    });
    
    // Check compatibility
    const compatible = this.transformEngine.areCompatible(result1, result2);
    
    // Additional checks for deep compatibility
    const topologyMatch = this.checkTopologyMatch(s1.transforms, s2.transforms);
    const axisCompatible = !s1.axis || !s2.axis || s1.axis === s2.axis || 
                           this.axesAreCompatible(s1.axis, s2.axis);
    
    // Calculate compatibility score
    let score = 0;
    if(compatible) score += 0.4;
    if(topologyMatch) score += 0.3;
    if(axisCompatible) score += 0.2;
    if(Math.abs(s1.energyDelta - s2.energyDelta) < 3) score += 0.1;
    
    return score >= 0.5;
  }
  
  checkTopologyMatch(t1, t2) {
    if(t1.length === 0 || t2.length === 0) return false;
    
    // Check if transformation sequences have similar structure
    const reversible1 = t1.some(t => ['crystallize', 'coalesce', 'invert'].includes(t));
    const reversible2 = t2.some(t => ['crystallize', 'coalesce', 'invert'].includes(t));
    
    const destructive1 = t1.some(t => ['annihilate', 'fragment', 'dissolve'].includes(t));
    const destructive2 = t2.some(t => ['annihilate', 'fragment', 'dissolve'].includes(t));
    
    return (reversible1 === reversible2) || (destructive1 === destructive2);
  }
  
  axesAreCompatible(a1, a2) {
    const compatibility = {
      'spatial': ['temporal', 'energetic'],
      'temporal': ['spatial', 'causal'],
      'energetic': ['spatial', 'informational'],
      'informational': ['energetic', 'causal'],
      'causal': ['temporal', 'informational']
    };
    
    return compatibility[a1] && compatibility[a1].includes(a2);
  }
  
  reset() {
    this.generatedHashes.clear();
    this.premiseHistory = [];
    this.seedHistory.clear();
    this.semanticTracker.reset();
  }
}

/* ===== Global state ===== */
const premiseGenerator = new QuantumSemanticGeneratorV2();
let MAX=200, RATE=25, N=1, SPEAK=true, SOLVE_WINDOW=5.0, STATEMENTS=1;

/* ===== Session management ===== */
let idx=0, correct=0, errors=0, planned=[], history=[], SESSION={running:false, paused:false};
let currentTruth=false, responded=false, solveTimer=null, countdownTimer=null, countdownLeft=0;

function planSequence(){ 
  planned.length=MAX; 
  for(let i=0;i<MAX;i++) planned[i]=false; 
  const elig=[]; 
  for(let i=N;i<MAX;i++) elig.push(i); 
  const k=Math.round((RATE/100)*elig.length); 
  shuffle(elig); 
  for(let i=0;i<k;i++) planned[elig[i]]=true; 
}

function sanitizeText(text) {
  // Remove any HTML tags or entities
  return text.replace(/[<>&"']/g, '').replace(/\//g, '/');
}

function showPremises(premises) {
  const container = $('premiseContainer');
  container.innerHTML = '';
  
  const arr = Array.isArray(premises) ? premises : [premises];
  
  arr.forEach((p, i) => {
    const div = document.createElement('div');
    div.className = 'premise-line';
    
    if(arr.length > 1) {
      const num = document.createElement('span');
      num.className = 'premise-number';
      num.textContent = (i+1).toString();
      div.appendChild(num);
    }
    
    const text = sanitizeText(p.text || p);
    const words = text.split(' ');
    
    // Create spans for each word with appropriate styling
    words.forEach((word, idx) => {
      const span = document.createElement('span');
      
      // Determine styling based on word type
      if(/^[A-Z]+$/.test(word) && word.length > 2) {
        if(['BOTH','NEITHER','ALL','NONE','ALWAYS','NEVER','ETERNAL'].includes(word)) {
          span.className = 'paradox';
        } else if(['IT','ITSELF','THIS','THAT','PRIOR','OTHER'].includes(word)) {
          span.className = 'meta';
        } else if(['COLLAPSING','EXPANDING','BECOMING','NOW'].includes(word)) {
          span.className = 'quantum';
        } else {
          span.className = 'entity';
        }
      } else if(word.includes('-')) {
        span.className = 'compound';
      } else if(['through','via','within','across','between','beyond'].includes(word)) {
        span.className = 'mediator';
      } else if(word.includes('ly')) {
        span.className = 'modifier';
      } else if(word.includes('|') || word.includes('‚Üí') || word.includes('¬≤')) {
        span.className = 'quantum';
      } else {
        span.className = 'transform';
      }
      
      span.textContent = word;
      div.appendChild(span);
      
      if(idx < words.length - 1) {
        div.appendChild(document.createTextNode(' '));
      }
    });
    
    // Add metadata
    if(p.structure) {
      const meta = document.createElement('div');
      meta.className = 'meta-info';
      meta.textContent = `[Energy: ${p.structure.finalEnergy.toFixed(1)} (Œî${p.structure.energyDelta.toFixed(1)}), ` +
                        `Coherence: ${p.structure.coherence.toFixed(2)}, ` +
                        `Phase: ${p.structure.phase}, ` +
                        `Axis: ${p.structure.axis || 'neutral'}]`;
      div.appendChild(meta);
    }
    
    container.appendChild(div);
  });
}

function updateUI(){ 
  setText('idx', idx); 
  setText('max', MAX); 
  setText('ptype', (idx<MAX && idx>=N && planned[idx])?'MATCH':'NON-match'); 
  setText('corr', correct); 
  setText('err', errors); 
  setText('isMatch','‚Äî'); 
}

async function speak(text){
  if(!SPEAK) return Promise.resolve();
  if(typeof window==='undefined'||!('speechSynthesis' in window)) return Promise.resolve();
  
  const speakText = Array.isArray(text) ? 
    text.map(p => sanitizeText(p.text || p)).join('. ') : 
    sanitizeText(text.text || text);
    
  return new Promise(res=>{ 
    try{ 
      const u=new SpeechSynthesisUtterance(speakText); 
      u.lang='en-GB'; 
      u.rate=0.65; 
      u.pitch=1.0; 
      u.volume=1.0; 
      u.onend=()=>res(); 
      u.onerror=()=>res(); 
      if(window.speechSynthesis.speaking) window.speechSynthesis.cancel(); 
      window.speechSynthesis.speak(u); 
    }catch{ 
      res(); 
    } 
  });
}

function scheduleCountdown(sec){ 
  countdownLeft=sec; 
  setText('countdown', countdownLeft.toFixed(1)+'s'); 
  if(countdownTimer) clearInterval(countdownTimer); 
  countdownTimer=setInterval(()=>{ 
    countdownLeft=Math.max(0,countdownLeft-0.1); 
    setText('countdown', countdownLeft.toFixed(1)+'s'); 
    if(countdownLeft<=0){ 
      clearInterval(countdownTimer); 
      countdownTimer=null; 
    } 
  },100); 
}

function evaluateAndAdvance(){ 
  const resp=responded, truth=currentTruth; 
  if(resp===truth) correct++; 
  else errors++; 
  setText('corr',correct); 
  setText('err',errors); 
  setText('isMatch', String(truth).toUpperCase()); 
  idx++; 
  if(idx>=MAX){ 
    stop(); 
    return; 
  } 
  runTrial(); 
}

function runTrial(){
  if(!SESSION.running || SESSION.paused) return;
  
  const mustMatch=(idx>=N)&&planned[idx];
  
  let premises = premiseGenerator.generatePremise(idx, N, STATEMENTS);
  
  if(idx >= N) {
    const reference = history[idx-N];
    
    if(mustMatch) {
      // Try to generate compatible premise
      let attempts = 0;
      let compatible = false;
      
      while(!compatible && attempts < 30) {
        premises = premiseGenerator.generatePremise(idx + attempts, N, STATEMENTS);
        compatible = premiseGenerator.checkDeepCompatibility(premises[0], reference[0]);
        attempts++;
      }
      
      currentTruth = true; // Force match as planned
    } else {
      // Check if accidentally compatible
      const compatible = premiseGenerator.checkDeepCompatibility(premises[0], reference[0]);
      
      if(compatible) {
        // Generate incompatible premise
        let attempts = 0;
        while(compatible && attempts < 20) {
          premises = premiseGenerator.generatePremise(idx + attempts * 1000, N, STATEMENTS);
          if(!premiseGenerator.checkDeepCompatibility(premises[0], reference[0])) {
            break;
          }
          attempts++;
        }
      }
      
      currentTruth = false; // Force non-match as planned
    }
  } else {
    currentTruth = false;
  }
  
  history[idx] = premises;
  showPremises(premises); 
  responded=false;
  
  setText('isMatch','‚Äî'); 
  setText('ptype', (idx<MAX && idx>=N && planned[idx])?'MATCH':'NON-match');

  speak(premises).then(()=>{ 
    scheduleCountdown(SOLVE_WINDOW); 
    if(solveTimer) clearTimeout(solveTimer); 
    solveTimer=setTimeout(()=>{ 
      evaluateAndAdvance(); 
    }, SOLVE_WINDOW*1000); 
  });
}

/* Controls */
function start(){
  MAX=+$('trials').value||200; 
  RATE=+$('rate').value||25; 
  N=+$('nback').value||1; 
  STATEMENTS=+$('statements').value||1;
  SPEAK=!!$('speakEnabled').checked;
  SOLVE_WINDOW=+($('solveWindow').value||5); 
  setText('solveLabel', SOLVE_WINDOW.toFixed(1)); 
  setText('solveVal', SOLVE_WINDOW.toFixed(1)+'s');
  
  // Full reset
  premiseGenerator.reset();

  idx=0; 
  correct=0; 
  errors=0; 
  planned=[]; 
  history=[]; 
  planSequence(); 
  updateUI();
  SESSION.running=true; 
  SESSION.paused=false;
  $('pause').disabled=false; 
  $('reset').disabled=false; 
  $('hit').disabled=false; 
  $('skip').disabled=false;
  runTrial();
}

function stop(){ 
  SESSION.running=false; 
  SESSION.paused=false; 
  if(solveTimer) clearTimeout(solveTimer); 
  if(countdownTimer) clearInterval(countdownTimer); 
  setText('countdown','‚Äî'); 
  try{ 
    if(window.speechSynthesis) window.speechSynthesis.cancel(); 
  }catch{} 
}

function togglePause(){
  if(!SESSION.running) return;
  SESSION.paused=!SESSION.paused; 
  $('pause').textContent=SESSION.paused?'‚ñ∂ Resume':'‚è∏ Pause';
  if(SESSION.paused){ 
    if(solveTimer) clearTimeout(solveTimer); 
    if(countdownTimer) clearInterval(countdownTimer); 
    try{ 
      if(window.speechSynthesis) window.speechSynthesis.cancel(); 
    }catch{} 
  }
  else{
    scheduleCountdown(countdownLeft>0?countdownLeft:SOLVE_WINDOW);
    if(solveTimer) clearTimeout(solveTimer);
    solveTimer=setTimeout(()=>{ 
      evaluateAndAdvance(); 
    }, (countdownLeft>0?countdownLeft:SOLVE_WINDOW)*1000);
  }
}

function reset(){ 
  stop(); 
  premiseGenerator.reset();
  
  $('premiseContainer').innerHTML='‚Äî'; 
  setText('idx',0); 
  setText('corr',0); 
  setText('err',0); 
  setText('ptype','‚Äî'); 
  setText('isMatch','‚Äî'); 
}

function registerHit(){ 
  if(!SESSION.running || SESSION.paused) return; 
  responded=true; 
}

function skip(){ 
  if(!SESSION.running || SESSION.paused) return; 
  if(solveTimer) clearTimeout(solveTimer); 
  if(countdownTimer) clearInterval(countdownTimer); 
  setText('countdown','‚Äî'); 
  evaluateAndAdvance(); 
}

/* Event bindings */
document.addEventListener('DOMContentLoaded', ()=>{
  // Instructions modal
  const modal = $('instructionsModal');
  const btn = $('instructionsBtn');
  const span = document.querySelector('.close');
  
  btn.onclick = () => { modal.style.display = 'block'; };
  span.onclick = () => { modal.style.display = 'none'; };
  window.onclick = (e) => {
    if(e.target === modal) modal.style.display = 'none';
  };
  
  // Settings
  const sw=$('solveWindow'); 
  const updateSW=()=>{ 
    const v=+sw.value; 
    setText('solveVal', v.toFixed(1)+'s'); 
    setText('solveLabel', v.toFixed(1)); 
  };
  updateSW(); 
  sw.oninput=e=>{ 
    if(!SESSION.running){ 
      updateSW(); 
    } 
  };
  
  $('nback').oninput=e=>{ 
    if(!SESSION.running){ 
      N=+e.target.value; 
      setText('nVal',N); 
      setText('modeLine',`Cognitive Singularity v2.0 ‚Ä¢ G-Load: ~0.90+ ‚Ä¢ N=${N}`);
    } 
  };
  
  $('statements').oninput=e=>{ 
    if(!SESSION.running){ 
      STATEMENTS=+e.target.value; 
      setText('stmtVal',STATEMENTS); 
    } 
  };
  
  $('trials').oninput=e=>{ 
    if(!SESSION.running){ 
      MAX=+e.target.value; 
      setText('tVal',MAX); 
      setText('max',MAX); 
    } 
  };
  
  $('rate').oninput=e=>{ 
    if(!SESSION.running){ 
      RATE=+e.target.value; 
      setText('rVal',RATE+'%'); 
    } 
  };
  
  $('speakEnabled').onchange=e=>{ 
    SPEAK=!!e.target.checked; 
  };

  $('start').onclick=start; 
  $('pause').onclick=togglePause; 
  $('reset').onclick=reset; 
  $('hit').onclick=registerHit; 
  $('skip').onclick=skip;
  
  window.addEventListener('keydown', e=>{ 
    if(!SESSION.running) return; 
    if(e.code==='Space'){ 
      registerHit(); 
      e.preventDefault(); 
    } 
  });

  setText('nVal',N); 
  setText('stmtVal',STATEMENTS);
  setText('tVal',MAX); 
  setText('rVal',RATE+'%');
  setText('modeLine',`Cognitive Singularity v2.0 ‚Ä¢ G-Load: ~0.90+ ‚Ä¢ N=${N}`);
  updateUI();
});
</script>
</body>
</html>
