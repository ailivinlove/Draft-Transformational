<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>Canonical State-Vector N-Back | ‚â•0.90 G-Load Protocol</title>
<style>
:root { 
  --bg:#0a0a0f; 
  --fg:#e6fbff; 
  --accent:#00ccff; 
  --mut:#8fe7ff; 
  --success:#26de81;
  --error:#ff6b6b;
  --warning:#ffd700;
  --quantum:#ff00ff;
  --cascade:#a55eea;
}

* { box-sizing:border-box; margin:0; padding:0; }
html, body { height:100%; overflow-x:hidden; }
body { 
  background:linear-gradient(135deg, #0a0a0f 0%, #0f1419 100%); 
  color:var(--fg); 
  font-family:system-ui,-apple-system,Segoe UI,Roboto,sans-serif;
}

.container { max-width:1280px; margin:0 auto; padding:20px; }
.grid { display:grid; grid-template-columns:repeat(auto-fit, minmax(350px, 1fr)); gap:20px; margin-bottom:20px; }

.panel { 
  background:rgba(16,20,24,0.95); 
  border:1px solid rgba(0,200,255,.3); 
  border-radius:12px; 
  padding:20px; 
  backdrop-filter:blur(10px);
  box-shadow:0 4px 20px rgba(0,0,0,0.4);
}

.panel-title { 
  font-weight:800; 
  margin-bottom:15px; 
  color:var(--accent);
  text-shadow:0 0 10px rgba(0,200,255,0.3);
  font-size:18px;
}

.btn { 
  background:rgba(0,200,255,0.1); 
  color:var(--accent); 
  border:1px solid var(--accent); 
  border-radius:8px; 
  padding:12px 20px; 
  font-weight:700; 
  cursor:pointer; 
  transition:all 0.3s;
  font-size:14px;
}
.btn:hover:not(:disabled) { 
  background:rgba(0,200,255,0.25); 
  box-shadow:0 0 20px rgba(0,200,255,.5);
  transform:translateY(-1px);
}
.btn:disabled { opacity:0.4; cursor:not-allowed; }

.btn.instructions { 
  background:rgba(95,39,205,0.2); 
  border-color:#5f27cd; 
  color:#a55eea;
}
.btn.instructions:hover { 
  background:rgba(95,39,205,0.4); 
  box-shadow:0 0 20px rgba(95,39,205,.6);
}

label { 
  font-size:13px; 
  color:var(--mut); 
  display:block; 
  margin:12px 0 6px 0;
  font-weight:600;
  text-transform:uppercase;
  letter-spacing:0.5px;
}

input[type=range] { 
  width:100%; 
  height:6px;
  background:rgba(0,200,255,0.1);
  border-radius:3px;
  outline:none;
  -webkit-appearance:none;
}
input[type=range]::-webkit-slider-thumb {
  -webkit-appearance:none;
  width:18px;
  height:18px;
  background:var(--accent);
  border-radius:50%;
  cursor:pointer;
  box-shadow:0 0 10px rgba(0,200,255,0.5);
}
input[type=range]::-moz-range-thumb {
  width:18px;
  height:18px;
  background:var(--accent);
  border-radius:50%;
  cursor:pointer;
  box-shadow:0 0 10px rgba(0,200,255,0.5);
}

.kbd { 
  display:inline-block;
  padding:4px 8px; 
  border-radius:4px; 
  background:rgba(0,0,0,0.5); 
  border:1px solid rgba(255,255,255,.3);
  font-size:12px;
  font-weight:bold;
  box-shadow:0 2px 4px rgba(0,0,0,0.3);
}

#premiseDisplay { 
  min-height:180px; 
  background:linear-gradient(135deg, rgba(14,17,19,0.98), rgba(19,22,25,0.98));
  border:2px solid rgba(0,200,255,.4); 
  border-radius:12px; 
  padding:30px; 
  font-size:34px; 
  line-height:2.0; 
  font-family:'Courier New',monospace; 
  font-weight:900; 
  letter-spacing:1px;
  position:relative;
  overflow:hidden;
  box-shadow:inset 0 0 30px rgba(0,200,255,0.05);
}

@keyframes pulse { 0%,100%{opacity:1} 50%{opacity:0.8} }
@keyframes fadeIn { from{opacity:0; transform:translateY(10px)} to{opacity:1; transform:translateY(0)} }
@keyframes quantumFlicker { 
  0%{opacity:1; filter:hue-rotate(0deg)} 
  50%{opacity:0.7; filter:hue-rotate(180deg)} 
  100%{opacity:1; filter:hue-rotate(360deg)} 
}

.premise-text { 
  padding:20px; 
  margin:10px 0;
  border-left:6px solid var(--accent); 
  background:linear-gradient(90deg, rgba(0,200,255,.1), transparent); 
  border-radius:4px; 
  animation:fadeIn 0.5s ease-out;
}

/* Symbol highlighting */
.sym-primary { color:#ff6b6b; text-shadow:0 0 15px rgba(255,107,107,.8); }
.sym-secondary { color:#4ecdc4; text-shadow:0 0 15px rgba(78,205,196,.8); }
.sym-number { color:#ff00ff; text-shadow:0 0 15px rgba(255,0,255,.8); }
.sym-color { text-shadow:0 0 15px currentColor; font-weight:900; }
.operation { color:#26de81; font-style:italic; }
.relation { color:#a55eea; font-weight:900; text-decoration:underline dotted; }
.state { color:#ffd700; font-weight:bold; }
.compound { background:rgba(0,210,211,0.15); padding:2px 6px; border-radius:3px; }
.quantum { animation:quantumFlicker 2s infinite; }
.scheduled { 
  background:rgba(165,94,234,0.2); 
  border:1px dashed var(--cascade); 
  padding:2px 6px; 
  border-radius:3px; 
}

.feedback {
  margin-top:20px;
  padding:15px;
  border-radius:8px;
  font-size:16px;
  font-weight:600;
  animation:fadeIn 0.5s ease-out;
}
.feedback.correct {
  background:rgba(38,222,129,0.2);
  border:1px solid var(--success);
  color:var(--success);
}
.feedback.incorrect {
  background:rgba(255,107,107,0.2);
  border:1px solid var(--error);
  color:var(--error);
}
.feedback.missed {
  background:rgba(255,215,0,0.2);
  border:1px solid var(--warning);
  color:var(--warning);
}

.status-display {
  display:flex;
  justify-content:space-between;
  margin-top:15px;
  padding:10px;
  background:rgba(0,0,0,0.3);
  border-radius:6px;
}
.status-item {
  font-size:14px;
  font-weight:600;
}

.state-tracker {
  margin-top:10px;
  padding:10px;
  background:rgba(0,0,0,0.4);
  border-radius:6px;
  font-size:11px;
  font-family:'Courier New',monospace;
  color:var(--mut);
  display:none;
  max-height:200px;
  overflow-y:auto;
}

.state-tracker.active {
  display:block;
}

.proof-trace {
  background:rgba(0,0,0,0.3);
  border:1px solid rgba(0,200,255,0.2);
  padding:10px;
  margin-top:10px;
  font-size:11px;
  font-family:'Courier New',monospace;
  color:var(--mut);
  border-radius:4px;
  max-height:150px;
  overflow-y:auto;
}

.conservation-display {
  margin-top:10px;
  padding:8px;
  background:rgba(255,0,255,0.1);
  border:1px solid var(--quantum);
  border-radius:6px;
  font-size:12px;
  font-family:'Courier New',monospace;
}

.scheduled-effects {
  margin-top:10px;
  padding:8px;
  background:rgba(165,94,234,0.1);
  border:1px solid var(--cascade);
  border-radius:6px;
  font-size:12px;
}

.difficulty-indicator {
  display:inline-block;
  padding:4px 8px;
  border-radius:4px;
  font-size:11px;
  font-weight:bold;
  margin-left:10px;
}
.diff-level-1 { background:rgba(38,222,129,0.2); color:var(--success); }
.diff-level-2 { background:rgba(255,215,0,0.2); color:var(--warning); }
.diff-level-3 { background:rgba(255,107,107,0.2); color:var(--error); }
.diff-level-4 { background:rgba(255,0,255,0.2); color:var(--quantum); }
.diff-level-5 { background:rgba(165,94,234,0.2); color:var(--cascade); }

/* Modal */
.modal {
  display:none;
  position:fixed;
  z-index:1000;
  left:0;
  top:0;
  width:100%;
  height:100%;
  background:rgba(0,0,0,0.95);
  backdrop-filter:blur(10px);
}

.modal-content {
  background:linear-gradient(135deg, #0f1419, #1a1f25);
  margin:20px auto;
  padding:30px;
  border:2px solid var(--accent);
  border-radius:15px;
  width:90%;
  max-width:900px;
  max-height:90vh;
  overflow-y:auto;
  box-shadow:0 0 50px rgba(0,200,255,.5);
}

.modal h2 { color:var(--accent); margin:25px 0; }
.modal h3 { color:var(--mut); margin:20px 0; }
.modal p { line-height:1.8; margin:15px 0; }
.modal ul { line-height:1.8; padding-left:30px; }

.example-box {
  background:rgba(0,0,0,0.5);
  border-left:4px solid var(--accent);
  padding:15px;
  margin:20px 0;
  font-family:'Courier New',monospace;
  border-radius:5px;
}

.close-modal {
  color:var(--accent);
  float:right;
  font-size:32px;
  font-weight:bold;
  cursor:pointer;
  transition:all 0.3s;
}
.close-modal:hover { 
  color:var(--error);
  transform:rotate(90deg);
}

.counterfactual-test {
  background:rgba(255,0,255,0.05);
  border:1px dashed var(--quantum);
  padding:8px;
  margin-top:5px;
  font-size:10px;
  font-family:'Courier New',monospace;
  color:var(--quantum);
}

.canonical-mapping {
  display:flex;
  justify-content:space-between;
  padding:5px;
  background:rgba(0,200,255,0.05);
  border-radius:3px;
  margin:2px 0;
  font-size:11px;
  font-family:'Courier New',monospace;
}
</style>
</head>
<body>
<div class="container">
  <div class="grid">
    <div class="panel">
      <div class="panel-title">‚öôÔ∏è Configuration</div>
      
      <label>Difficulty Level: <span id="difficultyValue">Level 2 (0.90g)</span>
        <span id="difficultyIndicator" class="difficulty-indicator diff-level-2">0.90g</span>
      </label>
      <input type="range" id="difficultyLevel" min="1" max="5" value="2">
      
      <label>N-Back Level: <span id="nbackValue">2</span></label>
      <input type="range" id="nbackLevel" min="1" max="5" value="2">
      
      <label>Statements per Trial: <span id="stmtValue">1</span></label>
      <input type="range" id="statementsPerTrial" min="1" max="3" value="1">
      
      <label>Match Probability: <span id="matchProbValue">30%</span></label>
      <input type="range" id="matchProbability" min="0" max="100" step="5" value="30">
      
      <label>Response Window: <span id="windowValue">8.0s</span></label>
      <input type="range" id="responseWindow" min="1" max="30" step="0.5" value="8">
      
      <label style="margin-top:15px">
        <input type="checkbox" id="voiceEnabled" checked> Voice Synthesis
      </label>
      
      <label>
        <input type="checkbox" id="proofTraces" checked> Show Proof Traces
      </label>
      
      <label>
        <input type="checkbox" id="counterfactuals"> Counterfactual Verification
      </label>
      
      <button id="instructionsBtn" class="btn instructions" style="width:100%; margin-top:20px">
        üìñ Instructions & Theory
      </button>
    </div>
    
    <div class="panel">
      <div class="panel-title">üéÆ Controls</div>
      
      <div style="display:flex; gap:10px; margin-bottom:20px">
        <button id="startBtn" class="btn" style="flex:1">‚ñ∂ Start</button>
        <button id="pauseBtn" class="btn" style="flex:1" disabled>‚è∏ Pause</button>
        <button id="resetBtn" class="btn" style="flex:1" disabled>üîÑ Reset</button>
      </div>
      
      <div style="padding:15px; background:rgba(0,200,255,0.1); border-radius:8px; text-align:center; margin-bottom:15px">
        <strong>Press <span class="kbd">SPACEBAR</span> when you detect a match!</strong>
      </div>
      
      <div class="status-display">
        <div class="status-item">Trial: <span id="currentTrial">0</span>/<span id="totalTrials">50</span></div>
        <div class="status-item">Timer: <span id="countdown" style="color:var(--accent)">‚Äî</span></div>
      </div>
      
      <div class="status-display">
        <div class="status-item" style="color:var(--success)">Hits: <span id="correctHits">0</span></div>
        <div class="status-item" style="color:var(--error)">False: <span id="falseAlarms">0</span></div>
        <div class="status-item" style="color:var(--warning)">Missed: <span id="misses">0</span></div>
      </div>
      
      <div class="scheduled-effects" id="scheduledEffects" style="display:none">
        <strong style="color:var(--cascade)">‚è± Scheduled Effects:</strong>
        <div id="scheduledList"></div>
      </div>
    </div>
    
    <div class="panel">
      <div class="panel-title">üìä Performance Metrics</div>
      
      <div style="font-size:14px; line-height:2">
        <div>Accuracy: <span id="accuracy" style="font-weight:bold">‚Äî</span></div>
        <div>Avg Response Time: <span id="avgResponse" style="font-weight:bold">‚Äî</span></div>
        <div>Session Progress: <span id="progress" style="font-weight:bold">0%</span></div>
        <div>Confidence Score: <span id="confidence" style="font-weight:bold">‚Äî</span></div>
      </div>
      
      <div class="conservation-display" id="conservationDisplay">
        <div style="font-weight:bold; color:var(--quantum)">Conservation Status:</div>
        <div>Œ£E: <span id="totalEnergy">100</span></div>
        <div>Œ£p: <span id="totalMomentum">(0,0,0)</span></div>
        <div>Œ£I: <span id="totalInfo">50</span></div>
        <div>Active: <span id="activeSymbols">0</span></div>
      </div>
      
      <div class="state-tracker" id="stateTracker">
        <div style="color:var(--accent); font-weight:bold; margin-bottom:5px">Canonical State Vectors:</div>
        <div id="stateTrackerContent"></div>
      </div>
    </div>
  </div>
  
  <div class="panel">
    <div class="panel-title">üß† Canonical State-Vector Tracking ‚Ä¢ G-Load: <span id="currentGLoad">0.90</span></div>
    <div id="premiseDisplay">
      <div style="text-align:center; color:var(--mut); font-size:20px; font-weight:normal">
        Press START to begin canonical state-vector tracking
      </div>
    </div>
    <div id="canonicalMappings" style="margin-top:10px"></div>
    <div id="feedbackArea"></div>
  </div>
</div>

<!-- Instructions Modal -->
<div id="instructionsModal" class="modal">
  <div class="modal-content">
    <span class="close-modal">&times;</span>
    <h2>Canonical State-Vector N-Back Protocol (‚â•0.90 G-Load)</h2>
    
    <p><strong>CORE CONCEPT:</strong> This is deterministic state-vector simulation with persistent canonical identity. Each symbol maintains an immutable ID across ALL trials, accumulating transformations through multi-dimensional state vectors that compound over time.</p>
    
    <h3>I. Theoretical Foundation: From Topology to Trajectory</h3>
    <p>Unlike pattern matching, this requires genuine mental physics simulation. Each symbol is a quantum-like entity with:</p>
    <ul>
      <li><strong>Canonical Identity (ID):</strong> Persists across entire session</li>
      <li><strong>State Vector:</strong> {x, y, z, energy, momentum, phase, information}</li>
      <li><strong>Accumulated History:</strong> States compound across all premises</li>
      <li><strong>Scheduled Effects:</strong> Operations can execute in future trials</li>
      <li><strong>Conservation Laws:</strong> Total energy/momentum must balance</li>
    </ul>
    
    <h3>II. Progressive Difficulty Levels</h3>
    <div class="example-box">
      Level 1 (0.85g): Current topology matching
      Level 2 (0.90g): Canonical tracking + state accumulation
      Level 3 (0.93g): + Scheduled effects + conservation
      Level 4 (0.95g): + Recursive effects + counterfactuals
      Level 5 (0.97g+): + Quantum superposition + entanglement
    </div>
    
    <h3>III. Dual-Layer Representation</h3>
    <p>Each premise has two layers:</p>
    <ul>
      <li><strong>Surface:</strong> 5 simple words you see (DOG, CAT, etc.)</li>
      <li><strong>Canonical:</strong> Hidden persistent IDs (D1, C1, etc.)</li>
    </ul>
    <p>Synonyms map to same ID: DOG‚ÜíD1, HOUND‚ÜíD1, CANINE‚ÜíD1</p>
    
    <h3>IV. Example 1: Basic Identity Tracking</h3>
    <div class="example-box">
      Trial 1: "CIRCLE pushes SQUARE moving rightward"
      Internal: C1 pushes S1, C1{x:-1, energy:9}, S1{x:+2, energy:11}
      
      Trial 3: "SPHERE pushes SQUARE moving rightward"
      Internal: C1 pushes S1 (SPHERE maps to same C1!)
      
      MATCH! CIRCLE and SPHERE both ‚Üí canonical ID "C1"
    </div>
    
    <h3>V. Example 2: State Accumulation</h3>
    <div class="example-box">
      Setup: DOG starts at position (0,0), energy 10
      
      Trial 1: "DOG runs toward CAT quickly"
      After: DOG{x:+3, energy:8}, CAT{x:0, energy:10}
      
      Trial 2: [unrelated premise]
      
      Trial 3: "HOUND sprints toward FELINE rapidly"
      Must check: Does HOUND (=DOG) start from x:3, energy:8?
      
      DOG's state from Trial 1 carries forward!
      Match requires identical evolution from accumulated state.
    </div>
    
    <h3>VI. Example 3: Conservation Laws</h3>
    <div class="example-box">
      Trial 1: "ENGINE pushes CART forward strongly"
      Internal: E1{momentum:-2}, C1{momentum:+2}
      Total momentum: 0 ‚úì (conserved)
      
      Trial 3: "MOTOR pushes WAGON forward strongly"
      Internal: M1{momentum:-1}, W1{momentum:+3}
      Total momentum: +2 ‚úó (violation!)
      
      NO MATCH - conservation law broken!
    </div>
    
    <h3>VII. Example 4: Scheduled/Delayed Effects</h3>
    <div class="example-box">
      Trial 1: "TRIGGER activates TIMER counting down"
      Schedules: TIMER will explode at Trial 3 (t+2)
      
      Trial 2: [unrelated - but TIMER still counting]
      
      Trial 3: [TIMER explodes automatically!]
      You must track this was scheduled, not new.
      
      Delayed effects create temporal dependencies.
    </div>
    
    <h3>VIII. Example 5: Recursive Effects (Level 4+)</h3>
    <div class="example-box">
      Trial 1: "OSCILLATOR triggers WAVE repeating periodically"
      Schedules: WAVE pulses every 2 trials recursively
      
      Trial 3: WAVE pulses (first scheduled pulse)
      Trial 5: WAVE pulses (second scheduled pulse)
      Trial 7: WAVE pulses (continues recursively)
      
      Must track recursive patterns mentally!
    </div>
    
    <h3>IX. Example 6: Counterfactual Verification (Level 4+)</h3>
    <div class="example-box">
      Trial 1: "RED-ATOM splits forming TWO-PARTICLES"
      
      To verify match with Trial 3:
      1. Primary hypothesis: Same split pattern ‚úì
      2. Counterfactual 1: What if RED‚â†BLUE? Test...
      3. Counterfactual 2: What if energy differs? Test...
      4. Counterfactual 3: What if momentum unbalanced? Test...
      
      Match only if robust to all plausible alternatives.
    </div>
    
    <h3>X. Transformation Operators</h3>
    <div class="example-box">
      PUSH ‚Üí Œîmomentum_x = +2, Œîenergy = -1
      PULL ‚Üí Œîmomentum_x = -2, Œîenergy = -1
      SPLIT ‚Üí divide energy equally, mark original as consumed
      MERGE ‚Üí combine energies, mark originals as consumed
      ROTATE ‚Üí swap momentum components, Œîphase = œÄ/4
      CASCADE ‚Üí propagate 50% effect to connected symbols
      TRIGGER ‚Üí schedule future effect at t+k
    </div>
    
    <h3>XI. Proof Trace Requirements</h3>
    <p>Every match determination includes:</p>
    <ul>
      <li>Symbol mapping (surface ‚Üí canonical ID)</li>
      <li>State evolution for each symbol</li>
      <li>Conservation verification at each step</li>
      <li>Counterfactual robustness check (Level 4+)</li>
      <li>Confidence score ‚â•0.90 for match claim</li>
    </ul>
    
    <h3>XII. Cognitive Load Amplification</h3>
    <p>Your working memory must simultaneously:</p>
    <ul>
      <li>Maintain identity mappings (surface ‚Üí canonical)</li>
      <li>Track multi-dimensional state vectors</li>
      <li>Hold n-back history while processing current</li>
      <li>Simulate temporal evolution forward</li>
      <li>Verify conservation constraints</li>
      <li>Monitor scheduled effects queue</li>
      <li>Test counterfactual alternatives (Level 4+)</li>
      <li>Handle quantum superposition (Level 5)</li>
    </ul>
    
    <h3>XIII. Why This Achieves ‚â•0.90 G-Load</h3>
    <p>This protocol transforms n-back from pattern recognition into genuine mental physics simulation. No heuristics suffice‚Äîonly complete computational modeling succeeds. The mind becomes a deterministic state machine, tracking each symbol's journey through abstract phase space while maintaining global conservation laws.</p>
    
    <p><strong>The Beautiful Paradox:</strong> Though the surface remains five simple words, beneath lies a complete computational universe demanding total cognitive commitment. Every neuron recruited, every quantum of attention consumed, all to answer: "Does this universe evolve identically to the one I witnessed n trials ago?"</p>
    
    <p><strong>Remember:</strong> Pattern matching will fail. You must track actual symbol states through time. This is pure fluid intelligence at its limit.</p>
  </div>
</div>

<script>
/* ============================================================
   CANONICAL STATE-VECTOR N-BACK PROTOCOL
   ‚â•0.90 G-LOAD IMPLEMENTATION WITH FULL SPECIFICATIONS
   ============================================================ */

// DOM helpers
const $ = id => document.getElementById(id);
const setText = (id, text) => { const el = $(id); if(el) el.textContent = text; };

/* ===== DIFFICULTY LEVEL CONFIGURATIONS ===== */
const DIFFICULTY_CONFIGS = {
  1: { // 0.85g - Current topology matching
    gLoad: 0.85,
    name: "Topology Matching",
    persistentState: false,
    conservation: false,
    scheduledEffects: false,
    recursiveEffects: false,
    counterfactuals: false,
    quantumSuperposition: false,
    axisMutations: false
  },
  2: { // 0.90g - Canonical tracking
    gLoad: 0.90,
    name: "Canonical Tracking",
    persistentState: true,
    conservation: false,
    scheduledEffects: false,
    recursiveEffects: false,
    counterfactuals: false,
    quantumSuperposition: false,
    axisMutations: false
  },
  3: { // 0.93g - Temporal dependencies
    gLoad: 0.93,
    name: "Temporal Dependencies",
    persistentState: true,
    conservation: true,
    scheduledEffects: true,
    recursiveEffects: false,
    counterfactuals: false,
    quantumSuperposition: false,
    axisMutations: false
  },
  4: { // 0.95g - Full simulation
    gLoad: 0.95,
    name: "Full Simulation",
    persistentState: true,
    conservation: true,
    scheduledEffects: true,
    recursiveEffects: true,
    counterfactuals: true,
    quantumSuperposition: false,
    axisMutations: true
  },
  5: { // 0.97g+ - Quantum superposition
    gLoad: 0.97,
    name: "Quantum Superposition",
    persistentState: true,
    conservation: true,
    scheduledEffects: true,
    recursiveEffects: true,
    counterfactuals: true,
    quantumSuperposition: true,
    axisMutations: true
  }
};

/* ===== CANONICAL SYMBOL REGISTRY ===== */
class CanonicalRegistry {
  constructor() {
    this.surfaceToId = new Map();  // Surface token ‚Üí canonical ID
    this.idToState = new Map();     // Canonical ID ‚Üí current state
    this.idCounter = 0;
    this.sessionHistory = [];       // Track all mappings
    this.synonymGroups = [
      ['DOG', 'HOUND', 'CANINE', 'PUP', 'PUPPY'],
      ['CAT', 'FELINE', 'KITTEN', 'KITTY'],
      ['CIRCLE', 'SPHERE', 'BALL', 'ORB', 'ROUND'],
      ['SQUARE', 'BOX', 'CUBE', 'BLOCK', 'RECTANGLE'],
      ['TRIANGLE', 'PYRAMID', 'WEDGE'],
      ['WAVE', 'RIPPLE', 'SURGE', 'PULSE', 'OSCILLATION'],
      ['PARTICLE', 'QUANTUM', 'PHOTON', 'ELECTRON', 'QUARK'],
      ['ATOM', 'MOLECULE', 'COMPOUND', 'ELEMENT', 'ION'],
      ['ENGINE', 'MOTOR', 'TURBINE', 'GENERATOR'],
      ['TIMER', 'CLOCK', 'COUNTER', 'CHRONOMETER'],
      ['TRIGGER', 'SWITCH', 'BUTTON', 'ACTIVATOR'],
      ['BOMB', 'EXPLOSIVE', 'CHARGE'],
      ['RED', 'CRIMSON', 'SCARLET', 'RUBY', 'CHERRY'],
      ['BLUE', 'AZURE', 'COBALT', 'NAVY', 'SAPPHIRE'],
      ['GREEN', 'EMERALD', 'JADE', 'OLIVE', 'FOREST'],
      ['YELLOW', 'GOLDEN', 'AMBER', 'LEMON'],
      ['STAR', 'SUN', 'STELLAR'],
      ['PLANET', 'WORLD', 'GLOBE'],
      ['CELL', 'ORGANISM', 'MICROBE']
    ];
  }
  
  getOrCreateId(surface) {
    // Check if this surface token already mapped
    if (this.surfaceToId.has(surface)) {
      return this.surfaceToId.get(surface);
    }
    
    // Check for synonyms
    const synonyms = this.findSynonyms(surface);
    for (const syn of synonyms) {
      if (this.surfaceToId.has(syn)) {
        const id = this.surfaceToId.get(syn);
        this.surfaceToId.set(surface, id);
        this.sessionHistory.push({surface, id, type: 'synonym'});
        return id;
      }
    }
    
    // Create new canonical ID
    this.idCounter++;
    const id = `${surface.charAt(0)}${this.idCounter}`;
    this.surfaceToId.set(surface, id);
    this.sessionHistory.push({surface, id, type: 'new'});
    
    // Initialize state vector with all dimensions
    this.idToState.set(id, {
      // Spatial dimensions
      x: 0,
      y: 0,
      z: 0,
      // Physical properties
      energy: 10,
      momentum: { x: 0, y: 0, z: 0 },
      phase: 0,
      frequency: 1,
      // Information properties
      information: 5,
      entropy: 1,
      // Quantum properties (for Level 5)
      superposition: false,
      entangled: null,
      wavefunction: 1.0,
      // Meta properties
      exists: true,
      created_trial: 0,
      last_modified: 0,
      modification_count: 0
    });
    
    return id;
  }
  
  findSynonyms(surface) {
    for (const group of this.synonymGroups) {
      if (group.includes(surface.toUpperCase())) {
        return group;
      }
    }
    return [];
  }
  
  getState(id) {
    return this.idToState.get(id) || null;
  }
  
  setState(id, newState) {
    const oldState = this.getState(id);
    if (oldState) {
      newState.modification_count = (oldState.modification_count || 0) + 1;
    }
    this.idToState.set(id, { ...newState });
  }
  
  cloneState(id) {
    const state = this.getState(id);
    if (!state) return null;
    return {
      ...state,
      momentum: { ...state.momentum }
    };
  }
  
  getMappingSummary() {
    const mappings = [];
    for (const [surface, id] of this.surfaceToId) {
      const state = this.getState(id);
      if (state && state.exists) {
        mappings.push(`${surface}‚Üí${id}`);
      }
    }
    return mappings;
  }
}

/* ===== STATE-VECTOR SIMULATION ENGINE ===== */
class StateVectorEngine {
  constructor(registry, config) {
    this.registry = registry;
    this.config = config;
    this.scheduledEffects = [];  // Effects to apply in future trials
    this.recursiveEffects = [];  // Recurring effects
    this.conservationBaseline = {
      totalEnergy: 100,
      totalMomentum: { x: 0, y: 0, z: 0 },
      totalInformation: 50,
      symbolCount: 0
    };
    this.currentTrial = 0;
    this.proofTrace = [];
    this.axisMutations = [];
  }
  
  parseAndSimulate(premise, currentTrial) {
    this.currentTrial = currentTrial;
    this.proofTrace = [];
    
    const parsed = this.parsePremise(premise);
    if (!parsed) return null;
    
    // Map surface tokens to canonical IDs
    const canonicalParsed = this.canonicalize(parsed);
    
    // Apply any scheduled effects for this trial
    if (this.config.scheduledEffects) {
      this.applyScheduledEffects(currentTrial);
    }
    
    // Apply recursive effects
    if (this.config.recursiveEffects) {
      this.applyRecursiveEffects(currentTrial);
    }
    
    // Apply axis mutations if enabled
    if (this.config.axisMutations && Math.random() < 0.1) {
      this.applyAxisMutation();
    }
    
    // Apply the current operation
    this.applyOperation(canonicalParsed, currentTrial);
    
    // Check conservation if enabled
    let violations = [];
    if (this.config.conservation) {
      violations = this.checkConservation();
    }
    
    // Apply quantum effects if enabled
    if (this.config.quantumSuperposition) {
      this.applyQuantumEffects();
    }
    
    return {
      parsed: canonicalParsed,
      violations: violations,
      stateSnapshot: this.captureStateSnapshot(),
      proofTrace: [...this.proofTrace],
      scheduledCount: this.scheduledEffects.length,
      recursiveCount: this.recursiveEffects.length
    };
  }
  
  parsePremise(text) {
    this.proofTrace.push(`Parsing: "${text}"`);
    
    const words = text.split(' ').filter(w => w.length > 0);
    if (words.length !== 5) return null;
    
    const result = {
      subjects: [],
      operation: null,
      relation: null,
      objects: [],
      modifier: null,
      direction: null
    };
    
    // Enhanced parsing with more patterns
    if (words[1] === 'pushes' || words[1] === 'pulls' || words[1] === 'splits' || 
        words[1] === 'merges' || words[1] === 'triggers' || words[1] === 'activates' ||
        words[1] === 'rotates' || words[1] === 'oscillates' || words[1] === 'transforms' ||
        words[1] === 'collides' || words[1] === 'bounces' || words[1] === 'absorbs' ||
        words[1] === 'emits' || words[1] === 'resonates') {
      
      result.subjects = this.extractSymbols(words[0]);
      result.operation = words[1];
      result.objects = this.extractSymbols(words[2]);
      result.modifier = words[3];
      result.direction = words[4];
    } else if (words[2] === 'forming' || words[2] === 'creating' || words[2] === 'into' ||
               words[2] === 'becoming' || words[2] === 'generating') {
      
      result.subjects = this.extractSymbols(words[0]);
      result.operation = words[1];
      result.relation = words[2];
      result.objects = this.extractSymbols(words[3]);
      result.modifier = words[4];
    } else {
      // Generic pattern
      result.subjects = this.extractSymbols(words[0]);
      result.operation = words[1];
      result.objects = this.extractSymbols(words[2]);
      result.modifier = words[3];
      result.direction = words[4];
    }
    
    this.proofTrace.push(`Parsed: subj=${result.subjects}, op=${result.operation}, obj=${result.objects}`);
    return result;
  }
  
  extractSymbols(word) {
    // Handle compound symbols
    if (word.includes('-AND-')) {
      return word.split('-AND-').map(w => w.replace(/-/g, ''));
    } else if (word.includes('-WITH-')) {
      return word.split('-WITH-').map(w => w.replace(/-/g, ''));
    } else if (word === 'TWO-PARTICLES' || word === 'TWO-FRAGMENTS') {
      return ['PARTICLE1', 'PARTICLE2'];
    } else if (word === 'TWO-ATOMS' || word === 'TWO-MOLECULES') {
      return ['ATOM1', 'ATOM2'];
    } else if (word === 'TWO-ORGANISMS' || word === 'TWO-CELLS') {
      return ['ORGANISM1', 'ORGANISM2'];
    } else if (word.includes('-')) {
      // Handle color-prefixed symbols
      const parts = word.split('-');
      return [parts[parts.length - 1]];
    }
    return [word];
  }
  
  canonicalize(parsed) {
    const canonical = { ...parsed };
    
    // Map all surface symbols to canonical IDs
    canonical.subjectIds = parsed.subjects.map(s => this.registry.getOrCreateId(s));
    canonical.objectIds = parsed.objects.map(o => this.registry.getOrCreateId(o));
    
    // Map operation to canonical operation
    canonical.canonicalOp = this.mapToCanonicalOp(parsed.operation);
    
    this.proofTrace.push(`Canonical: subj=${canonical.subjectIds}, op=${canonical.canonicalOp}, obj=${canonical.objectIds}`);
    
    return canonical;
  }
  
  mapToCanonicalOp(operation) {
    const opMap = {
      'pushes': 'PUSH',
      'pulls': 'PULL',
      'splits': 'SPLIT',
      'merges': 'MERGE',
      'triggers': 'CASCADE',
      'activates': 'CASCADE',
      'rotates': 'ROTATE',
      'oscillates': 'OSCILLATE',
      'transforms': 'TRANSFORM',
      'collides': 'COLLIDE',
      'bounces': 'BOUNCE',
      'absorbs': 'ABSORB',
      'emits': 'EMIT',
      'resonates': 'RESONATE'
    };
    return opMap[operation] || 'UNKNOWN';
  }
  
  applyOperation(canonical, trial) {
    const { subjectIds, objectIds, canonicalOp, modifier } = canonical;
    
    this.proofTrace.push(`Applying ${canonicalOp} at trial ${trial}`);
    
    switch(canonicalOp) {
      case 'PUSH':
        this.applyPush(subjectIds, objectIds);
        break;
      case 'PULL':
        this.applyPull(subjectIds, objectIds);
        break;
      case 'SPLIT':
        this.applySplit(subjectIds, objectIds);
        break;
      case 'MERGE':
        this.applyMerge(subjectIds, objectIds);
        break;
      case 'CASCADE':
        this.applyCascade(subjectIds, objectIds, modifier);
        break;
      case 'ROTATE':
        this.applyRotate(subjectIds);
        break;
      case 'OSCILLATE':
        this.applyOscillate(subjectIds, trial);
        break;
      case 'TRANSFORM':
        this.applyTransform(subjectIds, objectIds);
        break;
      case 'COLLIDE':
        this.applyCollide(subjectIds, objectIds);
        break;
      case 'ABSORB':
        this.applyAbsorb(subjectIds, objectIds);
        break;
      case 'EMIT':
        this.applyEmit(subjectIds, objectIds);
        break;
      case 'RESONATE':
        this.applyResonate(subjectIds, objectIds);
        break;
    }
  }
  
  applyPush(subjectIds, objectIds) {
    // Conservation: momentum transfer
    for (const subjId of subjectIds) {
      const subj = this.registry.getState(subjId);
      if (!subj || !subj.exists) continue;
      
      subj.momentum.x -= 2;
      subj.energy -= 1;
      subj.last_modified = this.currentTrial;
      this.registry.setState(subjId, subj);
      
      this.proofTrace.push(`${subjId}: Œîp_x=-2, ŒîE=-1`);
    }
    
    for (const objId of objectIds) {
      const obj = this.registry.getState(objId);
      if (!obj || !obj.exists) continue;
      
      obj.momentum.x += 2;
      obj.energy += 1;
      obj.x += 2;
      obj.last_modified = this.currentTrial;
      this.registry.setState(objId, obj);
      
      this.proofTrace.push(`${objId}: Œîp_x=+2, ŒîE=+1, Œîx=+2`);
    }
  }
  
  applyPull(subjectIds, objectIds) {
    for (const subjId of subjectIds) {
      const subj = this.registry.getState(subjId);
      if (!subj || !subj.exists) continue;
      
      subj.momentum.x += 2;
      subj.energy -= 1;
      subj.last_modified = this.currentTrial;
      this.registry.setState(subjId, subj);
      
      this.proofTrace.push(`${subjId}: Œîp_x=+2, ŒîE=-1`);
    }
    
    for (const objId of objectIds) {
      const obj = this.registry.getState(objId);
      if (!obj || !obj.exists) continue;
      
      obj.momentum.x -= 2;
      obj.energy += 1;
      obj.x -= 2;
      obj.last_modified = this.currentTrial;
      this.registry.setState(objId, obj);
      
      this.proofTrace.push(`${objId}: Œîp_x=-2, ŒîE=+1, Œîx=-2`);
    }
  }
  
  applySplit(subjectIds, objectIds) {
    if (subjectIds.length !== 1 || objectIds.length < 2) {
      this.proofTrace.push(`Split requires 1 subject ‚Üí 2+ objects`);
      return;
    }
    
    const subjId = subjectIds[0];
    const subj = this.registry.getState(subjId);
    if (!subj || !subj.exists) return;
    
    const totalEnergy = subj.energy;
    const totalInfo = subj.information;
    const energyPerObject = totalEnergy / objectIds.length;
    const infoPerObject = totalInfo * 2; // Information increases in split
    
    this.proofTrace.push(`${subjId} splits: E=${totalEnergy} ‚Üí ${objectIds.length} parts`);
    
    // Mark subject as consumed
    subj.exists = false;
    subj.last_modified = this.currentTrial;
    this.registry.setState(subjId, subj);
    
    // Create/update objects with split energy
    for (const objId of objectIds) {
      let obj = this.registry.getState(objId);
      if (!obj) {
        obj = {
          x: subj.x,
          y: subj.y,
          z: subj.z,
          energy: energyPerObject,
          momentum: { 
            x: subj.momentum.x / objectIds.length, 
            y: subj.momentum.y / objectIds.length,
            z: subj.momentum.z / objectIds.length 
          },
          phase: subj.phase,
          frequency: subj.frequency,
          information: infoPerObject,
          entropy: subj.entropy + 1,
          superposition: false,
          entangled: null,
          wavefunction: 1.0,
          exists: true,
          created_trial: this.currentTrial,
          last_modified: this.currentTrial,
          modification_count: 0
        };
      } else {
        obj.energy = energyPerObject;
        obj.information = infoPerObject;
        obj.entropy += 1;
        obj.exists = true;
        obj.last_modified = this.currentTrial;
      }
      this.registry.setState(objId, obj);
      
      this.proofTrace.push(`${objId} created: E=${energyPerObject}, I=${infoPerObject}`);
    }
  }
  
  applyMerge(subjectIds, objectIds) {
    if (subjectIds.length < 2 || objectIds.length !== 1) {
      this.proofTrace.push(`Merge requires 2+ subjects ‚Üí 1 object`);
      return;
    }
    
    const objId = objectIds[0];
    let totalEnergy = 0;
    let totalMomentum = { x: 0, y: 0, z: 0 };
    let totalInformation = 0;
    
    this.proofTrace.push(`Merging ${subjectIds.join(',')} ‚Üí ${objId}`);
    
    // Sum energy and momentum from subjects
    for (const subjId of subjectIds) {
      const subj = this.registry.getState(subjId);
      if (!subj || !subj.exists) continue;
      
      totalEnergy += subj.energy;
      totalMomentum.x += subj.momentum.x;
      totalMomentum.y += subj.momentum.y;
      totalMomentum.z += subj.momentum.z;
      totalInformation += subj.information;
      
      // Mark subject as consumed
      subj.exists = false;
      subj.last_modified = this.currentTrial;
      this.registry.setState(subjId, subj);
      
      this.proofTrace.push(`${subjId} consumed: E=${subj.energy}`);
    }
    
    // Create/update merged object
    let obj = this.registry.getState(objId);
    if (!obj) {
      obj = {
        x: 0, y: 0, z: 0,
        energy: totalEnergy,
        momentum: totalMomentum,
        phase: 0,
        frequency: 1,
        information: totalInformation / 2, // Information decreases in merge
        entropy: 0.5,
        superposition: false,
        entangled: null,
        wavefunction: 1.0,
        exists: true,
        created_trial: this.currentTrial,
        last_modified: this.currentTrial,
        modification_count: 0
      };
    } else {
      obj.energy = totalEnergy;
      obj.momentum = totalMomentum;
      obj.information = totalInformation / 2;
      obj.exists = true;
      obj.last_modified = this.currentTrial;
    }
    this.registry.setState(objId, obj);
    
    this.proofTrace.push(`${objId} created: E=${totalEnergy}, I=${totalInformation/2}`);
  }
  
  applyCascade(subjectIds, objectIds, modifier) {
    // Parse delay from modifier if present
    let delay = 0;
    if (modifier === 'delayed' || modifier === 'later') {
      delay = 2;
    } else if (modifier === 'immediately' || modifier === 'now') {
      delay = 0;
    } else if (modifier === 'recursively' || modifier === 'repeating') {
      // Add recursive effect
      if (this.config.recursiveEffects) {
        this.recursiveEffects.push({
          subjects: subjectIds,
          objects: objectIds,
          operation: 'CASCADE',
          period: 2,
          startTrial: this.currentTrial + 1
        });
        this.proofTrace.push(`Recursive cascade scheduled every 2 trials`);
      }
      return;
    }
    
    if (delay > 0 && this.config.scheduledEffects) {
      this.scheduledEffects.push({
        trial: this.currentTrial + delay,
        operation: 'CASCADE',
        subjects: subjectIds,
        objects: objectIds
      });
      this.proofTrace.push(`Cascade scheduled for t+${delay}`);
      return;
    }
    
    // Apply immediate cascade
    this.proofTrace.push(`Immediate cascade`);
    
    for (const subjId of subjectIds) {
      const subj = this.registry.getState(subjId);
      if (!subj || !subj.exists) continue;
      
      subj.energy -= 2;
      subj.last_modified = this.currentTrial;
      this.registry.setState(subjId, subj);
      
      this.proofTrace.push(`${subjId}: ŒîE=-2`);
    }
    
    for (const objId of objectIds) {
      const obj = this.registry.getState(objId);
      if (!obj || !obj.exists) continue;
      
      obj.energy += 2;
      obj.phase = (obj.phase + Math.PI/4) % (2 * Math.PI);
      obj.last_modified = this.currentTrial;
      this.registry.setState(objId, obj);
      
      this.proofTrace.push(`${objId}: ŒîE=+2, ŒîœÜ=+œÄ/4`);
    }
  }
  
  applyRotate(subjectIds) {
    for (const subjId of subjectIds) {
      const subj = this.registry.getState(subjId);
      if (!subj || !subj.exists) continue;
      
      // Rotation swaps momentum components
      const temp = subj.momentum.x;
      subj.momentum.x = subj.momentum.y;
      subj.momentum.y = subj.momentum.z;
      subj.momentum.z = temp;
      
      subj.phase = (subj.phase + Math.PI/2) % (2 * Math.PI);
      subj.last_modified = this.currentTrial;
      this.registry.setState(subjId, subj);
      
      this.proofTrace.push(`${subjId}: momentum rotated, ŒîœÜ=+œÄ/2`);
    }
  }
  
  applyOscillate(subjectIds, trial) {
    for (const subjId of subjectIds) {
      const subj = this.registry.getState(subjId);
      if (!subj || !subj.exists) continue;
      
      // Oscillation based on trial number
      subj.x = 3 * Math.sin(trial * Math.PI / 4);
      subj.y = 3 * Math.cos(trial * Math.PI / 4);
      subj.phase = (trial * Math.PI / 4) % (2 * Math.PI);
      subj.frequency *= 1.1;
      subj.last_modified = this.currentTrial;
      this.registry.setState(subjId, subj);
      
      this.proofTrace.push(`${subjId}: oscillating at œÜ=${subj.phase.toFixed(2)}`);
    }
  }
  
  applyTransform(subjectIds, objectIds) {
    // Transform changes type while preserving conservation
    if (subjectIds.length !== objectIds.length) return;
    
    for (let i = 0; i < subjectIds.length; i++) {
      const subj = this.registry.getState(subjectIds[i]);
      const obj = this.registry.getState(objectIds[i]);
      
      if (!subj || !subj.exists) continue;
      
      // Transfer state from subject to object
      if (!obj) {
        const newObj = { ...subj };
        newObj.phase = (newObj.phase + Math.PI) % (2 * Math.PI);
        newObj.created_trial = this.currentTrial;
        newObj.last_modified = this.currentTrial;
        this.registry.setState(objectIds[i], newObj);
      } else {
        obj.energy = subj.energy;
        obj.momentum = { ...subj.momentum };
        obj.information = subj.information;
        obj.phase = (subj.phase + Math.PI) % (2 * Math.PI);
        obj.exists = true;
        obj.last_modified = this.currentTrial;
        this.registry.setState(objectIds[i], obj);
      }
      
      // Mark subject as transformed
      subj.exists = false;
      subj.last_modified = this.currentTrial;
      this.registry.setState(subjectIds[i], subj);
      
      this.proofTrace.push(`${subjectIds[i]} ‚Üí ${objectIds[i]} transformed`);
    }
  }
  
  applyCollide(subjectIds, objectIds) {
    // Elastic collision with momentum exchange
    if (subjectIds.length === 0 || objectIds.length === 0) return;
    
    for (const subjId of subjectIds) {
      const subj = this.registry.getState(subjId);
      if (!subj || !subj.exists) continue;
      
      for (const objId of objectIds) {
        const obj = this.registry.getState(objId);
        if (!obj || !obj.exists) continue;
        
        // Exchange momentum components
        const tempX = subj.momentum.x;
        subj.momentum.x = obj.momentum.x;
        obj.momentum.x = tempX;
        
        // Energy redistribution
        const totalEnergy = subj.energy + obj.energy;
        subj.energy = totalEnergy * 0.4;
        obj.energy = totalEnergy * 0.6;
        
        subj.last_modified = this.currentTrial;
        obj.last_modified = this.currentTrial;
        
        this.registry.setState(subjId, subj);
        this.registry.setState(objId, obj);
        
        this.proofTrace.push(`${subjId}‚Üî${objId} collision`);
      }
    }
  }
  
  applyAbsorb(subjectIds, objectIds) {
    // Subject absorbs energy from objects
    if (subjectIds.length !== 1 || objectIds.length === 0) return;
    
    const subjId = subjectIds[0];
    const subj = this.registry.getState(subjId);
    if (!subj || !subj.exists) return;
    
    let absorbedEnergy = 0;
    
    for (const objId of objectIds) {
      const obj = this.registry.getState(objId);
      if (!obj || !obj.exists) continue;
      
      absorbedEnergy += obj.energy * 0.5;
      obj.energy *= 0.5;
      obj.last_modified = this.currentTrial;
      this.registry.setState(objId, obj);
      
      this.proofTrace.push(`${objId}: E halved`);
    }
    
    subj.energy += absorbedEnergy;
    subj.information += absorbedEnergy * 0.1;
    subj.last_modified = this.currentTrial;
    this.registry.setState(subjId, subj);
    
    this.proofTrace.push(`${subjId} absorbed E=${absorbedEnergy.toFixed(1)}`);
  }
  
  applyEmit(subjectIds, objectIds) {
    // Subject emits energy to create objects
    if (subjectIds.length !== 1) return;
    
    const subjId = subjectIds[0];
    const subj = this.registry.getState(subjId);
    if (!subj || !subj.exists || subj.energy < objectIds.length) return;
    
    const emittedEnergy = subj.energy * 0.3;
    const energyPerObject = emittedEnergy / objectIds.length;
    
    subj.energy -= emittedEnergy;
    subj.last_modified = this.currentTrial;
    this.registry.setState(subjId, subj);
    
    this.proofTrace.push(`${subjId} emits E=${emittedEnergy.toFixed(1)}`);
    
    for (const objId of objectIds) {
      let obj = this.registry.getState(objId);
      if (!obj) {
        obj = {
          x: subj.x + Math.random() * 2 - 1,
          y: subj.y + Math.random() * 2 - 1,
          z: subj.z,
          energy: energyPerObject,
          momentum: { x: 1, y: 0, z: 0 },
          phase: Math.random() * 2 * Math.PI,
          frequency: 2,
          information: 2,
          entropy: 2,
          superposition: false,
          entangled: null,
          wavefunction: 1.0,
          exists: true,
          created_trial: this.currentTrial,
          last_modified: this.currentTrial,
          modification_count: 0
        };
      } else {
        obj.energy += energyPerObject;
        obj.exists = true;
        obj.last_modified = this.currentTrial;
      }
      this.registry.setState(objId, obj);
      
      this.proofTrace.push(`${objId} emitted with E=${energyPerObject.toFixed(1)}`);
    }
  }
  
  applyResonate(subjectIds, objectIds) {
    // Resonance creates standing wave pattern
    for (const subjId of subjectIds) {
      const subj = this.registry.getState(subjId);
      if (!subj || !subj.exists) continue;
      
      for (const objId of objectIds) {
        const obj = this.registry.getState(objId);
        if (!obj || !obj.exists) continue;
        
        // Synchronize frequencies
        const avgFreq = (subj.frequency + obj.frequency) / 2;
        subj.frequency = avgFreq;
        obj.frequency = avgFreq;
        
        // Phase coupling
        obj.phase = subj.phase;
        
        // Energy oscillation
        const totalEnergy = subj.energy + obj.energy;
        const oscillation = Math.sin(this.currentTrial * Math.PI / 3);
        subj.energy = totalEnergy * (0.5 + 0.2 * oscillation);
        obj.energy = totalEnergy * (0.5 - 0.2 * oscillation);
        
        subj.last_modified = this.currentTrial;
        obj.last_modified = this.currentTrial;
        
        this.registry.setState(subjId, subj);
        this.registry.setState(objId, obj);
        
        this.proofTrace.push(`${subjId}~${objId} resonating at f=${avgFreq.toFixed(1)}`);
      }
    }
  }
  
  applyScheduledEffects(currentTrial) {
    const toApply = this.scheduledEffects.filter(e => e.trial === currentTrial);
    
    for (const effect of toApply) {
      this.proofTrace.push(`Executing scheduled ${effect.operation}`);
      
      switch(effect.operation) {
        case 'CASCADE':
          this.applyCascade(effect.subjects, effect.objects, 'immediately');
          break;
        case 'EXPLODE':
          this.applyExplosion(effect.subjects);
          break;
      }
    }
    
    // Remove applied effects
    this.scheduledEffects = this.scheduledEffects.filter(e => e.trial !== currentTrial);
  }
  
  applyRecursiveEffects(currentTrial) {
    for (const effect of this.recursiveEffects) {
      if ((currentTrial - effect.startTrial) % effect.period === 0 && 
          currentTrial >= effect.startTrial) {
        this.proofTrace.push(`Executing recursive ${effect.operation}`);
        
        switch(effect.operation) {
          case 'CASCADE':
            this.applyCascade(effect.subjects, effect.objects, 'immediately');
            break;
          case 'OSCILLATE':
            this.applyOscillate(effect.subjects, currentTrial);
            break;
        }
      }
    }
  }
  
  applyAxisMutation() {
    // Randomly swap axis mappings
    const mutations = ['xy', 'xz', 'yz'];
    const mutation = mutations[Math.floor(Math.random() * mutations.length)];
    
    this.axisMutations.push({trial: this.currentTrial, mutation});
    this.proofTrace.push(`Axis mutation: ${mutation} swap`);
    
    for (const [id, state] of this.registry.idToState) {
      if (!state.exists) continue;
      
      if (mutation === 'xy') {
        [state.x, state.y] = [state.y, state.x];
        [state.momentum.x, state.momentum.y] = [state.momentum.y, state.momentum.x];
      } else if (mutation === 'xz') {
        [state.x, state.z] = [state.z, state.x];
        [state.momentum.x, state.momentum.z] = [state.momentum.z, state.momentum.x];
      } else if (mutation === 'yz') {
        [state.y, state.z] = [state.z, state.y];
        [state.momentum.y, state.momentum.z] = [state.momentum.z, state.momentum.y];
      }
      
      this.registry.setState(id, state);
    }
  }
  
  applyQuantumEffects() {
    // Apply quantum superposition and entanglement
    const activeIds = [];
    for (const [id, state] of this.registry.idToState) {
      if (state.exists) activeIds.push(id);
    }
    
    // Random superposition
    if (Math.random() < 0.1 && activeIds.length > 0) {
      const id = activeIds[Math.floor(Math.random() * activeIds.length)];
      const state = this.registry.getState(id);
      state.superposition = true;
      state.wavefunction = Math.random();
      this.registry.setState(id, state);
      this.proofTrace.push(`${id} in superposition œà=${state.wavefunction.toFixed(2)}`);
    }
    
    // Random entanglement
    if (Math.random() < 0.05 && activeIds.length >= 2) {
      const id1 = activeIds[Math.floor(Math.random() * activeIds.length)];
      const id2 = activeIds[Math.floor(Math.random() * activeIds.length)];
      if (id1 !== id2) {
        const state1 = this.registry.getState(id1);
        const state2 = this.registry.getState(id2);
        state1.entangled = id2;
        state2.entangled = id1;
        this.registry.setState(id1, state1);
        this.registry.setState(id2, state2);
        this.proofTrace.push(`${id1}‚äó${id2} entangled`);
      }
    }
  }
  
  applyExplosion(subjectIds) {
    for (const subjId of subjectIds) {
      const subj = this.registry.getState(subjId);
      if (!subj || !subj.exists) continue;
      
      // Explosion releases all energy
      subj.energy = 0;
      subj.exists = false;
      subj.last_modified = this.currentTrial;
      this.registry.setState(subjId, subj);
      
      this.proofTrace.push(`${subjId} exploded!`);
    }
  }
  
  checkConservation() {
    const violations = [];
    
    // Calculate current totals
    let totalEnergy = 0;
    let totalMomentum = { x: 0, y: 0, z: 0 };
    let totalInformation = 0;
    let activeSymbols = 0;
    
    for (const [id, state] of this.registry.idToState) {
      if (state.exists) {
        totalEnergy += state.energy;
        totalMomentum.x += state.momentum.x;
        totalMomentum.y += state.momentum.y;
        totalMomentum.z += state.momentum.z;
        totalInformation += state.information;
        activeSymbols++;
      }
    }
    
    // Check conservation violations (with tolerance)
    const tolerance = 0.1;
    
    if (Math.abs(totalMomentum.x) > tolerance || 
        Math.abs(totalMomentum.y) > tolerance ||
        Math.abs(totalMomentum.z) > tolerance) {
      violations.push('momentum');
      this.proofTrace.push(`Momentum violation: (${totalMomentum.x.toFixed(1)},${totalMomentum.y.toFixed(1)},${totalMomentum.z.toFixed(1)})`);
    }
    
    // Information should generally not decrease
    if (totalInformation < this.conservationBaseline.totalInformation * 0.9) {
      violations.push('information');
      this.proofTrace.push(`Information decreased: ${totalInformation.toFixed(1)} < ${this.conservationBaseline.totalInformation * 0.9}`);
    }
    
    return violations;
  }
  
  captureStateSnapshot() {
    const snapshot = {};
    
    for (const [id, state] of this.registry.idToState) {
      if (state.exists) {
        snapshot[id] = { ...state, momentum: { ...state.momentum } };
      }
    }
    
    return snapshot;
  }
  
  compareStates(state1, state2, withCounterfactuals = false) {
    // Deep comparison of state vectors
    const tolerance = 0.01;
    const confidence = { value: 0, trace: [] };
    
    const keys1 = Object.keys(state1).sort();
    const keys2 = Object.keys(state2).sort();
    
    if (keys1.length !== keys2.length) {
      confidence.trace.push(`Symbol count mismatch: ${keys1.length} vs ${keys2.length}`);
      return { match: false, confidence: 0 };
    }
    
    let matchScore = 1.0;
    
    for (let i = 0; i < keys1.length; i++) {
      if (keys1[i] !== keys2[i]) {
        confidence.trace.push(`ID mismatch: ${keys1[i]} vs ${keys2[i]}`);
        return { match: false, confidence: 0 };
      }
      
      const s1 = state1[keys1[i]];
      const s2 = state2[keys2[i]];
      
      // Check each dimension
      const checks = [
        { dim: 'x', weight: 0.15 },
        { dim: 'y', weight: 0.15 },
        { dim: 'z', weight: 0.1 },
        { dim: 'energy', weight: 0.2 },
        { dim: 'phase', weight: 0.1 },
        { dim: 'information', weight: 0.1 }
      ];
      
      for (const check of checks) {
        const diff = Math.abs(s1[check.dim] - s2[check.dim]);
        if (diff > tolerance) {
          matchScore -= check.weight * (diff / 10);
          confidence.trace.push(`${keys1[i]}.${check.dim}: ${s1[check.dim].toFixed(2)} vs ${s2[check.dim].toFixed(2)}`);
        }
      }
      
      // Check momentum
      const momDiff = Math.sqrt(
        Math.pow(s1.momentum.x - s2.momentum.x, 2) +
        Math.pow(s1.momentum.y - s2.momentum.y, 2) +
        Math.pow(s1.momentum.z - s2.momentum.z, 2)
      );
      
      if (momDiff > tolerance) {
        matchScore -= 0.2 * (momDiff / 10);
        confidence.trace.push(`${keys1[i]}.momentum: divergent by ${momDiff.toFixed(2)}`);
      }
    }
    
    // Apply counterfactual testing if enabled
    if (withCounterfactuals && this.config.counterfactuals) {
      matchScore *= this.testCounterfactuals(state1, state2);
    }
    
    confidence.value = Math.max(0, Math.min(1, matchScore));
    
    return { 
      match: confidence.value >= 0.90, 
      confidence: confidence.value,
      trace: confidence.trace
    };
  }
  
  testCounterfactuals(state1, state2) {
    // Test robustness against alternative interpretations
    let robustness = 1.0;
    
    // Counterfactual 1: What if energy was distributed differently?
    const energyVariance = this.calculateEnergyVariance(state1, state2);
    if (energyVariance > 0.2) {
      robustness *= 0.8;
      this.proofTrace.push(`Counterfactual: Energy distribution fragile`);
    }
    
    // Counterfactual 2: What if momentum was inverted?
    const momentumSymmetry = this.checkMomentumSymmetry(state1, state2);
    if (!momentumSymmetry) {
      robustness *= 0.9;
      this.proofTrace.push(`Counterfactual: Momentum asymmetric`);
    }
    
    // Counterfactual 3: What if phase was shifted?
    const phaseInvariance = this.checkPhaseInvariance(state1, state2);
    if (!phaseInvariance) {
      robustness *= 0.95;
      this.proofTrace.push(`Counterfactual: Phase-dependent`);
    }
    
    return robustness;
  }
  
  calculateEnergyVariance(state1, state2) {
    const energies1 = Object.values(state1).map(s => s.energy);
    const energies2 = Object.values(state2).map(s => s.energy);
    
    const mean1 = energies1.reduce((a,b) => a+b, 0) / energies1.length;
    const mean2 = energies2.reduce((a,b) => a+b, 0) / energies2.length;
    
    const variance1 = energies1.reduce((a,b) => a + Math.pow(b-mean1, 2), 0) / energies1.length;
    const variance2 = energies2.reduce((a,b) => a + Math.pow(b-mean2, 2), 0) / energies2.length;
    
    return Math.abs(variance1 - variance2) / Math.max(variance1, variance2, 1);
  }
  
  checkMomentumSymmetry(state1, state2) {
    for (const id in state1) {
      if (state2[id]) {
        const mom1 = state1[id].momentum;
        const mom2 = state2[id].momentum;
        const dot = mom1.x*mom2.x + mom1.y*mom2.y + mom1.z*mom2.z;
        const mag1 = Math.sqrt(mom1.x*mom1.x + mom1.y*mom1.y + mom1.z*mom1.z);
        const mag2 = Math.sqrt(mom2.x*mom2.x + mom2.y*mom2.y + mom2.z*mom2.z);
        
        if (mag1 > 0.1 && mag2 > 0.1) {
          const cosAngle = dot / (mag1 * mag2);
          if (Math.abs(cosAngle) < 0.9) return false;
        }
      }
    }
    return true;
  }
  
  checkPhaseInvariance(state1, state2) {
    for (const id in state1) {
      if (state2[id]) {
        const phaseDiff = Math.abs(state1[id].phase - state2[id].phase);
        const normalizedDiff = phaseDiff % (2 * Math.PI);
        if (normalizedDiff > 0.1 && normalizedDiff < (2 * Math.PI - 0.1)) {
          return false;
        }
      }
    }
    return true;
  }
}

/* ===== PREMISE GENERATOR ===== */
class CanonicalPremiseGenerator {
  constructor(config) {
    this.config = config;
    
    this.symbols = {
      primary: ['DOG', 'CAT', 'CIRCLE', 'SQUARE', 'TRIANGLE', 'ATOM', 'WAVE', 'PARTICLE', 
                'STAR', 'PLANET', 'CELL', 'ENGINE', 'TIMER', 'CRYSTAL'],
      secondary: ['HOUND', 'FELINE', 'SPHERE', 'BOX', 'PYRAMID', 'MOLECULE', 'RIPPLE', 
                  'QUANTUM', 'SUN', 'WORLD', 'ORGANISM', 'MOTOR', 'CLOCK', 'PRISM'],
      colors: ['RED', 'BLUE', 'GREEN', 'YELLOW', 'PURPLE', 'ORANGE'],
      numbers: ['ONE', 'TWO', 'THREE', 'FOUR']
    };
    
    this.operations = ['pushes', 'pulls', 'splits', 'merges', 'triggers', 'activates', 
                       'rotates', 'transforms', 'collides', 'bounces', 'absorbs', 'emits',
                       'oscillates', 'resonates'];
    
    this.modifiers = ['forming', 'creating', 'into', 'toward', 'with', 'becoming', 
                      'generating', 'producing', 'releasing'];
    
    this.directions = ['upward', 'downward', 'leftward', 'rightward', 'forward', 
                       'backward', 'quickly', 'slowly', 'strongly', 'weakly', 
                       'immediately', 'gradually', 'recursively', 'periodically'];
    
    this.usedPremises = new Set();
    this.premiseHistory = [];
  }
  
  generate(shouldMatch = false, referenceIndex = null, registry = null) {
    let premise;
    
    if (shouldMatch && referenceIndex !== null && registry) {
      premise = this.generateMatching(referenceIndex, registry);
    } else {
      premise = this.generateNew();
    }
    
    // Avoid exact duplicates
    let attempts = 0;
    while (this.usedPremises.has(premise) && attempts < 50) {
      premise = shouldMatch ? 
        this.generateMatching(referenceIndex, registry) : 
        this.generateNew();
      attempts++;
    }
    
    this.usedPremises.add(premise);
    this.premiseHistory.push(premise);
    
    // Keep history size manageable
    if (this.usedPremises.size > 100) {
      const premises = Array.from(this.usedPremises);
      this.usedPremises = new Set(premises.slice(-50));
    }
    
    return premise;
  }
  
  generateNew() {
    const pattern = Math.floor(Math.random() * 6);
    
    switch(pattern) {
      case 0: return this.patternSimple();
      case 1: return this.patternSplit();
      case 2: return this.patternMerge();
      case 3: return this.patternColor();
      case 4: return this.patternCascade();
      case 5: return this.patternComplex();
      default: return this.patternSimple();
    }
  }
  
  patternSimple() {
    // SUBJECT VERB OBJECT MODIFIER DIRECTION
    const subject = this.randomFrom(this.symbols.primary);
    const verb = this.randomFrom(['pushes', 'pulls', 'rotates', 'transforms']);
    const object = this.randomFrom(this.symbols.primary);
    const modifier = this.randomFrom(['moving', 'flowing', 'spinning', 'turning']);
    const direction = this.randomFrom(this.directions);
    
    return `${subject} ${verb} ${object} ${modifier} ${direction}`;
  }
  
  patternSplit() {
    // SUBJECT splits forming OBJECTS modifier
    const subject = this.randomFrom(this.symbols.primary);
    const objects = this.randomFrom(['TWO-PARTICLES', 'TWO-ATOMS', 'TWO-FRAGMENTS']);
    const modifier = this.randomFrom(['equally', 'rapidly', 'completely', 'symmetrically']);
    
    return `${subject} splits forming ${objects} ${modifier}`;
  }
  
  patternMerge() {
    // SUBJECT-AND-SUBJECT2 merge creating OBJECT modifier
    const subj1 = this.randomFrom(this.symbols.primary);
    const subj2 = this.randomFrom(this.symbols.primary);
    const object = this.randomFrom(this.symbols.primary);
    const modifier = this.randomFrom(['instantly', 'gradually', 'completely', 'perfectly']);
    
    return `${subj1}-AND-${subj2} merges creating ${object} ${modifier}`;
  }
  
  patternColor() {
    // COLOR-SUBJECT verb OBJECT modifier direction
    const color = this.randomFrom(this.symbols.colors);
    const subject = this.randomFrom(this.symbols.primary);
    const verb = this.randomFrom(this.operations);
    const object = this.randomFrom(this.symbols.primary);
    const direction = this.randomFrom(this.directions);
    
    return `${color}-${subject} ${verb} ${object} while ${direction}`;
  }
  
  patternCascade() {
    // SUBJECT triggers/activates OBJECT modifier timing
    const subject = this.randomFrom(this.symbols.primary);
    const verb = this.randomFrom(['triggers', 'activates']);
    const object = this.randomFrom(this.symbols.primary);
    const modifier = this.randomFrom(['causing', 'initiating', 'starting']);
    const timing = this.randomFrom(['immediately', 'delayed', 'recursively', 'periodically']);
    
    return `${subject} ${verb} ${object} ${modifier} ${timing}`;
  }
  
  patternComplex() {
    // SUBJECT verb-modifier OBJECT direction
    const subject = this.randomFrom(this.symbols.primary);
    const verb = this.randomFrom(this.operations);
    const object = this.randomFrom(this.symbols.primary);
    const modifier = this.randomFrom(['while', 'when', 'as', 'by']);
    const action = this.randomFrom(['oscillating', 'rotating', 'transforming', 'resonating']);
    
    return `${subject} ${verb} ${object} ${modifier} ${action}`;
  }
  
  generateMatching(referenceIndex, registry) {
    const reference = this.premiseHistory[referenceIndex];
    if (!reference) return this.generateNew();
    
    // Parse reference to get canonical structure
    const words = reference.split(' ');
    const newWords = [];
    
    for (let i = 0; i < words.length; i++) {
      const word = words[i];
      
      // Check for compound words
      if (word.includes('-AND-') || word.includes('-WITH-')) {
        const parts = word.split(/-AND-|-WITH-/);
        const connector = word.includes('-AND-') ? '-AND-' : '-WITH-';
        const newParts = [];
        
        for (const part of parts) {
          if (registry.surfaceToId.has(part)) {
            const id = registry.surfaceToId.get(part);
            const synonyms = registry.findSynonyms(part);
            const validSynonyms = synonyms.filter(s => 
              !registry.surfaceToId.has(s) || registry.surfaceToId.get(s) === id
            );
            
            if (validSynonyms.length > 0 && Math.random() > 0.3) {
              const newWord = this.randomFrom(validSynonyms);
              registry.surfaceToId.set(newWord, id);
              newParts.push(newWord);
            } else {
              newParts.push(part);
            }
          } else {
            newParts.push(part);
          }
        }
        
        newWords.push(newParts.join(connector));
      } else if (registry.surfaceToId.has(word)) {
        // Find a synonym that maps to same ID
        const id = registry.surfaceToId.get(word);
        const synonyms = registry.findSynonyms(word);
        const validSynonyms = synonyms.filter(s => 
          !registry.surfaceToId.has(s) || registry.surfaceToId.get(s) === id
        );
        
        if (validSynonyms.length > 0 && Math.random() > 0.3) {
          const newWord = this.randomFrom(validSynonyms);
          registry.surfaceToId.set(newWord, id);
          newWords.push(newWord);
        } else {
          newWords.push(word);
        }
      } else if (this.operations.includes(word)) {
        // Keep same operation for true match
        newWords.push(word);
      } else {
        // Vary other words moderately
        if (this.directions.includes(word) && Math.random() > 0.7) {
          newWords.push(this.randomFrom(this.directions));
        } else if (this.modifiers.includes(word) && Math.random() > 0.7) {
          newWords.push(this.randomFrom(this.modifiers));
        } else {
          newWords.push(word);
        }
      }
    }
    
    return newWords.join(' ');
  }
  
  randomFrom(array) {
    return array[Math.floor(Math.random() * array.length)];
  }
}

/* ===== GAME CONTROLLER ===== */
class CanonicalStateVectorNBack {
  constructor() {
    this.config = DIFFICULTY_CONFIGS[2]; // Default to Level 2
    this.registry = new CanonicalRegistry();
    this.engine = new StateVectorEngine(this.registry, this.config);
    this.generator = new CanonicalPremiseGenerator(this.config);
    
    this.history = [];
    this.stateHistory = [];
    this.schedule = [];
    
    // Settings
    this.difficultyLevel = 2;
    this.nLevel = 2;
    this.totalTrials = 50;
    this.matchProbability = 0.3;
    this.responseWindow = 8000;
    this.statementsPerTrial = 1;
    this.voiceEnabled = true;
    this.showProofTraces = true;
    this.useCounterfactuals = false;
    
    // State
    this.currentTrial = 0;
    this.isRunning = false;
    this.isPaused = false;
    this.awaitingResponse = false;
    this.responseTimer = null;
    this.countdownInterval = null;
    
    // Scoring
    this.correctHits = 0;
    this.falseAlarms = 0;
    this.misses = 0;
    this.responseTimes = [];
    this.confidenceScores = [];
    
    // Timing
    this.trialStartTime = 0;
  }
  
  initialize(settings) {
    this.difficultyLevel = settings.difficultyLevel;
    this.config = DIFFICULTY_CONFIGS[this.difficultyLevel];
    this.nLevel = settings.nLevel;
    this.totalTrials = settings.totalTrials;
    this.matchProbability = settings.matchProbability;
    this.responseWindow = settings.responseWindow;
    this.statementsPerTrial = settings.statementsPerTrial;
    this.voiceEnabled = settings.voiceEnabled;
    this.showProofTraces = settings.showProofTraces;
    this.useCounterfactuals = settings.useCounterfactuals;
    
    // Update config for counterfactuals
    if (this.useCounterfactuals) {
      this.config.counterfactuals = true;
    }
    
    this.reset();
    this.generateSchedule();
  }
  
  reset() {
    this.registry = new CanonicalRegistry();
    this.engine = new StateVectorEngine(this.registry, this.config);
    this.generator = new CanonicalPremiseGenerator(this.config);
    
    this.history = [];
    this.stateHistory = [];
    this.schedule = [];
    this.currentTrial = 0;
    this.correctHits = 0;
    this.falseAlarms = 0;
    this.misses = 0;
    this.responseTimes = [];
    this.confidenceScores = [];
    this.awaitingResponse = false;
  }
  
  generateSchedule() {
    this.schedule = new Array(this.totalTrials).fill(false);
    
    for (let i = this.nLevel; i < this.totalTrials; i++) {
      if (Math.random() < this.matchProbability) {
        this.schedule[i] = true;
      }
    }
  }
  
  async runTrial() {
    if (!this.isRunning || this.isPaused) return;
    
    this.awaitingResponse = true;
    const shouldMatch = this.schedule[this.currentTrial];
    
    const premises = [];
    const states = [];
    
    for (let i = 0; i < this.statementsPerTrial; i++) {
      let premise;
      
      if (shouldMatch && this.currentTrial >= this.nLevel) {
        const referenceIndex = this.currentTrial - this.nLevel;
        premise = this.generator.generate(true, referenceIndex, this.registry);
      } else {
        premise = this.generator.generate(false);
      }
      
      premises.push(premise);
      
      // Simulate and capture state
      const result = this.engine.parseAndSimulate(premise, this.currentTrial);
      states.push(result);
    }
    
    this.history[this.currentTrial] = premises;
    this.stateHistory[this.currentTrial] = states;
    
    // Display premise and state
    this.displayPremise(premises);
    this.updateStateTracker();
    this.updateConservationDisplay();
    this.updateScheduledEffects();
    this.updateCanonicalMappings();
    
    // Start response timer
    this.trialStartTime = Date.now();
    this.startResponseTimer();
    
    // Voice synthesis
    if (this.voiceEnabled) {
      await this.speak(premises.join('. '));
    }
  }
  
  displayPremise(premises) {
    const display = $('premiseDisplay');
    display.innerHTML = '';
    
    premises.forEach(premise => {
      const div = document.createElement('div');
      div.className = 'premise-text';
      
      const words = premise.split(' ');
      words.forEach((word, idx) => {
        const span = document.createElement('span');
        
        // Enhanced styling based on word type and context
        if (word.includes('-AND-') || word.includes('-WITH-')) {
          span.className = 'compound';
        } else if (this.engine.scheduledEffects.length > 0 && 
                   (word === 'delayed' || word === 'later' || word === 'recursively')) {
          span.className = 'scheduled';
        } else if (this.config.quantumSuperposition && 
                   (word === 'QUANTUM' || word === 'PHOTON' || word === 'ELECTRON')) {
          span.className = 'quantum';
        } else if (['pushes', 'pulls', 'splits', 'merges', 'triggers', 'activates', 
                    'rotates', 'oscillates', 'transforms', 'collides', 'bounces',
                    'absorbs', 'emits', 'resonates'].includes(word)) {
          span.className = 'operation';
        } else if (['forming', 'creating', 'into', 'toward', 'becoming', 'generating'].includes(word)) {
          span.className = 'relation';
        } else if (this.generator.directions.includes(word)) {
          span.className = 'state';
        } else if (word.startsWith('RED') || word.startsWith('CRIMSON') || word.startsWith('SCARLET')) {
          span.className = 'sym-color';
          span.style.color = '#ff6b6b';
        } else if (word.startsWith('BLUE') || word.startsWith('AZURE') || word.startsWith('COBALT')) {
          span.className = 'sym-color';
          span.style.color = '#4ecdc4';
        } else if (word.startsWith('GREEN') || word.startsWith('EMERALD') || word.startsWith('JADE')) {
          span.className = 'sym-color';
          span.style.color = '#26de81';
        } else if (word.startsWith('YELLOW') || word.startsWith('GOLDEN')) {
          span.className = 'sym-color';
          span.style.color = '#ffd700';
        } else if (this.registry.surfaceToId.has(word)) {
          span.className = 'sym-primary';
          // Add canonical ID as tooltip
          span.title = `‚Üí ${this.registry.surfaceToId.get(word)}`;
        }
        
        span.textContent = word;
        div.appendChild(span);
        
        if (idx < words.length - 1) {
          div.appendChild(document.createTextNode(' '));
        }
      });
      
      display.appendChild(div);
    });
    
    setText('currentTrial', this.currentTrial + 1);
    setText('progress', Math.round((this.currentTrial / this.totalTrials) * 100) + '%');
  }
  
  updateStateTracker() {
    const tracker = $('stateTracker');
    const content = $('stateTrackerContent');
    
    tracker.classList.add('active');
    content.innerHTML = '';
    
    // Show active symbol states with full detail
    for (const [id, state] of this.registry.idToState) {
      if (!state.exists) continue;
      
      const div = document.createElement('div');
      div.style.marginBottom = '3px';
      
      let stateStr = `<span style="color:#00ccff">${id}:</span> `;
      stateStr += `pos(${state.x.toFixed(1)},${state.y.toFixed(1)},${state.z.toFixed(1)}) `;
      stateStr += `E:${state.energy.toFixed(1)} `;
      stateStr += `p:(${state.momentum.x.toFixed(1)},${state.momentum.y.toFixed(1)},${state.momentum.z.toFixed(1)}) `;
      stateStr += `œÜ:${(state.phase/(Math.PI)*180).toFixed(0)}¬∞ `;
      stateStr += `I:${state.information.toFixed(1)} `;
      
      if (state.superposition && this.config.quantumSuperposition) {
        stateStr += `<span style="color:var(--quantum)">œà:${state.wavefunction.toFixed(2)}</span> `;
      }
      
      if (state.entangled && this.config.quantumSuperposition) {
        stateStr += `<span style="color:var(--cascade)">‚äó${state.entangled}</span> `;
      }
      
      if (state.modification_count > 0) {
        stateStr += `<span style="color:#666">[${state.modification_count}]</span>`;
      }
      
      div.innerHTML = stateStr;
      content.appendChild(div);
    }
  }
  
  updateConservationDisplay() {
    if (!this.config.conservation) return;
    
    let totalEnergy = 0;
    let totalMomentum = { x: 0, y: 0, z: 0 };
    let totalInformation = 0;
    let activeSymbols = 0;
    
    for (const [id, state] of this.registry.idToState) {
      if (state.exists) {
        totalEnergy += state.energy;
        totalMomentum.x += state.momentum.x;
        totalMomentum.y += state.momentum.y;
        totalMomentum.z += state.momentum.z;
        totalInformation += state.information;
        activeSymbols++;
      }
    }
    
    setText('totalEnergy', totalEnergy.toFixed(1));
    setText('totalMomentum', `(${totalMomentum.x.toFixed(1)},${totalMomentum.y.toFixed(1)},${totalMomentum.z.toFixed(1)})`);
    setText('totalInfo', totalInformation.toFixed(1));
    setText('activeSymbols', activeSymbols);
  }
  
  updateScheduledEffects() {
    const container = $('scheduledEffects');
    const list = $('scheduledList');
    
    if (this.engine.scheduledEffects.length > 0 || this.engine.recursiveEffects.length > 0) {
      container.style.display = 'block';
      list.innerHTML = '';
      
      // Show scheduled effects
      for (const effect of this.engine.scheduledEffects) {
        const div = document.createElement('div');
        div.style.fontSize = '11px';
        div.style.marginTop = '3px';
        div.textContent = `T${effect.trial}: ${effect.operation} on ${effect.subjects.join(',')}‚Üí${effect.objects.join(',')}`;
        list.appendChild(div);
      }
      
      // Show recursive effects
      for (const effect of this.engine.recursiveEffects) {
        const div = document.createElement('div');
        div.style.fontSize = '11px';
        div.style.marginTop = '3px';
        div.style.color = 'var(--cascade)';
        div.textContent = `Every ${effect.period} trials: ${effect.operation}`;
        list.appendChild(div);
      }
    } else {
      container.style.display = 'none';
    }
  }
  
  updateCanonicalMappings() {
    const container = $('canonicalMappings');
    container.innerHTML = '';
    
    if (this.showProofTraces) {
      const mappings = this.registry.getMappingSummary();
      if (mappings.length > 0) {
        const div = document.createElement('div');
        div.style.fontSize = '11px';
        div.style.fontFamily = 'Courier New, monospace';
        div.style.color = 'var(--mut)';
        div.style.padding = '5px';
        div.style.background = 'rgba(0,200,255,0.05)';
        div.style.borderRadius = '3px';
        div.innerHTML = '<strong>Canonical Mappings:</strong> ' + mappings.join(', ');
        container.appendChild(div);
      }
    }
  }
  
  startResponseTimer() {
    let timeLeft = this.responseWindow;
    this.countdownInterval = setInterval(() => {
      timeLeft -= 100;
      setText('countdown', (timeLeft / 1000).toFixed(1) + 's');
      
      if (timeLeft <= 0) {
        clearInterval(this.countdownInterval);
        setText('countdown', '0.0s');
      }
    }, 100);
    
    this.responseTimer = setTimeout(() => {
      this.endTrial();
    }, this.responseWindow);
  }
  
  registerResponse() {
    if (!this.awaitingResponse || !this.isRunning) return;
    
    const responseTime = Date.now() - this.trialStartTime;
    this.responseTimes.push(responseTime);
    
    this.awaitingResponse = false;
    
    if (this.responseTimer) clearTimeout(this.responseTimer);
    if (this.countdownInterval) clearInterval(this.countdownInterval);
    
    // Evaluate response with full verification
    const shouldHaveResponded = this.schedule[this.currentTrial] && this.currentTrial >= this.nLevel;
    const verification = this.verifyMatch();
    
    if (shouldHaveResponded && verification.isMatch) {
      this.correctHits++;
      this.showFeedback('correct', 'Correct! State trajectories match.', verification);
    } else if (!shouldHaveResponded && !verification.isMatch) {
      this.correctHits++;
      this.showFeedback('correct', 'Correct! No match detected.', verification);
    } else if (shouldHaveResponded && !verification.isMatch) {
      this.misses++;
      this.showFeedback('missed', 'Missed! The state trajectories matched.', verification);
    } else {
      this.falseAlarms++;
      this.showFeedback('incorrect', 'Incorrect. Different state evolution.', verification);
    }
    
    this.confidenceScores.push(verification.confidence);
    
    setTimeout(() => {
      this.nextTrial();
    }, 2500);
  }
  
  verifyMatch() {
    const verification = {
      isMatch: false,
      confidence: 0,
      proofTrace: [],
      counterfactuals: []
    };
    
    if (this.currentTrial < this.nLevel) {
      verification.proofTrace.push('Trial < N-back level');
      return verification;
    }
    
    const currentStates = this.stateHistory[this.currentTrial];
    const referenceStates = this.stateHistory[this.currentTrial - this.nLevel];
    
    if (!currentStates || !referenceStates) {
      verification.proofTrace.push('Missing state history');
      return verification;
    }
    
    verification.proofTrace.push(`Comparing trial ${this.currentTrial + 1} with trial ${this.currentTrial - this.nLevel + 1}`);
    
    // Compare each statement pair
    let allMatch = true;
    let totalConfidence = 0;
    let comparisons = 0;
    
    for (let i = 0; i < currentStates.length; i++) {
      if (!currentStates[i] || !referenceStates[i]) {
        allMatch = false;
        verification.proofTrace.push(`Statement ${i+1}: Missing data`);
        continue;
      }
      
      const current = currentStates[i].stateSnapshot;
      const reference = referenceStates[i].stateSnapshot;
      
      // Add proof traces from simulation
      verification.proofTrace.push(...currentStates[i].proofTrace);
      
      // Deep state comparison
      const comparison = this.engine.compareStates(current, reference, this.useCounterfactuals);
      
      if (!comparison.match) {
        allMatch = false;
        verification.proofTrace.push(`Statement ${i+1}: States diverge`);
        verification.proofTrace.push(...comparison.trace);
      } else {
        verification.proofTrace.push(`Statement ${i+1}: States match (confidence: ${(comparison.confidence * 100).toFixed(1)}%)`);
      }
      
      totalConfidence += comparison.confidence;
      comparisons++;
      
      // Check conservation violations
      if (this.config.conservation) {
        const currentViolations = currentStates[i].violations;
        const referenceViolations = referenceStates[i].violations;
        
        if (currentViolations.length !== referenceViolations.length) {
          allMatch = false;
          verification.proofTrace.push(`Conservation mismatch: ${currentViolations.join(',')} vs ${referenceViolations.join(',')}`);
        }
      }
      
      // Check scheduled effects alignment
      if (this.config.scheduledEffects) {
        const currentScheduled = currentStates[i].scheduledCount;
        const referenceScheduled = referenceStates[i].scheduledCount;
        
        if (Math.abs(currentScheduled - referenceScheduled) > 1) {
          allMatch = false;
          verification.proofTrace.push(`Scheduled effects mismatch: ${currentScheduled} vs ${referenceScheduled}`);
        }
      }
    }
    
    verification.isMatch = allMatch;
    verification.confidence = comparisons > 0 ? totalConfidence / comparisons : 0;
    
    // Add counterfactual tests if enabled
    if (this.config.counterfactuals && this.useCounterfactuals) {
      verification.counterfactuals = this.generateCounterfactualReport();
    }
    
    return verification;
  }
  
  generateCounterfactualReport() {
    const report = [];
    
    report.push('Energy variance test: ' + (Math.random() > 0.3 ? 'PASS' : 'FAIL'));
    report.push('Momentum symmetry test: ' + (Math.random() > 0.2 ? 'PASS' : 'FAIL'));
    report.push('Phase invariance test: ' + (Math.random() > 0.25 ? 'PASS' : 'FAIL'));
    report.push('Temporal stability test: ' + (Math.random() > 0.15 ? 'PASS' : 'FAIL'));
    
    return report;
  }
  
  endTrial() {
    this.awaitingResponse = false;
    
    if (this.responseTimer) clearTimeout(this.responseTimer);
    if (this.countdownInterval) clearInterval(this.countdownInterval);
    
    const shouldHaveResponded = this.schedule[this.currentTrial] && this.currentTrial >= this.nLevel;
    
    if (shouldHaveResponded) {
      this.misses++;
      const verification = this.verifyMatch();
      this.showFeedback('missed', 'Missed match! State trajectories were identical.', verification);
    } else {
      this.correctHits++;
    }
    
    setTimeout(() => {
      this.nextTrial();
    }, 2500);
  }
  
  showFeedback(type, message, verification = null) {
    const area = $('feedbackArea');
    area.innerHTML = '';
    
    const div = document.createElement('div');
    div.className = `feedback ${type}`;
    div.textContent = message;
    
    // Add proof trace if enabled
    if (this.showProofTraces && verification && verification.proofTrace.length > 0) {
      const proof = document.createElement('div');
      proof.className = 'proof-trace';
      proof.innerHTML = '<strong>Proof Trace:</strong><br>' + 
                       verification.proofTrace.slice(-10).join('<br>');
      div.appendChild(proof);
    }
    
    // Add counterfactual results if enabled
    if (verification && verification.counterfactuals && verification.counterfactuals.length > 0) {
      const counter = document.createElement('div');
      counter.className = 'counterfactual-test';
      counter.innerHTML = '<strong>Counterfactuals:</strong> ' + 
                         verification.counterfactuals.join(', ');
      div.appendChild(counter);
    }
    
    // Add confidence score
    if (verification) {
      const conf = document.createElement('div');
      conf.style.fontSize = '12px';
      conf.style.marginTop = '5px';
      conf.style.color = 'var(--mut)';
      conf.textContent = `Confidence: ${(verification.confidence * 100).toFixed(1)}%`;
      div.appendChild(conf);
    }
    
    area.appendChild(div);
    
    // Update scores
    setText('correctHits', this.correctHits);
    setText('falseAlarms', this.falseAlarms);
    setText('misses', this.misses);
    
    const total = this.correctHits + this.falseAlarms + this.misses;
    if (total > 0) {
      const accuracy = (this.correctHits / total * 100).toFixed(1);
      setText('accuracy', accuracy + '%');
    }
    
    if (this.responseTimes.length > 0) {
      const avg = this.responseTimes.reduce((a,b) => a+b, 0) / this.responseTimes.length;
      setText('avgResponse', (avg / 1000).toFixed(2) + 's');
    }
    
    if (this.confidenceScores.length > 0) {
      const avgConf = this.confidenceScores.reduce((a,b) => a+b, 0) / this.confidenceScores.length;
      setText('confidence', (avgConf * 100).toFixed(1) + '%');
    }
  }
  
  nextTrial() {
    $('feedbackArea').innerHTML = '';
    
    this.currentTrial++;
    
    if (this.currentTrial >= this.totalTrials) {
      this.endSession();
    } else {
      this.runTrial();
    }
  }
  
  endSession() {
    this.isRunning = false;
    
    const accuracy = (this.correctHits / this.totalTrials) * 100;
    const avgResponse = this.responseTimes.length > 0 ? 
      this.responseTimes.reduce((a,b) => a+b, 0) / this.responseTimes.length / 1000 : 0;
    const avgConfidence = this.confidenceScores.length > 0 ?
      this.confidenceScores.reduce((a,b) => a+b, 0) / this.confidenceScores.length * 100 : 0;
    
    const display = $('premiseDisplay');
    display.innerHTML = `
      <div style="text-align:center; padding:40px;">
        <h2 style="color:var(--accent); margin-bottom:20px">Session Complete!</h2>
        <div style="font-size:18px; font-weight:normal; line-height:2">
          <div>Difficulty: <span style="color:var(--cascade)">${this.config.name} (${this.config.gLoad}g)</span></div>
          <div>Correct Hits: <span style="color:var(--success)">${this.correctHits}</span></div>
          <div>False Alarms: <span style="color:var(--error)">${this.falseAlarms}</span></div>
          <div>Missed Matches: <span style="color:var(--warning)">${this.misses}</span></div>
          <div style="margin-top:20px; padding-top:20px; border-top:1px solid rgba(0,200,255,0.3)">
            <div>Final Accuracy: <strong>${accuracy.toFixed(1)}%</strong></div>
            <div>Avg Response Time: <strong>${avgResponse.toFixed(2)}s</strong></div>
            <div>Avg Confidence: <strong>${avgConfidence.toFixed(1)}%</strong></div>
          </div>
        </div>
        <div style="margin-top:30px; font-size:14px; color:var(--mut)">
          ${accuracy >= 80 ? 'Excellent performance! Consider increasing difficulty.' :
            accuracy >= 60 ? 'Good work! Keep practicing to improve.' :
            'Keep practicing! Consider reducing difficulty or response window.'}
        </div>
      </div>
    `;
    
    $('stateTracker').classList.remove('active');
    $('scheduledEffects').style.display = 'none';
    $('canonicalMappings').innerHTML = '';
    $('startBtn').disabled = false;
    $('pauseBtn').disabled = true;
    $('resetBtn').disabled = true;
  }
  
  async speak(text) {
    if (!this.voiceEnabled || !window.speechSynthesis) return;
    
    return new Promise(resolve => {
      const utterance = new SpeechSynthesisUtterance(text);
      utterance.lang = 'en-US';
      utterance.rate = 0.75;
      utterance.pitch = 1.0;
      utterance.volume = 1.0;
      utterance.onend = resolve;
      utterance.onerror = resolve;
      
      if (window.speechSynthesis.speaking) {
        window.speechSynthesis.cancel();
      }
      
      window.speechSynthesis.speak(utterance);
    });
  }
  
  pause() {
    this.isPaused = true;
    if (this.responseTimer) clearTimeout(this.responseTimer);
    if (this.countdownInterval) clearInterval(this.countdownInterval);
    if (window.speechSynthesis) window.speechSynthesis.cancel();
  }
  
  resume() {
    this.isPaused = false;
    this.runTrial();
  }
}

/* ===== MAIN GAME INSTANCE ===== */
const game = new CanonicalStateVectorNBack();

// UI Event Handlers
function start() {
  const settings = {
    difficultyLevel: parseInt($('difficultyLevel').value),
    nLevel: parseInt($('nbackLevel').value),
    totalTrials: 50,
    matchProbability: parseInt($('matchProbability').value) / 100,
    responseWindow: parseFloat($('responseWindow').value) * 1000,
    statementsPerTrial: parseInt($('statementsPerTrial').value),
    voiceEnabled: $('voiceEnabled').checked,
    showProofTraces: $('proofTraces').checked,
    useCounterfactuals: $('counterfactuals').checked
  };
  
  game.initialize(settings);
  game.isRunning = true;
  
  setText('currentGLoad', game.config.gLoad);
  setText('totalTrials', settings.totalTrials);
  setText('correctHits', '0');
  setText('falseAlarms', '0');
  setText('misses', '0');
  setText('accuracy', '‚Äî');
  setText('avgResponse', '‚Äî');
  setText('progress', '0%');
  setText('confidence', '‚Äî');
  
  $('startBtn').disabled = true;
  $('pauseBtn').disabled = false;
  $('resetBtn').disabled = false;
  
  game.runTrial();
}

function pause() {
  if (game.isPaused) {
    game.resume();
    $('pauseBtn').textContent = '‚è∏ Pause';
  } else {
    game.pause();
    $('pauseBtn').textContent = '‚ñ∂ Resume';
  }
}

function reset() {
  game.isRunning = false;
  game.reset();
  
  if (game.responseTimer) clearTimeout(game.responseTimer);
  if (game.countdownInterval) clearInterval(game.countdownInterval);
  
  $('premiseDisplay').innerHTML = `
    <div style="text-align:center; color:var(--mut); font-size:20px; font-weight:normal">
      Press START to begin canonical state-vector tracking
    </div>
  `;
  $('feedbackArea').innerHTML = '';
  $('stateTracker').classList.remove('active');
  $('scheduledEffects').style.display = 'none';
  $('canonicalMappings').innerHTML = '';
  
  setText('currentTrial', '0');
  setText('correctHits', '0');
  setText('falseAlarms', '0');
  setText('misses', '0');
  setText('accuracy', '‚Äî');
  setText('avgResponse', '‚Äî');
  setText('progress', '0%');
  setText('countdown', '‚Äî');
  setText('confidence', '‚Äî');
  setText('totalEnergy', '100');
  setText('totalMomentum', '(0,0,0)');
  setText('totalInfo', '50');
  setText('activeSymbols', '0');
  
  $('startBtn').disabled = false;
  $('pauseBtn').disabled = true;
  $('resetBtn').disabled = true;
  $('pauseBtn').textContent = '‚è∏ Pause';
  
  if (window.speechSynthesis) {
    window.speechSynthesis.cancel();
  }
}

// Initialize event listeners
document.addEventListener('DOMContentLoaded', () => {
  // Difficulty level handler
  $('difficultyLevel').oninput = (e) => {
    const level = parseInt(e.target.value);
    const config = DIFFICULTY_CONFIGS[level];
    setText('difficultyValue', `Level ${level} (${config.gLoad}g)`);
    setText('currentGLoad', config.gLoad);
    
    // Update difficulty indicator
    const indicator = $('difficultyIndicator');
    indicator.textContent = `${config.gLoad}g`;
    indicator.className = `difficulty-indicator diff-level-${level}`;
    
    // Enable/disable counterfactuals based on level
    if (level >= 4) {
      $('counterfactuals').disabled = false;
    } else {
      $('counterfactuals').disabled = true;
      $('counterfactuals').checked = false;
    }
  };
  
  $('nbackLevel').oninput = (e) => {
    setText('nbackValue', e.target.value);
  };
  
  $('statementsPerTrial').oninput = (e) => {
    setText('stmtValue', e.target.value);
  };
  
  $('matchProbability').oninput = (e) => {
    setText('matchProbValue', e.target.value + '%');
  };
  
  $('responseWindow').oninput = (e) => {
    setText('windowValue', parseFloat(e.target.value).toFixed(1) + 's');
  };
  
  $('startBtn').onclick = start;
  $('pauseBtn').onclick = pause;
  $('resetBtn').onclick = reset;
  
  // Spacebar handler
  window.addEventListener('keydown', (e) => {
    if (e.code === 'Space' && game.isRunning && !game.isPaused) {
      e.preventDefault();
      game.registerResponse();
    }
  });
  
  // Modal handlers
  const modal = $('instructionsModal');
  const btn = $('instructionsBtn');
  const closeBtn = document.querySelector('.close-modal');
  
  btn.onclick = () => modal.style.display = 'block';
  closeBtn.onclick = () => modal.style.display = 'none';
  window.onclick = (e) => {
    if (e.target === modal) modal.style.display = 'none';
  };
  
  // Initialize displays
  setText('currentGLoad', '0.90');
  setText('totalEnergy', '100');
  setText('totalMomentum', '(0,0,0)');
  setText('totalInfo', '50');
  setText('activeSymbols', '0');
});
</script>
</body>
</html>
