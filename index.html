<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>Quantum Semantic N-Back ‚Äî Cognitive Singularity Protocol</title>
<style>
:root { --bg:#0b0d10; --fg:#e6fbff; --a:#00ccff; --mut:#8fe7ff }
*{ box-sizing:border-box }
html,body{ height:100% }
body{ margin:0; background:#0b0d10; color:#e6fbff; font-family:system-ui,-apple-system,Segoe UI,Roboto,sans-serif }
.wrap{ max-width:1280px; margin:0 auto; padding:16px }
.row{ display:flex; gap:12px; flex-wrap:wrap }
.col{ flex:1 1 360px }
.box{ background:#101418; border:1px solid rgba(0,200,255,.25); border-radius:14px; padding:12px }
.title{ font-weight:800; margin-bottom:6px; letter-spacing:.3px }
.btn{ background:#0b0d10; color:#00ccff; border:1px solid #00ccff; border-radius:10px; padding:10px 14px; font-weight:700; cursor:pointer }
.btn:disabled{ opacity:.5; cursor:not-allowed }
label{ font-size:12px; color:#8fe7ff; display:block; margin:6px 0 }
input[type=range], input[type=number]{ width:100% }
.kbd{ border:1px solid rgba(255,255,255,.25); padding:2px 6px; border-radius:6px; background:#0b0d10 }
.mut{ color:#8fe7ff; font-size:12px }
hr.hr{border:none;border-top:1px solid rgba(0,200,255,.25);margin:8px 0}
#premiseContainer{ margin-top:12px; min-height:140px; background:#0e1113; border:1px solid rgba(0,200,255,.25); border-radius:12px; padding:12px; font-size:30px; line-height:2.1; word-break:break-word; font-family:'Courier New',monospace; font-weight:900; letter-spacing:2px }
.premise-line{ margin:14px 0; padding:16px; border-left:7px solid rgba(0,200,255,.7); background:linear-gradient(90deg, rgba(0,200,255,.2), rgba(0,200,255,.05)); border-radius:4px; position:relative }
.premise-number{ position:absolute; left:-40px; top:50%; transform:translateY(-50%); color:#00ccff; font-size:20px; font-weight:bold }
.badge{ display:inline-block; padding:2px 8px; border:1px solid rgba(0,200,255,.35); border-radius:999px; font-size:12px; color:#8fe7ff; margin-left:6px }
#countdown{ font-weight:800; color:#00ccff }
.entity{ color:#ff6b6b; text-shadow:0 0 14px rgba(255,107,107,.8) }
.operation{ color:#4ecdc4; text-shadow:0 0 12px rgba(78,205,196,.8) }
.paradox{ color:#ffd700; font-weight:bold; text-shadow:0 0 15px rgba(255,215,0,.9) }
.meta{ color:#00ff88; font-weight:bold; text-decoration:overline }
.quantum{ color:#b19cd9; font-style:italic; text-shadow:0 0 12px rgba(177,156,217,.8) }
.compound{ color:#00d2d3; text-decoration:underline; text-shadow:0 0 10px rgba(0,210,211,.7) }
.transform{ color:#ff00ff; font-weight:bold; text-shadow:0 0 12px rgba(255,0,255,.8) }
.mediator{ color:#a55eea; font-weight:900; text-shadow:0 0 16px rgba(165,94,234,.9) }
.meta-info{ font-size:13px; color:#4a8aff; margin-top:12px; opacity:0.9; font-weight:normal }
</style>
</head>
<body>
<div class="wrap">
  <div class="row">
    <div class="col">
      <div class="box">
        <div class="title">Quantum Configuration</div>
        <div class="mut" id="diffExplain">Cognitive Singularity ‚Ä¢ G-Load: ~0.90+</div>
        <hr class="hr">
        <label>N-Back level: <span id="nVal">1</span></label>
        <input id="nback" type="range" min="1" max="5" step="1" value="1">
        <hr class="hr">
        <label>Statements per trial: <span id="stmtVal">1</span></label>
        <input id="statements" type="range" min="1" max="5" step="1" value="1">
        <div class="mut small">Multiple statements create quantum interference patterns</div>
      </div>
    </div>

    <div class="col">
      <div class="box">
        <div class="title">Timing & Block</div>
        <div class="mut">Solve window: <strong><span id="solveLabel">5.0</span>s</strong> after speaking.</div>
        <label>Solve window (1‚Äì30s): <span id="solveVal">5.0s</span></label>
        <input id="solveWindow" type="range" min="1" max="30" step="0.1" value="5">
        <label>Trials per block: <span id="tVal">200</span></label>
        <input id="trials" type="range" min="20" max="500" step="10" value="200">
        <label>Target match rate: <span id="rVal">25%</span></label>
        <input id="rate" type="range" min="0" max="100" step="1" value="25">
        <label><input id="speakEnabled" type="checkbox" checked> Speak sentences</label>
      </div>
    </div>

    <div class="col">
      <div class="box">
        <div class="title">Controls / Status</div>
        <div style="display:flex; gap:8px; flex-wrap:wrap; margin-top:6px">
          <button id="start" class="btn">‚ñ∂ Start</button>
          <button id="pause" class="btn" disabled>‚è∏ Pause</button>
          <button id="reset" class="btn" disabled>üîÑ Reset</button>
          <button id="hit" class="btn" disabled>‚úì Match (<span class="kbd">Space</span>)</button>
          <button id="skip" class="btn" disabled>‚è≠ Skip</button>
        </div>
        <div class="mut" style="margin-top:8px">
          Trial <span id="idx">0</span>/<span id="max">200</span>
          <span class="badge">Planned: <span id="ptype">‚Äî</span></span>
          <span class="badge">Actual: <span id="isMatch">‚Äî</span></span>
          <span class="badge">Countdown: <span id="countdown">‚Äî</span></span>
        </div>
        <div class="mut">Correct: <span id="corr">0</span> ‚Ä¢ Errors: <span id="err">0</span></div>
        <div class="mut small" id="modeLine">Cognitive Singularity ‚Ä¢ G-Load: ~0.90+ ‚Ä¢ N=1</div>
      </div>
    </div>
  </div>

  <div class="box" style="margin-top:12px">
    <div class="title">Quantum Semantic N-Back <span class="badge">‚â§5 words</span> <span class="badge">Maximum g-load</span></div>
    <div id="premiseContainer" aria-live="polite">‚Äî</div>
  </div>

  <div id="log" style="display:none" aria-hidden="true">‚Äî</div>
</div>

<script>
/* ============================================================
   COGNITIVE SINGULARITY N-BACK
   True quantum semantic compression with maximum g-load
   ============================================================ */

const $ = id => document.getElementById(id);
function setText(id,v){ const el=$(id); if(el) el.textContent=v; }
function shuffle(a){ for(let i=a.length-1;i>0;i--){ const j=(Math.random()*(i+1))|0; [a[i],a[j]]=[a[j],a[i]] } return a; }

/* ===== TRANSFORMATION ENGINE ===== */
class TransformationEngine {
    constructor() {
        // Transformation functions with computational properties
        this.transformations = {
            'dissolves': { energyDelta: -2, coherence: 0.1, reversible: false, complexity: 2 },
            'crystallizes': { energyDelta: 2, coherence: 0.9, reversible: true, complexity: 2 },
            'inverts': { energyDelta: 0, coherence: 0.5, reversible: true, complexity: 1 },
            'cascades': { energyDelta: -3, coherence: 0.3, reversible: false, complexity: 3 },
            'fragments': { energyDelta: -1, coherence: 0.2, reversible: false, complexity: 2 },
            'coalesces': { energyDelta: 1, coherence: 0.8, reversible: true, complexity: 2 },
            'oscillates': { energyDelta: 0, coherence: 0.5, reversible: true, complexity: 2 },
            'resonates': { energyDelta: 0, coherence: 0.7, reversible: true, complexity: 3 },
            'collapses': { energyDelta: -4, coherence: 0.0, reversible: false, complexity: 3 },
            'entangles': { energyDelta: 1, coherence: 0.6, reversible: false, complexity: 4 },
            'tunnels': { energyDelta: -1, coherence: 0.4, reversible: false, complexity: 3 },
            'refracts': { energyDelta: 0, coherence: 0.5, reversible: true, complexity: 2 },
            'diffracts': { energyDelta: -1, coherence: 0.3, reversible: true, complexity: 3 },
            'superimposes': { energyDelta: 2, coherence: 0.6, reversible: true, complexity: 3 },
            'annihilates': { energyDelta: -5, coherence: 0.0, reversible: false, complexity: 4 },
            'becomes': { energyDelta: 0, coherence: 0.5, reversible: false, complexity: 1 },
            'transcends': { energyDelta: 3, coherence: 1.0, reversible: false, complexity: 4 }
        };
    }

    simulate(transformChain, initialState) {
        let state = { ...initialState };
        
        for (const transform of transformChain) {
            const t = this.transformations[transform];
            if (t) {
                state.energy += t.energyDelta;
                state.coherence *= t.coherence;
                state.complexity += t.complexity;
            }
        }
        
        return state;
    }

    areCompatible(t1, t2) {
        const trans1 = this.transformations[t1];
        const trans2 = this.transformations[t2];
        
        if (!trans1 || !trans2) return false;
        
        // Check energy conservation
        const energyBalance = Math.abs(trans1.energyDelta + trans2.energyDelta) <= 3;
        
        // Check coherence compatibility
        const coherenceValid = (trans1.coherence + trans2.coherence) <= 1.2;
        
        // Check reversibility paradox
        const reversibilityOk = !(trans1.reversible && trans2.reversible && 
                                  trans1.energyDelta * trans2.energyDelta < 0);
        
        return energyBalance && coherenceValid && reversibilityOk;
    }
}

/* ===== DYNAMIC LEXICON ===== */
class DynamicLexicon {
    constructor() {
        this.usedCombinations = new Set();
        this.sessionHash = new Set();
        
        // Synonym networks for preventing repetition
        this.synonymNetworks = {
            'WAVE': ['RIPPLE', 'SURGE', 'PULSE', 'FLOW', 'STREAM', 'CURRENT', 'TIDE', 'FLUX'],
            'PARTICLE': ['QUANTUM', 'ATOM', 'MOTE', 'GRAIN', 'SPECK', 'UNIT', 'ELEMENT', 'QUARK'],
            'VOID': ['VACUUM', 'NULL', 'ABYSS', 'CHASM', 'GAP', 'HOLE', 'SPACE', 'EMPTINESS'],
            'CHAOS': ['ENTROPY', 'DISORDER', 'TURMOIL', 'HAVOC', 'TUMULT', 'ANARCHY', 'BEDLAM', 'MAYHEM'],
            'ORDER': ['PATTERN', 'STRUCTURE', 'HARMONY', 'SYSTEM', 'FORM', 'DESIGN', 'MATRIX', 'LATTICE'],
            'LIGHT': ['PHOTON', 'RADIANCE', 'GLEAM', 'LUMINANCE', 'BEAM', 'RAY', 'GLOW', 'SPARK'],
            'SHADOW': ['SHADE', 'UMBRA', 'DARKNESS', 'GLOOM', 'PENUMBRA', 'DIMNESS', 'DUSK', 'MURK'],
            'ALWAYS': ['ETERNAL', 'FOREVER', 'PERPETUAL', 'ENDLESS', 'CONSTANT', 'CONTINUAL', 'PERMANENT', 'INFINITE'],
            'NEVER': ['VOID-TIME', 'ZERO-WHEN', 'NULL-ERA', 'ABSENT', 'NOWHERE-WHEN', 'UN-TIME', 'NON-MOMENT', 'NIL'],
            'BOTH': ['DUAL', 'TWIN', 'PAIRED', 'BINARY', 'DOUBLE', 'DUPLEX', 'BI-STATE', 'DI-FORM'],
            'NEITHER': ['NULL-BOTH', 'VOID-PAIR', 'UN-DUAL', 'NON-BINARY', 'ZERO-SET', 'EMPTY-PAIR', 'NIL-BOTH', 'NULL-TWIN']
        };

        // Neologism components for when vocabulary exhausted
        this.prefixes = ['HYPER', 'META', 'ULTRA', 'OMNI', 'TRANS', 'SUPRA', 'INFRA', 'QUASI'];
        this.roots = ['MORPH', 'PLEX', 'FLUX', 'CRYPT', 'STRAT', 'PHASE', 'SYNC', 'FORM'];
        this.suffixes = ['ION', 'ENT', 'OSE', 'INE', 'ATE', 'ILE', 'OID', 'EX'];
    }

    getUnusedWord(concept) {
        const network = this.synonymNetworks[concept];
        if (!network) return this.generateNeologism();
        
        const unused = network.filter(w => !this.sessionHash.has(w));
        if (unused.length === 0) {
            return this.generateNeologism();
        }
        
        const selected = unused[Math.floor(Math.random() * unused.length)];
        this.sessionHash.add(selected);
        return selected;
    }

    generateNeologism() {
        let attempts = 0;
        let neo;
        
        do {
            const pre = this.prefixes[Math.floor(Math.random() * this.prefixes.length)];
            const root = this.roots[Math.floor(Math.random() * this.roots.length)];
            const suf = this.suffixes[Math.floor(Math.random() * this.suffixes.length)];
            neo = `${pre}${root}${suf}`;
            attempts++;
        } while (this.sessionHash.has(neo) && attempts < 50);
        
        this.sessionHash.add(neo);
        return neo;
    }

    reset() {
        this.usedCombinations.clear();
        this.sessionHash.clear();
    }
}

/* ===== QUANTUM SEMANTIC GENERATOR ===== */
class QuantumSemanticGenerator {
    constructor() {
        this.transformEngine = new TransformationEngine();
        this.lexicon = new DynamicLexicon();
        
        // Base entity pools - will be dynamically replaced with synonyms
        this.baseEntities = ['WAVE', 'PARTICLE', 'VOID', 'CHAOS', 'ORDER', 'LIGHT', 'SHADOW'];
        this.paradoxNodes = ['BOTH', 'NEITHER', 'ALWAYS', 'NEVER'];
        this.mediators = ['through', 'via', 'within', 'across', 'between'];
        this.modifiers = ['inversely', 'fractally', 'quantumly', 'eternally', 'recursively'];
        
        // Session tracking
        this.generatedPremises = new Set();
        this.transformationHistory = [];
    }

    // True random generation using multiple entropy sources
    generateTrueRandom() {
        const sources = [
            performance.now() * Math.random() * 1000000,
            Date.now() % 999999,
            Math.sin(performance.now() * Math.random()) * 10000000,
            (window.devicePixelRatio || 1) * Math.random() * 1000000
        ];
        
        // Try crypto API if available
        if (window.crypto && window.crypto.getRandomValues) {
            const arr = new Uint32Array(1);
            window.crypto.getRandomValues(arr);
            sources.push(arr[0]);
        }
        
        // XOR fold for maximum entropy
        const result = sources.reduce((a, b) => a ^ Math.floor(b), 0);
        return Math.abs(result);
    }

    // Generate unique premise with no repetition
    generatePremise(trial, nback, count = 1) {
        const premises = [];
        
        for (let i = 0; i < count; i++) {
            let premise;
            let attempts = 0;
            const maxAttempts = 100;
            
            do {
                const seed = this.generateTrueRandom() + attempts * 99991;
                premise = this.buildQuantumPremise(seed, i, count);
                attempts++;
            } while (this.generatedPremises.has(premise.text) && attempts < maxAttempts);
            
            this.generatedPremises.add(premise.text);
            premises.push(premise);
            
            // Clear old premises if set gets too large
            if (this.generatedPremises.size > 500) {
                const premiseArray = Array.from(this.generatedPremises);
                this.generatedPremises = new Set(premiseArray.slice(-250));
            }
        }
        
        return premises;
    }

    // Build quantum semantic premise
    buildQuantumPremise(seed, index, total) {
        const pattern = seed % 5;
        let text = '';
        
        switch(pattern) {
            case 0: // Entity transform cascade
                text = this.buildTransformChain(seed);
                break;
            case 1: // Paradox resolution
                text = this.buildParadoxPremise(seed);
                break;
            case 2: // Meta-recursive
                text = this.buildMetaRecursive(seed, index);
                break;
            case 3: // Phase transition
                text = this.buildPhaseTransition(seed);
                break;
            case 4: // Quantum superposition
                text = this.buildSuperposition(seed);
                break;
        }
        
        // Ensure exactly 5 words
        const words = text.split(' ').filter(w => w.length > 0);
        if (words.length > 5) {
            text = words.slice(0, 5).join(' ');
        } else if (words.length < 5) {
            // Pad with quantum operators
            const padding = ['quantumly', 'fractally', 'eternally', 'recursively', 'infinitely'];
            while (words.length < 5) {
                words.push(padding[seed % padding.length]);
            }
            text = words.join(' ');
        }
        
        const structure = this.extractStructure(text);
        
        return {
            text: text,
            structure: structure,
            seed: seed,
            pattern: pattern
        };
    }

    // Pattern builders
    buildTransformChain(seed) {
        const e1 = this.getEntity(seed);
        const t1 = this.getTransform(seed + 1);
        const e2 = this.getEntity(seed + 2);
        const med = this.mediators[seed % this.mediators.length];
        const e3 = this.getEntity(seed + 3);
        
        return `${e1} ${t1} ${e2} ${med} ${e3}`;
    }

    buildParadoxPremise(seed) {
        const p1 = this.getParadox(seed);
        const t = this.getTransform(seed + 1);
        const e1 = this.getEntity(seed + 2);
        const mod = this.modifiers[seed % this.modifiers.length];
        const compound = `${mod}-${t}`;
        
        return `${p1} ${compound} ${e1} becoming INVERSE`;
    }

    buildMetaRecursive(seed, index) {
        const ref = index > 0 ? 'IT' : 'ITSELF';
        const t1 = this.getTransform(seed);
        const t2 = this.getTransform(seed + 1);
        const compound = `${t1}-${t2}`;
        const e = this.getEntity(seed + 2);
        
        return `${ref} ${compound} through ${e} recursively`;
    }

    buildPhaseTransition(seed) {
        const e1 = this.getEntity(seed);
        const arrow = '‚Üí';
        const e2 = this.getEntity(seed + 1);
        const t = this.getTransform(seed + 2);
        const mod = this.modifiers[seed % this.modifiers.length];
        
        return `${e1}${arrow}${e2} ${t} ${mod} NOW`;
    }

    buildSuperposition(seed) {
        const e1 = this.getEntity(seed);
        const e2 = this.getEntity(seed + 1);
        const superposed = `${e1}|${e2}`;
        const t = this.getTransform(seed + 2);
        const state = seed % 2 === 0 ? 'COLLAPSING' : 'EXPANDING';
        
        return `${superposed} ${t} ${state} quantum-field`;
    }

    // Get unique entities using dynamic lexicon
    getEntity(seed) {
        const base = this.baseEntities[seed % this.baseEntities.length];
        return this.lexicon.getUnusedWord(base);
    }

    getTransform(seed) {
        const transforms = Object.keys(this.transformEngine.transformations);
        return transforms[seed % transforms.length];
    }

    getParadox(seed) {
        const base = this.paradoxNodes[seed % this.paradoxNodes.length];
        return this.lexicon.getUnusedWord(base);
    }

    // Extract deep structure for matching
    extractStructure(text) {
        const words = text.split(' ');
        const transforms = [];
        const entities = [];
        
        // Find all transformations
        for (const word of words) {
            const parts = word.split('-');
            for (const part of parts) {
                if (this.transformEngine.transformations[part]) {
                    transforms.push(part);
                }
            }
        }
        
        // Calculate transformation properties
        const initialState = { energy: 0, coherence: 1, complexity: 0 };
        const finalState = this.transformEngine.simulate(transforms, initialState);
        
        return {
            transforms: transforms,
            energy: finalState.energy,
            coherence: finalState.coherence,
            complexity: finalState.complexity,
            wordCount: words.length,
            hasRecursion: text.includes('IT') || text.includes('ITSELF'),
            hasParadox: /BOTH|NEITHER|ALWAYS|NEVER/.test(text),
            hasSuperposition: text.includes('|') || text.includes('‚Üí'),
            topology: this.determineTopology(transforms)
        };
    }

    determineTopology(transforms) {
        if (transforms.length === 0) return 'static';
        if (transforms.length === 1) return 'linear';
        
        // Check for cycles
        let hasReversible = false;
        let hasIrreversible = false;
        
        for (const t of transforms) {
            const trans = this.transformEngine.transformations[t];
            if (trans) {
                if (trans.reversible) hasReversible = true;
                else hasIrreversible = true;
            }
        }
        
        if (hasReversible && hasIrreversible) return 'branching';
        if (hasReversible) return 'cyclic';
        return 'cascade';
    }

    // Deep compatibility checking through transformation simulation
    checkCompatibility(p1, p2) {
        const s1 = typeof p1 === 'object' ? p1.structure : this.extractStructure(p1);
        const s2 = typeof p2 === 'object' ? p2.structure : this.extractStructure(p2);
        
        // Multi-dimensional compatibility
        const dimensions = {
            topological: s1.topology === s2.topology ? 1.0 : 0.0,
            energetic: 1.0 - Math.min(1.0, Math.abs(s1.energy - s2.energy) / 10),
            coherence: 1.0 - Math.abs(s1.coherence - s2.coherence),
            complexity: 1.0 - Math.min(1.0, Math.abs(s1.complexity - s2.complexity) / 5),
            structural: (s1.hasRecursion === s2.hasRecursion ? 0.5 : 0) + 
                       (s1.hasParadox === s2.hasParadox ? 0.5 : 0)
        };
        
        // Weighted sum
        const weights = { topological: 0.3, energetic: 0.25, coherence: 0.2, complexity: 0.15, structural: 0.1 };
        
        let score = 0;
        for (const dim in dimensions) {
            score += dimensions[dim] * weights[dim];
        }
        
        return score >= 0.5;
    }

    reset() {
        this.generatedPremises.clear();
        this.transformationHistory = [];
        this.lexicon.reset();
    }
}

/* ===== COGNITIVE LOAD MANAGER ===== */
class CognitiveLoadManager {
    constructor() {
        this.responseTimeBuffer = [];
        this.errorRateBuffer = [];
        this.currentLoad = 0.9;
    }

    recordResponse(responseTime, wasCorrect) {
        this.responseTimeBuffer.push(responseTime);
        this.errorRateBuffer.push(!wasCorrect);
        
        // Keep only last 10 responses
        if (this.responseTimeBuffer.length > 10) {
            this.responseTimeBuffer.shift();
            this.errorRateBuffer.shift();
        }
        
        this.adjustLoad();
    }

    adjustLoad() {
        if (this.responseTimeBuffer.length < 5) return;
        
        const avgTime = this.responseTimeBuffer.reduce((a,b) => a+b, 0) / this.responseTimeBuffer.length;
        const errorRate = this.errorRateBuffer.filter(e => e).length / this.errorRateBuffer.length;
        
        if (errorRate > 0.4 && avgTime > 7000) {
            // User overwhelmed
            this.currentLoad = Math.max(0.7, this.currentLoad * 0.95);
        } else if (errorRate < 0.2 && avgTime < 3000) {
            // User coasting
            this.currentLoad = Math.min(1.0, this.currentLoad * 1.05);
        }
    }

    getOptimalComplexity() {
        return this.currentLoad;
    }
}

/* ===== Global state ===== */
const premiseGenerator = new QuantumSemanticGenerator();
const cognitiveLoadManager = new CognitiveLoadManager();
let MAX=200, RATE=25, N=1, SPEAK=true, SOLVE_WINDOW=5.0, STATEMENTS=1;

/* ===== Session management ===== */
let idx=0, correct=0, errors=0, planned=[], history=[], SESSION={running:false, paused:false};
let currentTruth=false, responded=false, solveTimer=null, countdownTimer=null, countdownLeft=0;
let responseStartTime = 0;

function planSequence(){ 
  planned.length=MAX; 
  for(let i=0;i<MAX;i++) planned[i]=false; 
  const elig=[]; 
  for(let i=N;i<MAX;i++) elig.push(i); 
  const k=Math.round((RATE/100)*elig.length); 
  shuffle(elig); 
  for(let i=0;i<k;i++) planned[elig[i]]=true; 
}

function sanitizeForDisplay(text) {
    // Ensure no HTML entities in the raw text
    const cleanText = text.replace(/[<>&"']/g, '');
    return cleanText;
}

function showPremises(premises) {
    const container = $('premiseContainer');
    container.innerHTML = '';
    
    const arr = Array.isArray(premises) ? premises : [premises];
    
    arr.forEach((p, i) => {
        const div = document.createElement('div');
        div.className = 'premise-line';
        
        if (arr.length > 1) {
            const num = document.createElement('span');
            num.className = 'premise-number';
            num.textContent = (i+1).toString();
            div.appendChild(num);
        }
        
        const text = typeof p === 'object' ? p.text : p;
        const cleanText = sanitizeForDisplay(text);
        
        // Parse and highlight with proper DOM manipulation
        const words = cleanText.split(' ');
        const fragments = [];
        
        for (const word of words) {
            const span = document.createElement('span');
            
            // Determine word type and apply class
            if (/^[A-Z]+$/.test(word) && word.length > 2) {
                // Entities
                if (['BOTH','NEITHER','ALWAYS','NEVER','DUAL','TWIN','ETERNAL','FOREVER'].includes(word)) {
                    span.className = 'paradox';
                } else if (['IT','ITSELF','THIS','THAT'].includes(word)) {
                    span.className = 'meta';
                } else if (['COLLAPSING','EXPANDING','INVERSE','NOW'].includes(word)) {
                    span.className = 'quantum';
                } else {
                    span.className = 'entity';
                }
            } else if (word.includes('-')) {
                // Compound operations
                span.className = 'compound';
            } else if (word.includes('|') || word.includes('‚Üí')) {
                // Superposition/transition
                span.className = 'quantum';
            } else if (['through','via','within','across','between','becoming'].includes(word)) {
                // Mediators
                span.className = 'mediator';
            } else if (Object.keys(premiseGenerator.transformEngine.transformations).includes(word)) {
                // Transformations
                span.className = 'transform';
            } else if (['inversely','fractally','quantumly','eternally','recursively','infinitely'].includes(word)) {
                // Modifiers
                span.className = 'operation';
            } else {
                // Default
                span.className = '';
            }
            
            span.textContent = word;
            fragments.push(span);
            fragments.push(document.createTextNode(' '));
        }
        
        // Add all fragments to div
        fragments.forEach(f => div.appendChild(f));
        
        // Add meta info if present
        if (typeof p === 'object' && p.structure) {
            const meta = document.createElement('div');
            meta.className = 'meta-info';
            meta.textContent = `[Energy: ${p.structure.energy}, Coherence: ${p.structure.coherence.toFixed(2)}, Complexity: ${p.structure.complexity}, Topology: ${p.structure.topology}]`;
            div.appendChild(meta);
        }
        
        container.appendChild(div);
    });
}

function updateUI(){ 
  setText('idx', idx); 
  setText('max', MAX); 
  setText('ptype', (idx<MAX && idx>=N && planned[idx])?'MATCH':'NON-match'); 
  setText('corr', correct); 
  setText('err', errors); 
  setText('isMatch','‚Äî'); 
}

async function speak(text){
  if(!SPEAK) return Promise.resolve();
  if(typeof window==='undefined'||!('speechSynthesis' in window)) return Promise.resolve();
  
  const speakText = Array.isArray(text) ? 
    text.map(p => sanitizeForDisplay(p.text || p)).join('. ') : 
    sanitizeForDisplay(text.text || text);
    
  return new Promise(res=>{ 
    try{ 
      const u=new SpeechSynthesisUtterance(speakText); 
      u.lang='en-GB'; 
      u.rate=0.65; 
      u.pitch=1.0; 
      u.volume=1.0; 
      u.onend=()=>res(); 
      u.onerror=()=>res(); 
      if(window.speechSynthesis.speaking) window.speechSynthesis.cancel(); 
      window.speechSynthesis.speak(u); 
    }catch{ 
      res(); 
    } 
  });
}

function scheduleCountdown(sec){ 
  countdownLeft=sec; 
  setText('countdown', countdownLeft.toFixed(1)+'s'); 
  if(countdownTimer) clearInterval(countdownTimer); 
  countdownTimer=setInterval(()=>{ 
    countdownLeft=Math.max(0,countdownLeft-0.1); 
    setText('countdown', countdownLeft.toFixed(1)+'s'); 
    if(countdownLeft<=0){ 
      clearInterval(countdownTimer); 
      countdownTimer=null; 
    } 
  },100); 
}

function evaluateAndAdvance(){ 
  const responseTime = Date.now() - responseStartTime;
  const resp=responded, truth=currentTruth; 
  
  if(resp===truth) correct++; 
  else errors++; 
  
  setText('corr',correct); 
  setText('err',errors); 
  setText('isMatch', String(truth).toUpperCase());
  
  // Record for cognitive load adjustment
  cognitiveLoadManager.recordResponse(responseTime, resp === truth);
  
  idx++; 
  if(idx>=MAX){ 
    stop(); 
    return; 
  } 
  runTrial(); 
}

function runTrial(){
  if(!SESSION.running || SESSION.paused) return;
  
  const mustMatch=(idx>=N)&&planned[idx];
  
  let premises = premiseGenerator.generatePremise(idx, N, STATEMENTS);
  
  if(idx >= N) {
    const reference = history[idx-N];
    
    if(mustMatch) {
      // Ensure match through multiple attempts
      let attempts = 0;
      while(!premiseGenerator.checkCompatibility(premises[0], reference[0]) && attempts < 20) {
        premises = premiseGenerator.generatePremise(idx + attempts * 7919, N, STATEMENTS);
        attempts++;
      }
      currentTruth = true;
    } else {
      // Ensure non-match
      if(premiseGenerator.checkCompatibility(premises[0], reference[0])) {
        // Force incompatibility by inverting structure
        const inverted = premiseGenerator.generatePremise(idx + 9999, N, STATEMENTS);
        premises = inverted;
      }
      currentTruth = premiseGenerator.checkCompatibility(premises[0], reference[0]);
      if(currentTruth) currentTruth = false; // Force non-match
    }
  } else {
    currentTruth = false;
  }
  
  history[idx] = premises;
  showPremises(premises); 
  responded=false;
  responseStartTime = Date.now();
  
  setText('isMatch','‚Äî'); 
  setText('ptype', (idx<MAX && idx>=N && planned[idx])?'MATCH':'NON-match');

  speak(premises).then(()=>{ 
    scheduleCountdown(SOLVE_WINDOW); 
    if(solveTimer) clearTimeout(solveTimer); 
    solveTimer=setTimeout(()=>{ 
      evaluateAndAdvance(); 
    }, SOLVE_WINDOW*1000); 
  });
}

/* Controls */
function start(){
  MAX=+$('trials').value||200; 
  RATE=+$('rate').value||25; 
  N=+$('nback').value||1; 
  STATEMENTS=+$('statements').value||1;
  SPEAK=!!$('speakEnabled').checked;
  SOLVE_WINDOW=+($('solveWindow').value||5); 
  setText('solveLabel', SOLVE_WINDOW.toFixed(1)); 
  setText('solveVal', SOLVE_WINDOW.toFixed(1)+'s');
  
  // Full reset for new session
  premiseGenerator.reset();
  cognitiveLoadManager.responseTimeBuffer = [];
  cognitiveLoadManager.errorRateBuffer = [];

  idx=0; 
  correct=0; 
  errors=0; 
  planned=[]; 
  history=[]; 
  planSequence(); 
  updateUI();
  SESSION.running=true; 
  SESSION.paused=false;
  $('pause').disabled=false; 
  $('reset').disabled=false; 
  $('hit').disabled=false; 
  $('skip').disabled=false;
  runTrial();
}

function stop(){ 
  SESSION.running=false; 
  SESSION.paused=false; 
  if(solveTimer) clearTimeout(solveTimer); 
  if(countdownTimer) clearInterval(countdownTimer); 
  setText('countdown','‚Äî'); 
  try{ 
    if(window.speechSynthesis) window.speechSynthesis.cancel(); 
  }catch{} 
}

function togglePause(){
  if(!SESSION.running) return;
  SESSION.paused=!SESSION.paused; 
  $('pause').textContent=SESSION.paused?'‚ñ∂ Resume':'‚è∏ Pause';
  if(SESSION.paused){ 
    if(solveTimer) clearTimeout(solveTimer); 
    if(countdownTimer) clearInterval(countdownTimer); 
    try{ 
      if(window.speechSynthesis) window.speechSynthesis.cancel(); 
    }catch{} 
  }
  else{
    scheduleCountdown(countdownLeft>0?countdownLeft:SOLVE_WINDOW);
    if(solveTimer) clearTimeout(solveTimer);
    solveTimer=setTimeout(()=>{ 
      evaluateAndAdvance(); 
    }, (countdownLeft>0?countdownLeft:SOLVE_WINDOW)*1000);
  }
}

function reset(){ 
  stop(); 
  // Full reset
  premiseGenerator.reset();
  
  $('premiseContainer').innerHTML='‚Äî'; 
  setText('idx',0); 
  setText('corr',0); 
  setText('err',0); 
  setText('ptype','‚Äî'); 
  setText('isMatch','‚Äî'); 
}

function registerHit(){ 
  if(!SESSION.running || SESSION.paused) return; 
  responded=true; 
}

function skip(){ 
  if(!SESSION.running || SESSION.paused) return; 
  if(solveTimer) clearTimeout(solveTimer); 
  if(countdownTimer) clearInterval(countdownTimer); 
  setText('countdown','‚Äî'); 
  evaluateAndAdvance(); 
}

/* Event bindings */
document.addEventListener('DOMContentLoaded', ()=>{
  const sw=$('solveWindow'); 
  const updateSW=()=>{ 
    const v=+sw.value; 
    setText('solveVal', v.toFixed(1)+'s'); 
    setText('solveLabel', v.toFixed(1)); 
  };
  updateSW(); 
  sw.oninput=e=>{ 
    if(!SESSION.running){ 
      updateSW(); 
    } 
  };
  
  $('nback').oninput=e=>{ 
    if(!SESSION.running){ 
      N=+e.target.value; 
      setText('nVal',N); 
      const currentText = $('modeLine').textContent;
      $('modeLine').textContent=`Cognitive Singularity ‚Ä¢ G-Load: ~0.90+ ‚Ä¢ N=${N}`; 
    } 
  };
  
  $('statements').oninput=e=>{ 
    if(!SESSION.running){ 
      STATEMENTS=+e.target.value; 
      setText('stmtVal',STATEMENTS); 
    } 
  };
  
  $('trials').oninput=e=>{ 
    if(!SESSION.running){ 
      MAX=+e.target.value; 
      setText('tVal',MAX); 
      setText('max',MAX); 
    } 
  };
  
  $('rate').oninput=e=>{ 
    if(!SESSION.running){ 
      RATE=+e.target.value; 
      setText('rVal',RATE+'%'); 
    } 
  };
  
  $('speakEnabled').onchange=e=>{ 
    SPEAK=!!e.target.checked; 
  };

  $('start').onclick=start; 
  $('pause').onclick=togglePause; 
  $('reset').onclick=reset; 
  $('hit').onclick=registerHit; 
  $('skip').onclick=skip;
  
  window.addEventListener('keydown', e=>{ 
    if(!SESSION.running) return; 
    if(e.code==='Space'){ 
      registerHit(); 
      e.preventDefault(); 
    } 
  });

  setText('nVal',N); 
  setText('stmtVal',STATEMENTS);
  setText('tVal',MAX); 
  setText('rVal',RATE+'%');
  setText('modeLine',`Cognitive Singularity ‚Ä¢ G-Load: ~0.90+ ‚Ä¢ N=${N}`);
  updateUI();
});
</script>
</body>
</html>
