<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>Infinity N-Back ‚Äî Maximum Relational G-Load</title>
<style>
:root { 
  --bg:#050507; 
  --fg:#e6fbff; 
  --accent:#00ffff; 
  --dim:#00ccff; 
  --glow:#00ffff40;
  --error:#ff3366;
  --success:#00ff88;
}

*{ box-sizing:border-box }
html,body{ height:100%; overflow-x:hidden }
body{ 
  margin:0; 
  background:linear-gradient(135deg, #050507, #0a0a0f); 
  color:var(--fg); 
  font-family:system-ui,-apple-system,Segoe UI,Roboto,sans-serif 
}

.wrap{ max-width:1280px; margin:0 auto; padding:16px }
.row{ display:flex; gap:12px; flex-wrap:wrap }
.col{ flex:1 1 360px }

.box{ 
  background:rgba(16,20,24,0.9); 
  border:1px solid rgba(0,255,255,.2); 
  border-radius:14px; 
  padding:12px; 
  backdrop-filter:blur(10px);
  box-shadow:0 4px 20px rgba(0,255,255,0.1);
}

.title{ 
  font-weight:800; 
  margin-bottom:8px; 
  letter-spacing:.5px;
  color:var(--accent);
}

.btn{ 
  background:rgba(0,255,255,0.1); 
  color:var(--accent); 
  border:1px solid var(--accent); 
  border-radius:10px; 
  padding:10px 14px; 
  font-weight:700; 
  cursor:pointer; 
  transition:all 0.3s;
  text-transform:uppercase;
  letter-spacing:0.5px;
}

.btn:hover:not(:disabled){ 
  background:rgba(0,255,255,0.2); 
  box-shadow:0 0 20px rgba(0,255,255,.5);
  transform:translateY(-1px);
}

.btn:disabled{ 
  opacity:.3; 
  cursor:not-allowed 
}

.btn.instructions{ 
  background:rgba(95,39,205,0.2); 
  border-color:#7c3aed; 
  color:#a78bfa;
}

.btn.instructions:hover{ 
  background:rgba(124,58,237,0.3); 
  box-shadow:0 0 20px rgba(124,58,237,.6) 
}

label{ 
  font-size:12px; 
  color:#8fe7ff; 
  display:block; 
  margin:8px 0 4px 0;
  text-transform:uppercase;
  letter-spacing:0.5px;
  font-weight:600;
}

input[type=range]{ 
  width:100%;
  height:6px;
  background:rgba(0,255,255,0.1);
  border-radius:3px;
  outline:none;
}

input[type=range]::-webkit-slider-thumb{
  -webkit-appearance:none;
  width:16px;
  height:16px;
  background:var(--accent);
  border-radius:50%;
  cursor:pointer;
}

.kbd{ 
  border:1px solid rgba(255,255,255,.25); 
  padding:2px 6px; 
  border-radius:6px; 
  background:#0b0d10; 
  font-size:11px;
  font-family:monospace;
}

.mut{ 
  color:#8fe7ff; 
  font-size:12px;
  opacity:0.8;
}

hr.hr{
  border:none;
  border-top:1px solid rgba(0,255,255,.15);
  margin:12px 0;
}

#premiseContainer{ 
  margin-top:16px; 
  min-height:160px; 
  background:linear-gradient(145deg, rgba(5,5,7,0.95), rgba(10,10,15,0.95));
  border:2px solid rgba(0,255,255,.3); 
  border-radius:16px; 
  padding:20px; 
  font-size:32px; 
  line-height:2.2; 
  font-family:'JetBrains Mono','Courier New',monospace; 
  font-weight:800; 
  letter-spacing:3px;
  position:relative;
  overflow:hidden;
}

#premiseContainer::before{
  content:'';
  position:absolute;
  top:-100%;
  left:-100%;
  width:300%;
  height:300%;
  background:radial-gradient(circle at center, rgba(0,255,255,0.03) 0%, transparent 50%);
  animation:pulse 10s ease-in-out infinite;
  pointer-events:none;
}

@keyframes pulse{ 
  0%,100%{transform:scale(1); opacity:0.5}
  50%{transform:scale(1.1); opacity:1}
}

.premise-line{ 
  margin:16px 0; 
  padding:20px; 
  border-left:8px solid rgba(0,255,255,.6); 
  background:linear-gradient(90deg, rgba(0,255,255,.15), transparent); 
  border-radius:8px; 
  position:relative;
  z-index:1;
  transition:all 0.3s;
}

.premise-line:hover{
  border-left-color:var(--accent);
  background:linear-gradient(90deg, rgba(0,255,255,.2), transparent);
}

.premise-number{ 
  position:absolute; 
  left:-45px; 
  top:50%; 
  transform:translateY(-50%); 
  color:var(--accent); 
  font-size:24px; 
  font-weight:bold;
  text-shadow:0 0 10px var(--glow);
}

.badge{ 
  display:inline-block; 
  padding:3px 10px; 
  border:1px solid rgba(0,255,255,.3); 
  border-radius:999px; 
  font-size:11px; 
  color:var(--accent); 
  margin-left:8px;
  background:rgba(0,255,255,0.05);
  font-weight:600;
  text-transform:uppercase;
  letter-spacing:0.5px;
}

#countdown{ 
  font-weight:800; 
  color:var(--accent);
  text-shadow:0 0 5px var(--glow);
}

/* Semantic highlighting for Infinity version */
.symbol-cluster{ 
  color:#ff6b6b; 
  text-shadow:0 0 20px rgba(255,107,107,.9);
  font-weight:900;
}

.transform-op{ 
  color:#4ecdc4; 
  text-shadow:0 0 15px rgba(78,205,196,.8);
  font-style:italic;
}

.axis-mod{ 
  color:#ffd700; 
  text-shadow:0 0 15px rgba(255,215,0,.9);
  font-weight:bold;
}

.propagation{ 
  color:#a78bfa; 
  text-shadow:0 0 15px rgba(167,139,250,.8);
}

.resolution{ 
  color:#00ff88; 
  text-shadow:0 0 15px rgba(0,255,136,.8);
  font-weight:bold;
}

.latent{ 
  color:#ff00ff; 
  text-shadow:0 0 15px rgba(255,0,255,.8);
  animation:flicker 2s infinite;
}

@keyframes flicker{
  0%,100%{opacity:1}
  50%{opacity:0.6}
}

.meta-info{ 
  font-size:12px; 
  color:#8fe7ff; 
  margin-top:16px; 
  opacity:0.7; 
  font-weight:normal;
  font-family:system-ui;
  line-height:1.6;
  padding:8px;
  background:rgba(0,255,255,0.05);
  border-radius:6px;
  border:1px solid rgba(0,255,255,0.1);
}

/* Modal for instructions */
.modal{
  display:none;
  position:fixed;
  z-index:2000;
  left:0;
  top:0;
  width:100%;
  height:100%;
  background:rgba(0,0,0,0.95);
  backdrop-filter:blur(10px);
}

.modal-content{
  background:linear-gradient(135deg, #101418, #0a0a0f);
  margin:1% auto;
  padding:30px;
  border:2px solid var(--accent);
  border-radius:20px;
  width:95%;
  max-width:900px;
  max-height:95vh;
  overflow-y:auto;
  box-shadow:0 0 40px rgba(0,255,255,.4);
}

.modal-content::-webkit-scrollbar{
  width:8px;
}

.modal-content::-webkit-scrollbar-track{
  background:rgba(0,255,255,0.05);
  border-radius:4px;
}

.modal-content::-webkit-scrollbar-thumb{
  background:rgba(0,255,255,0.3);
  border-radius:4px;
}

.modal-content h2{ 
  color:var(--accent); 
  margin-top:24px;
  font-size:28px;
  text-shadow:0 0 10px var(--glow);
}

.modal-content h3{ 
  color:#a78bfa; 
  margin-top:20px;
  font-size:20px;
}

.modal-content h4{ 
  color:#8fe7ff; 
  margin-top:16px;
  font-size:16px;
}

.modal-content p{ 
  line-height:1.8; 
  color:#e6fbff;
  margin:12px 0;
}

.modal-content .example{
  background:#050507;
  border-left:4px solid var(--accent);
  padding:16px;
  margin:16px 0;
  font-family:'JetBrains Mono',monospace;
  font-size:14px;
  border-radius:8px;
  line-height:1.6;
}

.modal-content .explanation{
  color:#00ff88;
  margin-top:12px;
  padding:12px;
  background:rgba(0,255,136,0.1);
  border-radius:6px;
  border:1px solid rgba(0,255,136,0.2);
}

.modal-content .warning{
  background:rgba(255,51,102,0.1);
  border:1px solid var(--error);
  padding:12px;
  border-radius:8px;
  color:#ff6b6b;
  margin:16px 0;
  font-weight:600;
}

.close{
  color:var(--error);
  float:right;
  font-size:32px;
  font-weight:bold;
  cursor:pointer;
  transition:all 0.3s;
  line-height:20px;
}

.close:hover{ 
  color:#ff0044;
  transform:rotate(90deg);
}

/* Special effects for Infinity mode */
.infinity-indicator{
  display:inline-block;
  color:var(--accent);
  font-weight:bold;
  animation:rotate-3d 4s linear infinite;
}

@keyframes rotate-3d{
  from{transform:rotateY(0deg)}
  to{transform:rotateY(360deg)}
}
</style>
</head>
<body>
<div class="wrap">
  <div class="row">
    <div class="col">
      <div class="box">
        <div class="title">INFINITY CONFIGURATION</div>
        <div class="mut" id="diffExplain">Maximum Relational G-Load ‚Ä¢ ~0.95+</div>
        <hr class="hr">
        <label>N-Back Level: <span id="nVal">1</span></label>
        <input id="nback" type="range" min="1" max="5" step="1" value="1">
        <hr class="hr">
        <label>Statements per trial: <span id="stmtVal">1</span></label>
        <input id="statements" type="range" min="1" max="3" step="1" value="1">
        <div class="mut">Multiple statements create cross-premise dependencies</div>
        <hr class="hr">
        <button id="instructionsBtn" class="btn instructions" style="width:100%; margin-top:10px">
          üìñ INFINITY MODE INSTRUCTIONS
        </button>
      </div>
    </div>

    <div class="col">
      <div class="box">
        <div class="title">TEMPORAL PARAMETERS</div>
        <div class="mut">Solve window: <strong><span id="solveLabel">8.0</span>s</strong> after speaking</div>
        <label>Solve window (1‚Äì30s): <span id="solveVal">8.0s</span></label>
        <input id="solveWindow" type="range" min="1" max="30" step="0.5" value="8">
        <label>Trials per block: <span id="tVal">100</span></label>
        <input id="trials" type="range" min="20" max="300" step="10" value="100">
        <label>Target match rate: <span id="rVal">25%</span></label>
        <input id="rate" type="range" min="10" max="40" step="5" value="25">
        <label><input id="speakEnabled" type="checkbox" checked> Voice synthesis</label>
      </div>
    </div>

    <div class="col">
      <div class="box">
        <div class="title">CONTROL MATRIX</div>
        <div style="display:flex; gap:8px; flex-wrap:wrap; margin-top:8px">
          <button id="start" class="btn">‚ñ∂ START</button>
          <button id="pause" class="btn" disabled>‚è∏ PAUSE</button>
          <button id="reset" class="btn" disabled>üîÑ RESET</button>
          <button id="hit" class="btn" disabled>‚úì MATCH [<span class="kbd">SPACE</span>]</button>
          <button id="skip" class="btn" disabled>‚è≠ SKIP</button>
        </div>
        <div class="mut" style="margin-top:12px">
          Trial <span id="idx">0</span>/<span id="max">100</span>
          <span class="badge">Target: <span id="ptype">‚Äî</span></span>
          <span class="badge">Actual: <span id="isMatch">‚Äî</span></span>
          <span class="badge">Timer: <span id="countdown">‚Äî</span></span>
        </div>
        <div class="mut" style="margin-top:8px">
          Correct: <span id="corr" style="color:var(--success)">0</span> ‚Ä¢ 
          Errors: <span id="err" style="color:var(--error)">0</span> ‚Ä¢ 
          Accuracy: <span id="accuracy">‚Äî</span>
        </div>
        <div class="mut" id="modeLine" style="margin-top:8px">
          <span class="infinity-indicator">‚àû</span> INFINITY MODE ‚Ä¢ G-Load: ~0.95+ ‚Ä¢ N=1
        </div>
      </div>
    </div>
  </div>

  <div class="box" style="margin-top:16px">
    <div class="title">
      RELATIONAL LATTICE STATE 
      <span class="badge">5 WORDS</span> 
      <span class="badge">7+ SYMBOLS</span>
      <span class="badge">DEEP SIMULATION REQUIRED</span>
    </div>
    <div id="premiseContainer" aria-live="polite">‚Äî</div>
  </div>
</div>

<!-- Instructions Modal -->
<div id="instructionsModal" class="modal">
  <div class="modal-content">
    <span class="close">&times;</span>
    <h2>üß† INFINITY N-BACK: MAXIMUM RELATIONAL G-LOAD</h2>
    
    <div class="warning">
      ‚ö†Ô∏è This mode requires simultaneous tracking of 7+ symbols across multiple transforming axes with latent propagation effects. Pattern matching will fail - only deep mental simulation can determine matches.
    </div>
    
    <h3>Core Concept: Relational Lattice States</h3>
    <p>Each 5-word premise encodes a <strong>complete relational universe</strong>:</p>
    <ul>
      <li><strong>7+ symbols</strong> compressed using operators (| for parallel, ‚Üí for sequence, ¬≤ for recursion)</li>
      <li><strong>Multi-axis transformations</strong> where axes themselves can merge, split, or invert</li>
      <li><strong>Cascading operations</strong> that propagate across symbols and time</li>
      <li><strong>Latent effects</strong> that only emerge after N steps</li>
      <li><strong>Inter-symbol dependencies</strong> where changing one affects all others</li>
    </ul>
    
    <h3>Understanding the 5-Word Format</h3>
    <div class="example">
      Œ±|Œ≤|Œ≥ spatial‚ü∑temporal Œ¥‚ÜíŒµ‚ÜíŒ∂ recursive¬≤-latent RESOLVES[10]
      
      Word 1: Œ±|Œ≤|Œ≥ = Three symbols in parallel state
      Word 2: spatial‚ü∑temporal = Axis transformation operator
      Word 3: Œ¥‚ÜíŒµ‚ÜíŒ∂ = Three symbols in sequence
      Word 4: recursive¬≤-latent = Propagation modifier
      Word 5: RESOLVES[10] = Resolution state with energy
    </div>
    
    <h3>MATCH Criteria - Complete Compatibility Required</h3>
    <p>A MATCH occurs <strong>only</strong> when ALL of the following align:</p>
    <ol>
      <li><strong>Symbol Trajectories:</strong> Every symbol's position and state must be compatible</li>
      <li><strong>Axis Consistency:</strong> Transformations of reference frames must align</li>
      <li><strong>Energy Conservation:</strong> Total energy must balance (¬±0.1 tolerance)</li>
      <li><strong>Phase Alignment:</strong> Quantum states must be able to coexist</li>
      <li><strong>No Latent Conflicts:</strong> No contradictions can emerge in future steps</li>
      <li><strong>Causal Coherence:</strong> No temporal paradoxes created</li>
      <li><strong>Recursive Stability:</strong> Self-referential operations must converge</li>
    </ol>
    
    <h3>NON-MATCH Criteria</h3>
    <p>ANY violation triggers NON-MATCH:</p>
    <ul>
      <li>Single symbol trajectory conflict</li>
      <li>Axis transformation incompatibility</li>
      <li>Energy violation beyond tolerance</li>
      <li>Phase states that cannot coexist</li>
      <li>Latent conflict that emerges later</li>
      <li>Causal paradox creation</li>
      <li>Recursive divergence</li>
    </ul>
    
    <h3>Examples: N-Back 1</h3>
    
    <h4>Single Statement per Trial:</h4>
    <div class="example">
      Trial 1: Œ±|Œ≤|Œ≥ dissolves-spatially Œ¥‚ÜíŒµ‚ÜíŒ∂ recursively¬≤ STABLE[5]
      Trial 2: Œ∑|Œ∏|Œ∫ crystallizes-temporally Œª‚ÜíŒº‚ÜíŒΩ fractally¬≥ UNSTABLE[-3]
    </div>
    <div class="explanation">
      <strong>NON-MATCH:</strong> 
      ‚Ä¢ Spatial dissolution (energy -5) vs temporal crystallization (energy +3) are incompatible
      ‚Ä¢ Recursive¬≤ propagation conflicts with fractally¬≥ pattern
      ‚Ä¢ Symbol Œ≥'s post-dissolution trajectory interferes with Œª's initial state
      ‚Ä¢ Axis mismatch: spatial cannot transform directly to temporal without intermediate state
    </div>
    
    <h4>Double Statements per Trial:</h4>
    <div class="example">
      Trial 1:
      [S1] Œ©|Œ®|Œ¶ inverts-axis Œõ|Œ£|Œ† cascading¬≤ RESOLVES[0]
      [S2] Œ±‚ÜíŒ≤‚ÜíŒ≥ stabilizes-all Œ¥|Œµ|Œ∂ latent-effect PENDING[?]
      
      Trial 2:
      [S1] Œ©¬≤|Œ®¬≤|Œ¶¬≤ reinverts-axis Œõ¬≤|Œ£¬≤|Œ†¬≤ cascading‚Å¥ RESOLVES[0]
      [S2] Œ±¬≤‚ÜíŒ≤¬≤‚ÜíŒ≥¬≤ destabilizes-all Œ¥¬≤|Œµ¬≤|Œ∂¬≤ immediate ACTIVE[!]
    </div>
    <div class="explanation">
      <strong>MATCH:</strong>
      ‚Ä¢ S1: Axis reinversion with squared symbols maintains compatibility (invert then reinvert = identity)
      ‚Ä¢ S1: Cascading‚Å¥ = (cascading¬≤)¬≤ preserves propagation pattern
      ‚Ä¢ S1: Energy remains at 0 in both cases
      ‚Ä¢ S2: Destabilization is the squared operation of stabilization
      ‚Ä¢ S2: The latent effect from Trial 1 activated in Trial 2 as "immediate"
      ‚Ä¢ All symbol trajectories align when traced through both transformations
    </div>
    
    <h3>Examples: N-Back 2</h3>
    <div class="example">
      Trial 1: A|B|C spatial-fold D‚ÜíE‚ÜíF quantum-tunnels STABLE[8]
      Trial 2: G|H|I temporal-twist J‚ÜíK‚ÜíL phase-shifts CHAOTIC[-2]
      Trial 3: A¬≤|B¬≤|C¬≤ spatial-unfold D¬≤‚ÜíE¬≤‚ÜíF¬≤ quantum-returns STABLE[8]
    </div>
    <div class="explanation">
      <strong>MATCH with Trial 1 (2-back):</strong>
      ‚Ä¢ Spatial-unfold reverses spatial-fold, returning to original state
      ‚Ä¢ Quantum-returns is the inverse of quantum-tunnels
      ‚Ä¢ Squared symbols indicate the transformation has been applied twice
      ‚Ä¢ Energy conserved at 8 in both stable states
      ‚Ä¢ No interference from Trial 2's temporal-twist (orthogonal axis)
    </div>
    
    <h3>Latent Effects & Propagation</h3>
    <div class="example">
      Trial N: X|Y|Z creates-latent A‚ÜíB‚ÜíC delay¬≥ DORMANT[0]
      Trial N+1: (any premise)
      Trial N+2: (any premise)
      Trial N+3: P|Q|R triggers-cascade S‚ÜíT‚ÜíU activates CONFLICT[-‚àû]
    </div>
    <div class="explanation">
      The latent effect created in Trial N remains dormant for exactly 3 trials (delay¬≥), 
      then activates when triggered, potentially causing conflicts with Trial N+3's premise.
      You must track these delayed effects mentally!
    </div>
    
    <h3>Critical Strategy for Success</h3>
    
    <h4>Step 1: Parse All Symbols</h4>
    <p>Extract all 7+ symbols from compressed notation:</p>
    <ul>
      <li>Œ±|Œ≤|Œ≥ = 3 symbols in parallel</li>
      <li>Œ¥‚ÜíŒµ‚ÜíŒ∂ = 3 symbols in sequence</li>
      <li>Plus any meta-symbols in modifiers</li>
    </ul>
    
    <h4>Step 2: Track State Evolution</h4>
    <p>For each symbol, track:</p>
    <ul>
      <li>Position on each axis (spatial, temporal, causal, etc.)</li>
      <li>Energy state</li>
      <li>Phase (solid, quantum, superposition, etc.)</li>
      <li>Connections to other symbols</li>
    </ul>
    
    <h4>Step 3: Simulate Transformations</h4>
    <p>Mentally execute each operation:</p>
    <ul>
      <li>How does "dissolves-spatially" change each symbol?</li>
      <li>What happens when axes merge or invert?</li>
      <li>Which propagation patterns cascade to other symbols?</li>
    </ul>
    
    <h4>Step 4: Check for Latent Conflicts</h4>
    <p>Project forward in time:</p>
    <ul>
      <li>Will this create a contradiction 2-3 steps later?</li>
      <li>Do any delayed effects interfere?</li>
      <li>Are there hidden dependencies that will emerge?</li>
    </ul>
    
    <h4>Step 5: Verify Complete Compatibility</h4>
    <p>Only declare MATCH if:</p>
    <ul>
      <li>ALL symbols' trajectories align</li>
      <li>ALL axes transform consistently</li>
      <li>Energy is conserved</li>
      <li>No latent conflicts exist</li>
      <li>Causal chains remain coherent</li>
    </ul>
    
    <div class="warning">
      ‚ö° CRITICAL: Word similarity means nothing! "Œ±|Œ≤|Œ≥" in Trial 1 and "Œ±|Œ≤|Œ≥" in Trial 2 
      may have completely different states after their transformations. You must simulate 
      the complete state evolution to determine matches.
    </div>
    
    <h3>Common Failure Modes</h3>
    <ul>
      <li><strong>Pattern Matching:</strong> Looking for similar words instead of simulating transformations</li>
      <li><strong>Ignoring Latent Effects:</strong> Not tracking delayed consequences</li>
      <li><strong>Axis Confusion:</strong> Not accounting for reference frame transformations</li>
      <li><strong>Partial Checking:</strong> Only verifying some symbols instead of all</li>
      <li><strong>Energy Neglect:</strong> Forgetting to track energy conservation</li>
    </ul>
    
    <p style="text-align:center; margin-top:30px; font-weight:bold; color:var(--accent)">
      Success requires holding the entire relational lattice in working memory 
      and simulating its complete evolution through time.
    </p>
  </div>
</div>

<script>
/* ============================================================
   INFINITY N-BACK: MAXIMUM RELATIONAL G-LOAD
   True 7+ symbol tracking with deep simulation requirement
   ============================================================ */

const $ = id => document.getElementById(id);
function setText(id,v){ const el=$(id); if(el) el.textContent=v; }
function shuffle(a){ for(let i=a.length-1;i>0;i--){ const j=(Math.random()*(i+1))|0; [a[i],a[j]]=[a[j],a[i]] } return a; }

/* ===== RELATIONAL LATTICE STATE TRACKER ===== */
class RelationalLattice {
  constructor() {
    this.symbolStates = new Map();
    this.axisStates = new Map();
    this.interactions = new Map();
    this.latentEffects = [];
    this.energyTotal = 0;
    this.timeStep = 0;
  }
  
  trackSymbol(symbol, state) {
    this.symbolStates.set(symbol, {
      position: state.position || {x:0, y:0, z:0, t:0},
      energy: state.energy || 0,
      phase: state.phase || 'neutral',
      trajectory: state.trajectory || [],
      connections: state.connections || new Set()
    });
  }
  
  trackAxis(axis, transformation) {
    this.axisStates.set(axis, {
      orientation: transformation.orientation || 'normal',
      stability: transformation.stability || 1.0,
      transformations: transformation.history || []
    });
  }
  
  addLatentEffect(effect) {
    this.latentEffects.push({
      trigger: this.timeStep + effect.delay,
      type: effect.type,
      symbols: effect.symbols,
      impact: effect.impact
    });
  }
  
  propagate() {
    this.timeStep++;
    
    // Check for triggered latent effects
    const triggered = this.latentEffects.filter(e => e.trigger === this.timeStep);
    for(const effect of triggered) {
      this.applyLatentEffect(effect);
    }
    
    // Cascade inter-symbol effects
    for(const [sym1, state1] of this.symbolStates) {
      for(const sym2 of state1.connections) {
        const state2 = this.symbolStates.get(sym2);
        if(state2) {
          // Energy transfer
          const delta = (state1.energy - state2.energy) * 0.1;
          state1.energy -= delta;
          state2.energy += delta;
        }
      }
    }
  }
  
  applyLatentEffect(effect) {
    for(const symbol of effect.symbols) {
      const state = this.symbolStates.get(symbol);
      if(state) {
        state.energy += effect.impact.energy || 0;
        state.phase = effect.impact.phase || state.phase;
      }
    }
  }
  
  getTotalEnergy() {
    let total = 0;
    for(const [_, state] of this.symbolStates) {
      total += state.energy;
    }
    return total;
  }
  
  clone() {
    const copy = new RelationalLattice();
    copy.symbolStates = new Map(this.symbolStates);
    copy.axisStates = new Map(this.axisStates);
    copy.interactions = new Map(this.interactions);
    copy.latentEffects = [...this.latentEffects];
    copy.energyTotal = this.energyTotal;
    copy.timeStep = this.timeStep;
    return copy;
  }
}

/* ===== INFINITY PREMISE GENERATOR ===== */
class InfinityPremiseGenerator {
  constructor() {
    // Greek symbols for primary entities
    this.greekSymbols = ['Œ±','Œ≤','Œ≥','Œ¥','Œµ','Œ∂','Œ∑','Œ∏','Œ∫','Œª','Œº','ŒΩ','Œæ','œÄ','œÅ','œÉ','œÑ','œÜ','œá','œà','œâ'];
    this.capitalGreek = ['Œ©','Œ®','Œ¶','Œõ','Œ£','Œ†','Œî','Œò','Œì'];
    
    // Transformation operations
    this.operations = {
      spatial: ['dissolves', 'crystallizes', 'fragments', 'coalesces', 'disperses', 'compacts'],
      temporal: ['accelerates', 'decelerates', 'reverses', 'loops', 'freezes', 'dilates'],
      causal: ['inverts', 'negates', 'affirms', 'branches', 'merges', 'isolates'],
      quantum: ['entangles', 'collapses', 'superimposes', 'tunnels', 'phases', 'interferes'],
      energetic: ['amplifies', 'dampens', 'transfers', 'absorbs', 'radiates', 'equilibrates']
    };
    
    // Axes that can transform
    this.axes = ['spatial', 'temporal', 'causal', 'quantum', 'energetic', 'informational'];
    
    // Propagation patterns
    this.propagations = ['recursively', 'fractally', 'cascading', 'exponentially', 'logarithmically', 'chaotically'];
    
    // Resolution states
    this.resolutions = ['STABLE', 'UNSTABLE', 'RESOLVES', 'CONFLICTS', 'PENDING', 'DORMANT', 'ACTIVE', 'CRITICAL'];
    
    // Session tracking
    this.usedPremises = new Set();
    this.premiseCount = 0;
    this.latticeHistory = [];
  }
  
  generatePremise(trial, nback, count = 1) {
    const premises = [];
    
    for(let i = 0; i < count; i++) {
      let premise;
      let attempts = 0;
      
      do {
        premise = this.buildInfinityPremise(trial + attempts * 1000 + i);
        attempts++;
      } while(this.isDuplicate(premise.text) && attempts < 50);
      
      this.usedPremises.add(premise.text);
      premises.push(premise);
      this.premiseCount++;
    }
    
    return premises;
  }
  
  buildInfinityPremise(seed) {
    // Use crypto for true randomness
    const random = () => {
      if(window.crypto) {
        const arr = new Uint32Array(1);
        window.crypto.getRandomValues(arr);
        return arr[0] / 0xFFFFFFFF;
      }
      return Math.random();
    };
    
    // Select pattern based on random
    const pattern = Math.floor(random() * 4);
    let text = '';
    
    switch(pattern) {
      case 0: // Standard: cluster transform cluster propagation resolution
        text = this.buildStandardPattern(seed, random);
        break;
      case 1: // Axis inversion pattern
        text = this.buildAxisPattern(seed, random);
        break;
      case 2: // Latent effect pattern
        text = this.buildLatentPattern(seed, random);
        break;
      case 3: // Meta-recursive pattern
        text = this.buildMetaPattern(seed, random);
        break;
    }
    
    // Ensure exactly 5 words
    const words = text.split(' ').filter(w => w.length > 0);
    if(words.length !== 5) {
      console.error(`Premise has ${words.length} words:`, text);
      // Fallback to ensure 5 words
      text = this.buildFallbackPremise(seed, random);
    }
    
    // Extract deep structure
    const structure = this.extractStructure(text);
    
    return {
      text: text,
      structure: structure,
      pattern: pattern,
      seed: seed
    };
  }
  
  buildStandardPattern(seed, random) {
    // Word 1: 3-4 symbols in cluster
    const sym1 = this.greekSymbols[Math.floor(random() * this.greekSymbols.length)];
    const sym2 = this.greekSymbols[Math.floor(random() * this.greekSymbols.length)];
    const sym3 = this.greekSymbols[Math.floor(random() * this.greekSymbols.length)];
    const cluster1 = `${sym1}|${sym2}|${sym3}`;
    
    // Word 2: operation with axis
    const axisType = this.axes[Math.floor(random() * this.axes.length)];
    const ops = this.operations[axisType] || this.operations.spatial;
    const op = ops[Math.floor(random() * ops.length)];
    const compound = `${op}-${axisType}ly`;
    
    // Word 3: target cluster in sequence
    const sym4 = this.greekSymbols[Math.floor(random() * this.greekSymbols.length)];
    const sym5 = this.greekSymbols[Math.floor(random() * this.greekSymbols.length)];
    const sym6 = this.greekSymbols[Math.floor(random() * this.greekSymbols.length)];
    const cluster2 = `${sym4}‚Üí${sym5}‚Üí${sym6}`;
    
    // Word 4: propagation with modifier
    const prop = this.propagations[Math.floor(random() * this.propagations.length)];
    const power = Math.floor(random() * 3) + 2;
    const propMod = `${prop}${power}`;
    
    // Word 5: resolution with energy
    const res = this.resolutions[Math.floor(random() * this.resolutions.length)];
    const energy = Math.floor(random() * 21) - 10;
    const resolution = `${res}[${energy}]`;
    
    return `${cluster1} ${compound} ${cluster2} ${propMod} ${resolution}`;
  }
  
  buildAxisPattern(seed, random) {
    // Word 1: Capital greek cluster with power
    const sym1 = this.capitalGreek[Math.floor(random() * this.capitalGreek.length)];
    const sym2 = this.capitalGreek[Math.floor(random() * this.capitalGreek.length)];
    const power = Math.floor(random() * 2) + 2;
    const cluster1 = `${sym1}${power}|${sym2}${power}`;
    
    // Word 2: axis transformation
    const axis1 = this.axes[Math.floor(random() * this.axes.length)];
    const axis2 = this.axes[Math.floor(random() * this.axes.length)];
    const axisTrans = `${axis1}‚ü∑${axis2}`;
    
    // Word 3: affected symbols
    const sym3 = this.greekSymbols[Math.floor(random() * this.greekSymbols.length)];
    const sym4 = this.greekSymbols[Math.floor(random() * this.greekSymbols.length)];
    const sym5 = this.greekSymbols[Math.floor(random() * this.greekSymbols.length)];
    const cluster2 = `${sym3}|${sym4}|${sym5}`;
    
    // Word 4: cascade type
    const cascade = random() > 0.5 ? 'cascade-inverts' : 'propagate-negates';
    
    // Word 5: state
    const state = random() > 0.5 ? 'PARADOX[‚àû]' : 'VOID[0]';
    
    return `${cluster1} ${axisTrans} ${cluster2} ${cascade} ${state}`;
  }
  
  buildLatentPattern(seed, random) {
    // Word 1: Initial cluster
    const sym1 = this.greekSymbols[Math.floor(random() * this.greekSymbols.length)];
    const sym2 = this.greekSymbols[Math.floor(random() * this.greekSymbols.length)];
    const cluster1 = `${sym1}‚Üí${sym2}`;
    
    // Word 2: latent operation
    const operations = ['creates-latent', 'delays-effect', 'stores-potential', 'queues-cascade'];
    const op = operations[Math.floor(random() * operations.length)];
    
    // Word 3: target symbols
    const sym3 = this.capitalGreek[Math.floor(random() * this.capitalGreek.length)];
    const sym4 = this.capitalGreek[Math.floor(random() * this.capitalGreek.length)];
    const sym5 = this.capitalGreek[Math.floor(random() * this.capitalGreek.length)];
    const cluster2 = `${sym3}|${sym4}|${sym5}`;
    
    // Word 4: delay specification
    const delay = Math.floor(random() * 4) + 1;
    const delaySpec = `after-${delay}-cycles`;
    
    // Word 5: pending state
    const pending = ['DORMANT[0]', 'WAITING[?]', 'ARMED[!]', 'TIMED[' + delay + ']'];
    const state = pending[Math.floor(random() * pending.length)];
    
    return `${cluster1} ${op} ${cluster2} ${delaySpec} ${state}`;
  }
  
  buildMetaPattern(seed, random) {
    // Word 1: Meta reference
    const metaRefs = ['IT¬≤', 'ITSELF¬≥', 'PRIOR¬≤', 'ALL‚àû'];
    const ref = metaRefs[Math.floor(random() * metaRefs.length)];
    
    // Word 2: recursive operation
    const ops = ['re-entangles', 'self-modifies', 'auto-inverts', 'meta-cascades'];
    const op = ops[Math.floor(random() * ops.length)];
    
    // Word 3: through what
    const sym1 = this.greekSymbols[Math.floor(random() * this.greekSymbols.length)];
    const sym2 = this.greekSymbols[Math.floor(random() * this.greekSymbols.length)];
    const through = `${sym1}‚ü∑${sym2}`;
    
    // Word 4: recursion type
    const recursion = ['infinitely-deep', 'fractally-nested', 'paradoxically', 'anti-structurally'];
    const recType = recursion[Math.floor(random() * recursion.length)];
    
    // Word 5: convergence
    const convergence = random() > 0.5 ? 'CONVERGES[1]' : 'DIVERGES[‚àû]';
    
    return `${ref} ${op} ${through} ${recType} ${convergence}`;
  }
  
  buildFallbackPremise(seed, random) {
    // Guaranteed 5 words
    const s1 = this.greekSymbols[Math.floor(random() * 10)];
    const s2 = this.greekSymbols[Math.floor(random() * 10) + 10];
    const op = this.operations.spatial[Math.floor(random() * 3)];
    const prop = this.propagations[Math.floor(random() * 3)];
    const res = this.resolutions[Math.floor(random() * 4)];
    
    return `${s1}|${s2} ${op} TARGET ${prop} ${res}[0]`;
  }
  
  extractStructure(text) {
    const structure = {
      symbols: [],
      axes: [],
      operations: [],
      propagation: null,
      energy: 0,
      phase: 'neutral',
      latentDelay: 0,
      recursionDepth: 0
    };
    
    // Extract all Greek symbols
    const greekRegex = /[Œ±-œâŒë-Œ©]/g;
    const symbols = text.match(greekRegex) || [];
    structure.symbols = [...new Set(symbols)];
    
    // Extract axes
    for(const axis of this.axes) {
      if(text.includes(axis)) {
        structure.axes.push(axis);
      }
    }
    
    // Extract operations
    for(const category in this.operations) {
      for(const op of this.operations[category]) {
        if(text.includes(op)) {
          structure.operations.push({op, category});
        }
      }
    }
    
    // Extract energy from brackets
    const energyMatch = text.match(/\[([^\]]+)\]/);
    if(energyMatch) {
      const value = energyMatch[1];
      if(value === '‚àû') structure.energy = Infinity;
      else if(value === '?') structure.energy = null;
      else if(value === '!') structure.energy = -Infinity;
      else structure.energy = parseFloat(value) || 0;
    }
    
    // Extract recursion depth
    const recursionMatch = text.match(/[¬≤¬≥‚Å¥‚àû]/);
    if(recursionMatch) {
      const power = recursionMatch[0];
      structure.recursionDepth = power === '¬≤' ? 2 : power === '¬≥' ? 3 : power === '‚Å¥' ? 4 : Infinity;
    }
    
    // Extract latent delay
    const delayMatch = text.match(/after-(\d+)-cycles/);
    if(delayMatch) {
      structure.latentDelay = parseInt(delayMatch[1]);
    }
    
    // Determine phase from resolution state
    if(text.includes('STABLE')) structure.phase = 'stable';
    else if(text.includes('UNSTABLE')) structure.phase = 'unstable';
    else if(text.includes('PARADOX')) structure.phase = 'paradox';
    else if(text.includes('VOID')) structure.phase = 'void';
    else if(text.includes('DORMANT')) structure.phase = 'dormant';
    
    return structure;
  }
  
  isDuplicate(text) {
    return this.usedPremises.has(text);
  }
  
  // Deep compatibility checking through complete simulation
  checkDeepCompatibility(p1, p2) {
    const s1 = p1.structure;
    const s2 = p2.structure;
    
    if(!s1 || !s2) return false;
    
    // Create lattice states for simulation
    const lattice1 = new RelationalLattice();
    const lattice2 = new RelationalLattice();
    
    // Load symbols into lattices
    for(const sym of s1.symbols) {
      lattice1.trackSymbol(sym, {energy: s1.energy / s1.symbols.length, phase: s1.phase});
    }
    for(const sym of s2.symbols) {
      lattice2.trackSymbol(sym, {energy: s2.energy / s2.symbols.length, phase: s2.phase});
    }
    
    // Simulate propagation
    for(let i = 0; i < (s1.recursionDepth || 1); i++) {
      lattice1.propagate();
    }
    for(let i = 0; i < (s2.recursionDepth || 1); i++) {
      lattice2.propagate();
    }
    
    // Check compatibility across all dimensions
    let compatibilityScore = 0;
    const checks = {
      symbolOverlap: this.checkSymbolCompatibility(s1.symbols, s2.symbols),
      axisAlignment: this.checkAxisAlignment(s1.axes, s2.axes),
      energyConservation: Math.abs(lattice1.getTotalEnergy() - lattice2.getTotalEnergy()) < 1,
      phaseCompatibility: this.checkPhaseCompatibility(s1.phase, s2.phase),
      operationCompatibility: this.checkOperationCompatibility(s1.operations, s2.operations),
      recursionAlignment: Math.abs((s1.recursionDepth || 1) - (s2.recursionDepth || 1)) <= 1,
      noLatentConflict: s1.latentDelay === 0 || s2.latentDelay === 0 || 
                       Math.abs(s1.latentDelay - s2.latentDelay) > 2
    };
    
    // Count passing checks
    for(const check in checks) {
      if(checks[check]) compatibilityScore++;
    }
    
    // Require at least 5 of 7 checks to pass for MATCH
    return compatibilityScore >= 5;
  }
  
  checkSymbolCompatibility(syms1, syms2) {
    // Check if symbol sets have reasonable overlap or complementarity
    const set1 = new Set(syms1);
    const set2 = new Set(syms2);
    const intersection = [...set1].filter(s => set2.has(s));
    
    // Either significant overlap OR completely disjoint (complementary)
    return intersection.length >= Math.min(syms1.length, syms2.length) / 2 ||
           intersection.length === 0;
  }
  
  checkAxisAlignment(axes1, axes2) {
    if(axes1.length === 0 || axes2.length === 0) return true;
    
    // Check if axes are compatible (same, orthogonal, or transformable)
    const compatiblePairs = {
      'spatial': ['spatial', 'temporal'],
      'temporal': ['temporal', 'spatial', 'causal'],
      'causal': ['causal', 'temporal', 'quantum'],
      'quantum': ['quantum', 'causal', 'energetic'],
      'energetic': ['energetic', 'quantum', 'informational'],
      'informational': ['informational', 'energetic']
    };
    
    for(const a1 of axes1) {
      for(const a2 of axes2) {
        if(compatiblePairs[a1] && compatiblePairs[a1].includes(a2)) {
          return true;
        }
      }
    }
    return false;
  }
  
  checkPhaseCompatibility(phase1, phase2) {
    const incompatible = [
      ['stable', 'unstable'],
      ['void', 'stable'],
      ['paradox', 'stable']
    ];
    
    for(const [p1, p2] of incompatible) {
      if((phase1 === p1 && phase2 === p2) || (phase1 === p2 && phase2 === p1)) {
        return false;
      }
    }
    return true;
  }
  
  checkOperationCompatibility(ops1, ops2) {
    if(ops1.length === 0 || ops2.length === 0) return true;
    
    // Check if operations can coexist
    const hasInverse = (ops1.some(o => o.op.includes('invert')) && 
                       ops2.some(o => o.op.includes('invert')));
    const hasDissolve = (ops1.some(o => o.op.includes('dissolve')) && 
                        ops2.some(o => o.op.includes('crystallize')));
    
    return !hasInverse || hasDissolve;
  }
  
  reset() {
    this.usedPremises.clear();
    this.premiseCount = 0;
    this.latticeHistory = [];
  }
}

/* ===== Global State ===== */
const premiseGenerator = new InfinityPremiseGenerator();
let MAX=100, RATE=25, N=1, SPEAK=true, SOLVE_WINDOW=8.0, STATEMENTS=1;

/* ===== Session Management ===== */
let idx=0, correct=0, errors=0, planned=[], history=[], SESSION={running:false, paused:false};
let currentTruth=false, responded=false, solveTimer=null, countdownTimer=null, countdownLeft=0;

function planSequence(){ 
  planned.length=MAX; 
  for(let i=0;i<MAX;i++) planned[i]=false; 
  const elig=[]; 
  for(let i=N;i<MAX;i++) elig.push(i); 
  const k=Math.round((RATE/100)*elig.length); 
  shuffle(elig); 
  for(let i=0;i<k;i++) planned[elig[i]]=true; 
}

function showPremises(premises) {
  const container = $('premiseContainer');
  container.innerHTML = '';
  
  const arr = Array.isArray(premises) ? premises : [premises];
  
  arr.forEach((p, i) => {
    const div = document.createElement('div');
    div.className = 'premise-line';
    
    if(arr.length > 1) {
      const num = document.createElement('span');
      num.className = 'premise-number';
      num.textContent = `S${i+1}`;
      div.appendChild(num);
    }
    
    const text = p.text || p;
    const words = text.split(' ');
    
    // Style each word appropriately
    words.forEach((word, idx) => {
      const span = document.createElement('span');
      
      // Determine word type and apply styling
      if(word.match(/[Œ±-œâŒë-Œ©|‚Üí‚ü∑¬≤¬≥‚Å¥‚àû]/)) {
        span.className = 'symbol-cluster';
      } else if(word.includes('-') && word.includes('ly')) {
        span.className = 'transform-op';
      } else if(word.includes('‚ü∑')) {
        span.className = 'axis-mod';
      } else if(word.match(/recursively|fractally|cascading|exponentially/)) {
        span.className = 'propagation';
      } else if(word.match(/STABLE|UNSTABLE|RESOLVES|CONFLICTS|PENDING|DORMANT|ACTIVE|CRITICAL|PARADOX|VOID|CONVERGES|DIVERGES/)) {
        span.className = 'resolution';
      } else if(word.includes('latent') || word.includes('delay') || word.includes('after')) {
        span.className = 'latent';
      } else {
        span.className = 'transform-op';
      }
      
      span.textContent = word;
      div.appendChild(span);
      
      if(idx < words.length - 1) {
        div.appendChild(document.createTextNode(' '));
      }
    });
    
    // Add structure metadata
    if(p.structure) {
      const meta = document.createElement('div');
      meta.className = 'meta-info';
      
      const info = [
        `Symbols: ${p.structure.symbols.length} [${p.structure.symbols.slice(0,5).join(',')}${p.structure.symbols.length > 5 ? '...' : ''}]`,
        `Axes: ${p.structure.axes.join(',') || 'neutral'}`,
        `Operations: ${p.structure.operations.length}`,
        `Energy: ${p.structure.energy === Infinity ? '‚àû' : p.structure.energy === -Infinity ? '-‚àû' : p.structure.energy}`,
        `Phase: ${p.structure.phase}`,
        p.structure.recursionDepth ? `Recursion: ${p.structure.recursionDepth === Infinity ? '‚àû' : p.structure.recursionDepth}` : '',
        p.structure.latentDelay ? `Latent: ${p.structure.latentDelay} cycles` : ''
      ].filter(s => s);
      
      meta.textContent = info.join(' ‚Ä¢ ');
      div.appendChild(meta);
    }
    
    container.appendChild(div);
  });
}

function updateUI(){ 
  setText('idx', idx); 
  setText('max', MAX); 
  setText('ptype', (idx<MAX && idx>=N && planned[idx])?'MATCH':'NON-MATCH'); 
  setText('corr', correct); 
  setText('err', errors); 
  setText('isMatch','‚Äî'); 
  
  // Calculate and show accuracy
  const total = correct + errors;
  if(total > 0) {
    const acc = ((correct / total) * 100).toFixed(1);
    setText('accuracy', `${acc}%`);
  } else {
    setText('accuracy', '‚Äî');
  }
}

async function speak(text){
  if(!SPEAK) return Promise.resolve();
  if(typeof window==='undefined'||!('speechSynthesis' in window)) return Promise.resolve();
  
  const speakText = Array.isArray(text) ? 
    text.map(p => {
      const t = p.text || p;
      // Clean up for speech - remove special characters
      return t.replace(/[|‚Üí‚ü∑¬≤¬≥‚Å¥‚àû\[\]]/g, ' ').replace(/[Œ±-œâ]/g, s => {
        const names = {
          'Œ±':'alpha','Œ≤':'beta','Œ≥':'gamma','Œ¥':'delta','Œµ':'epsilon',
          'Œ∂':'zeta','Œ∑':'eta','Œ∏':'theta','Œ∫':'kappa','Œª':'lambda',
          'Œº':'mu','ŒΩ':'nu','Œæ':'xi','œÄ':'pi','œÅ':'rho',
          'œÉ':'sigma','œÑ':'tau','œÜ':'phi','œá':'chi','œà':'psi','œâ':'omega'
        };
        return names[s] || s;
      });
    }).join('. ') :
    (text.text || text);
    
  return new Promise(res=>{ 
    try{ 
      const u=new SpeechSynthesisUtterance(speakText); 
      u.lang='en-US'; 
      u.rate=0.75; // Slower for complex content
      u.pitch=1.0; 
      u.volume=1.0; 
      u.onend=()=>res(); 
      u.onerror=()=>res(); 
      if(window.speechSynthesis.speaking) window.speechSynthesis.cancel(); 
      window.speechSynthesis.speak(u); 
    }catch{ 
      res(); 
    } 
  });
}

function scheduleCountdown(sec){ 
  countdownLeft=sec; 
  setText('countdown', countdownLeft.toFixed(1)+'s'); 
  if(countdownTimer) clearInterval(countdownTimer); 
  countdownTimer=setInterval(()=>{ 
    countdownLeft=Math.max(0,countdownLeft-0.1); 
    setText('countdown', countdownLeft.toFixed(1)+'s'); 
    if(countdownLeft<=0){ 
      clearInterval(countdownTimer); 
      countdownTimer=null; 
    } 
  },100); 
}

function evaluateAndAdvance(){ 
  const resp=responded, truth=currentTruth; 
  if(resp===truth) correct++; 
  else errors++; 
  setText('corr',correct); 
  setText('err',errors); 
  setText('isMatch', truth ? 'MATCH' : 'NON-MATCH'); 
  
  // Update accuracy
  const total = correct + errors;
  const acc = ((correct / total) * 100).toFixed(1);
  setText('accuracy', `${acc}%`);
  
  idx++; 
  if(idx>=MAX){ 
    stop(); 
    return; 
  } 
  runTrial(); 
}

function runTrial(){
  if(!SESSION.running || SESSION.paused) return;
  
  const mustMatch = (idx>=N) && planned[idx];
  
  let premises = premiseGenerator.generatePremise(idx, N, STATEMENTS);
  
  if(idx >= N) {
    const reference = history[idx-N];
    
    if(mustMatch) {
      // Try to generate compatible premise
      let attempts = 0;
      let compatible = false;
      
      while(!compatible && attempts < 30) {
        premises = premiseGenerator.generatePremise(idx * 1000 + attempts, N, STATEMENTS);
        compatible = premiseGenerator.checkDeepCompatibility(premises[0], reference[0]);
        attempts++;
      }
      
      currentTruth = true; // Force match as planned
    } else {
      // Check for accidental compatibility
      const compatible = premiseGenerator.checkDeepCompatibility(premises[0], reference[0]);
      
      if(compatible) {
        // Try to generate incompatible premise
        let attempts = 0;
        while(compatible && attempts < 20) {
          premises = premiseGenerator.generatePremise(idx * 7919 + attempts, N, STATEMENTS);
          if(!premiseGenerator.checkDeepCompatibility(premises[0], reference[0])) {
            break;
          }
          attempts++;
        }
      }
      
      currentTruth = false; // Force non-match as planned
    }
  } else {
    currentTruth = false; // No match possible before N-back threshold
  }
  
  history[idx] = premises;
  showPremises(premises); 
  responded=false;
  
  setText('isMatch','‚Äî'); 
  setText('ptype', (idx<MAX && idx>=N && planned[idx])?'MATCH':'NON-MATCH');

  speak(premises).then(()=>{ 
    scheduleCountdown(SOLVE_WINDOW); 
    if(solveTimer) clearTimeout(solveTimer); 
    solveTimer=setTimeout(()=>{ 
      evaluateAndAdvance(); 
    }, SOLVE_WINDOW*1000); 
  });
}

/* Controls */
function start(){
  MAX=+$('trials').value||100; 
  RATE=+$('rate').value||25; 
  N=+$('nback').value||1; 
  STATEMENTS=+$('statements').value||1;
  SPEAK=!!$('speakEnabled').checked;
  SOLVE_WINDOW=+($('solveWindow').value||8); 
  setText('solveLabel', SOLVE_WINDOW.toFixed(1)); 
  setText('solveVal', SOLVE_WINDOW.toFixed(1)+'s');
  
  // Reset generator
  premiseGenerator.reset();

  idx=0; 
  correct=0; 
  errors=0; 
  planned=[]; 
  history=[]; 
  planSequence(); 
  updateUI();
  SESSION.running=true; 
  SESSION.paused=false;
  $('pause').disabled=false; 
  $('reset').disabled=false; 
  $('hit').disabled=false; 
  $('skip').disabled=false;
  runTrial();
}

function stop(){ 
  SESSION.running=false; 
  SESSION.paused=false; 
  if(solveTimer) clearTimeout(solveTimer); 
  if(countdownTimer) clearInterval(countdownTimer); 
  setText('countdown','‚Äî'); 
  try{ 
    if(window.speechSynthesis) window.speechSynthesis.cancel(); 
  }catch{} 
}

function togglePause(){
  if(!SESSION.running) return;
  SESSION.paused=!SESSION.paused; 
  $('pause').textContent=SESSION.paused?'‚ñ∂ RESUME':'‚è∏ PAUSE';
  if(SESSION.paused){ 
    if(solveTimer) clearTimeout(solveTimer); 
    if(countdownTimer) clearInterval(countdownTimer); 
    try{ 
      if(window.speechSynthesis) window.speechSynthesis.cancel(); 
    }catch{} 
  }
  else{
    scheduleCountdown(countdownLeft>0?countdownLeft:SOLVE_WINDOW);
    if(solveTimer) clearTimeout(solveTimer);
    solveTimer=setTimeout(()=>{ 
      evaluateAndAdvance(); 
    }, (countdownLeft>0?countdownLeft:SOLVE_WINDOW)*1000);
  }
}

function reset(){ 
  stop(); 
  premiseGenerator.reset();
  
  $('premiseContainer').innerHTML='‚Äî'; 
  setText('idx',0); 
  setText('corr',0); 
  setText('err',0); 
  setText('ptype','‚Äî'); 
  setText('isMatch','‚Äî'); 
  setText('accuracy','‚Äî');
}

function registerHit(){ 
  if(!SESSION.running || SESSION.paused) return; 
  responded=true; 
}

function skip(){ 
  if(!SESSION.running || SESSION.paused) return; 
  if(solveTimer) clearTimeout(solveTimer); 
  if(countdownTimer) clearInterval(countdownTimer); 
  setText('countdown','‚Äî'); 
  evaluateAndAdvance(); 
}

/* Event Bindings */
document.addEventListener('DOMContentLoaded', ()=>{
  // Instructions modal
  const modal = $('instructionsModal');
  const btn = $('instructionsBtn');
  const span = document.querySelector('.close');
  
  btn.onclick = () => { modal.style.display = 'block'; };
  span.onclick = () => { modal.style.display = 'none'; };
  window.onclick = (e) => {
    if(e.target === modal) modal.style.display = 'none';
  };
  
  // Settings
  const sw=$('solveWindow'); 
  const updateSW=()=>{ 
    const v=+sw.value; 
    setText('solveVal', v.toFixed(1)+'s'); 
    setText('solveLabel', v.toFixed(1)); 
  };
  updateSW(); 
  sw.oninput=e=>{ 
    if(!SESSION.running){ 
      updateSW(); 
    } 
  };
  
  $('nback').oninput=e=>{ 
    if(!SESSION.running){ 
      N=+e.target.value; 
      setText('nVal',N); 
      setText('modeLine',`‚àû INFINITY MODE ‚Ä¢ G-Load: ~0.95+ ‚Ä¢ N=${N}`);
    } 
  };
  
  $('statements').oninput=e=>{ 
    if(!SESSION.running){ 
      STATEMENTS=+e.target.value; 
      setText('stmtVal',STATEMENTS); 
    } 
  };
  
  $('trials').oninput=e=>{ 
    if(!SESSION.running){ 
      MAX=+e.target.value; 
      setText('tVal',MAX); 
      setText('max',MAX); 
    } 
  };
  
  $('rate').oninput=e=>{ 
    if(!SESSION.running){ 
      RATE=+e.target.value; 
      setText('rVal',RATE+'%'); 
    } 
  };
  
  $('speakEnabled').onchange=e=>{ 
    SPEAK=!!e.target.checked; 
  };

  $('start').onclick=start; 
  $('pause').onclick=togglePause; 
  $('reset').onclick=reset; 
  $('hit').onclick=registerHit; 
  $('skip').onclick=skip;
  
  window.addEventListener('keydown', e=>{ 
    if(!SESSION.running) return; 
    if(e.code==='Space'){ 
      registerHit(); 
      e.preventDefault(); 
    } 
  });

  setText('nVal',N); 
  setText('stmtVal',STATEMENTS);
  setText('tVal',MAX); 
  setText('rVal',RATE+'%');
  setText('modeLine',`‚àû INFINITY MODE ‚Ä¢ G-Load: ~0.95+ ‚Ä¢ N=${N}`);
  updateUI();
});
</script>
</body>
</html>
