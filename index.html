# PROMPT FOR CODEX — PREMISE ENGINE UPGRADE: POLYMORPHIC DIGITS + LATENT ROTATION + HASHED LINES + STRICT NOVELTY (≤7 WORDS)

Target: index.html (Imagi-World)

GOALS
- Keep premises ≤7 words on surface.
- Digits are polymorphic (not “intensity only”).
- Binary ops weight the next operand asymmetrically.
- Latent rotation injected by digits under rotation context.
- Line endpoints vary per run via salted hashing.
- No surface or structural repeats within session; different sequence each Start.
- Preserve existing UI, TTS, N-back state-hash semantics.

----------------------------------------------------------------
A) INSERT CORE MAPS + PRIMALITY + SALT UTILITIES (once)
----------------------------------------------------------------
Right BEFORE your arithmetic/geometry parsers, insert:

<script>
// === Context maps and helpers ===
const ANGLE_MAP = {2:36, 3:54, 4:72, 5:108, 6:144};
const SCALE_RATIO = {2:[3,1], 3:[2,1], 4:[5,2], 5:[3,2], 6:[5,1]};
function isPrime(n){return n===2||n===3||n===5;}
function isEven(n){return (n%2)===0;}
function clampPhase(p){return ((p%360)+360)%360;}

// per-run salt for variability (reuse if you already have one)
(function(){
  const K='iw_salt_v2';
  if(!localStorage.getItem(K)){
    const r=(crypto&&crypto.getRandomValues)?(crypto.getRandomValues(new Uint32Array(1))[0]>>>0):(Date.now()>>>0);
    localStorage.setItem(K,String(r));
  }
  window.IW_SALT = parseInt(localStorage.getItem(K)||'0',10)>>>0;
})();
function Phi(idx){ // salted letter picker for lines
  const base = (IW_SALT + idx*17) % 26;
  return 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'[base];
}
</script>

----------------------------------------------------------------
B) ADD DIGIT ROLE ENGINE (single function)
----------------------------------------------------------------
Insert after A):

<script>
/**
 * Apply a digit's polymorphic role to the given letter state.
 * ctx = { kind: 'arith'|'geom'|'lattice'|'scale'|'rotate'|'project'|'reflect'|'none',
 *         nextToken?:string, prevToken?:string }
 * S is the canonical store; L is letter key.
 */
function applyDigitRole(S, L, d, ctx){
  d = Math.max(0, Math.min(9, parseInt(d,10)||0));
  if(!d || !S[L]) return;

  // 1) Context-gated primary effect
  if(ctx.kind==='scale' && SCALE_RATIO[d]){
    // store intended ratio on the letter (consumed by scale op)
    S[L]._ratio = SCALE_RATIO[d]; // [num,den]
  } else if((ctx.kind==='rotate' || ctx.kind==='geom') && ANGLE_MAP[d]){
    // queue a latent rotation angle (consumed by the next rotate or by context)
    S[L]._latentRot = ANGLE_MAP[d];
  } else if(ctx.kind==='lattice'){
    S[L]._step = d; // lattice step magnitude
  } else if(ctx.kind==='arith'){
    // in arithmetic, the digit is a weight applied to the NEXT operand
    S[L]._weightNext = (d||1);
  } else if(ctx.kind==='project'){
    // choose hashed endpoints indices from d; small deterministic spread
    S[L]._linePick = [ (d+1), (d+7) ];
  } else {
    // fallback: mild intensity bump to avoid "no-op"
    S[L].intensity *= (1 + 0.15*d);
  }

  // 2) Parity → orientation flip post local op
  if(isEven(d)){ S[L] = T.invert(S[L]); }

  // 3) Prime/composite side-channel
  if(isPrime(d)){ S[L].level += 1; }
  else if(d>1){ S[L].phase = clampPhase((S[L].phase||0)+45); }
}
</script>

----------------------------------------------------------------
C) UPGRADE ARITHMETIC PARSER TO USE DIGIT ROLES + ASYMMETRY
----------------------------------------------------------------
FIND your function `applyArithPremise(S0, text){ ... }` and REPLACE its body with:

{
  const S = cloneStore(S0);
  // Tokenize: keep operators separate
  let toks = text
    .replace(/—|–/g,'-')
    .replace(/([+\-×÷*/^()])/g,' $1 ')
    .replace(/\s+/g,' ')
    .trim()
    .split(' ')
    .filter(Boolean);

  // Pass 1: unary stacks and letter^k, √L, inverted L
  for(let i=0;i<toks.length;i++){
    let t=toks[i];

    // √L
    if(/^√[A-Z]$/.test(t)){ const L=t.slice(1); S[L]=T.sqrt(S[L]); toks[i]=L; continue; }

    // inverted L
    if(t.toLowerCase()==='inverted' && /^[A-Z]$/.test(toks[i+1]||'')){ const L=toks[i+1]; S[L]=T.invert(S[L]); }

    // A^k ⇒ level +k
    if(/^[A-Z]\^\d+$/.test(t)){ const [L,exp]=t.split('^'); S[L]=T.powLevel(S[L], parseInt(exp,10)||1); toks[i]=L; }
  }

  // Pass 2: letter-digit suffix roles (A2, B3...)
  // Detect coarse context from neighbors to drive applyDigitRole
  function contextAt(idx){
    const prev = toks[idx-1]||'';
    const next = toks[idx+1]||'';
    let kind='arith';
    if(/\b(rotate\d*|rotate)\b/i.test(text)) kind='rotate';
    return {kind, prevToken:prev, nextToken:next};
  }
  for(let i=0;i<toks.length;i++){
    const m = /^([A-Z])(\d+)$/.exec(toks[i]);
    if(m){
      const L=m[1], d=m[2];
      applyDigitRole(S, L, d, contextAt(i));
      toks[i]=L; // keep surface short
    }
  }

  // Pass 3: left→right binary ops with next-operand weighting (asymmetric)
  function parseLetter(tok){ return /^[A-Z]$/.test(tok)? tok : null; }
  for(let i=0;i<toks.length;i++){
    const op=toks[i];
    if(['+','-','−','×','*','÷','/'].includes(op)){
      const nextL = parseLetter(toks[i+1]||'');
      if(nextL){
        // apply optional weight from previous letter if set
        const prevL = parseLetter(toks[i-1]||'');
        const w = (prevL && S[prevL] && S[prevL]._weightNext) ? S[prevL]._weightNext : 1;
        // Implement minimal channel effect per op on the next operand
        if(op==='+'){ S[nextL]=T.add(S[nextL], w); }
        else if(op==='-'||op==='−'){ S[nextL]=T.sub(S[nextL], w); }
        else if(op==='×'||op==='*'){ S[nextL]=T.mul(S[nextL], Math.max(2,w)); }
        else if(op==='÷'||op==='/'){ S[nextL]=T.div(S[nextL], Math.max(2,w)); }
      }
    }
  }

  const touched = lettersTouched(text);
  return { S, touched };
}

----------------------------------------------------------------
D) UPGRADE GEOMETRY PARSER FOR ROTATION/LATTICE/SCALE/LINES
----------------------------------------------------------------
FIND `applyGeomPremise(S0, text){ ... }` and REPLACE its body with:

{
  const S = cloneStore(S0);
  const touched = lettersTouched(text);

  // 1) Lattice: "<L> e east n north X"
  if(/\b(\d+)\s+east\s+(\d+)\s+north\b/i.test(text)){
    const m = /([A-Z])\s+(\d+)\s+east\s+(\d+)\s+north\s+([A-Z])/i.exec(text) ||
              /([A-Z])\s+(\d+)\s+west\s+(\d+)\s+south\s+([A-Z])/i.exec(text);
    if(m){
      const L = m[1], ex = parseInt(m[2],10), ny = parseInt(m[3],10);
      const east = /east/i.test(text)? ex : -ex;
      const north = /north/i.test(text)? ny : -ny;
      // allow digit role to override step if present
      const step = S[L]._step || 1;
      S[L].pos.x += east*step; S[L].pos.y += north*step;
    }
  }

  // 2) Project/reflect lines with arbitrary endpoints "line X,Y"
  let lineMatch = /line\s+([A-Z])\s*,\s*([A-Z])/i.exec(text);
  if(/\bproject\b/i.test(text) && lineMatch){
    const L1=lineMatch[1], L2=lineMatch[2];
    for(const L of touched){ if(L!==L1 && L!==L2){ S[L]=T.projectToLineUV(S[L], S[L1], S[L2]); } }
  }
  if(/\breflect\b/i.test(text) && lineMatch){
    const L1=lineMatch[1], L2=lineMatch[2];
    for(const L of touched){
      if(L===L1 || L===L2) continue;
      const proj = T.projectToLineUV(S[L], S[L1], S[L2]);
      const mx = 2*proj.pos.x - S[L].pos.x, my = 2*proj.pos.y - S[L].pos.y;
      S[L] = {...S[L], pos:{x:mx,y:my}, polarity:-S[L].polarity};
    }
  }

  // 3) Scale with ratio lock from digit role
  if(/\bscale(\d*)\b/i.test(text)){
    const m = /([A-Z]).*scale(\d*)\s+U\s+from\s+([A-Z])/i.exec(text);
    if(m){
      const B=m[1], ktxt=m[2], A=m[3];
      const ratio = (S[B]._ratio || SCALE_RATIO[parseInt(ktxt||'0',10)] || null);
      if(ratio){
        const [num,den]=ratio;
        // simple center-from scaling using ratio as magnitude
        const k = num/Math.max(1,den);
        S[B]=T.scaleFromCenter(S[B], k);
      }
    }
  }

  // 4) Rotations: explicit rotateθ or latent queue
  let rot = /rotate(\d+)/i.exec(text);
  if(rot){
    const deg = parseInt(rot[1],10)||0;
    for(const L of touched){ S[L]=T.rotate(S[L], deg); }
  } else {
    // latent rotation if any letter queued it
    for(const L of touched){
      if(S[L]._latentRot){ S[L]=T.rotate(S[L], S[L]._latentRot); S[L]._latentRot=0; }
    }
  }

  // 5) Cardinal/diagonal words
  if(/\bnorth\b/i.test(text)) for(const L of touched){ S[L]=T.north(S[L])}
  if(/\bsouth\b/i.test(text)) for(const L of touched){ S[L]=T.south(S[L])}
  if(/\beast\b/i.test(text))  for(const L of touched){ S[L]=T.east(S[L])}
  if(/\bwest\b/i.test(text))  for(const L of touched){ S[L]=T.west(S[L])}
  if(/\bnortheast\b/i.test(text)) for(const L of touched){ S[L]=T.north(T.east(S[L])) }
  if(/\bnorthwest\b/i.test(text)) for(const L of touched){ S[L]=T.north(T.west(S[L])) }
  if(/\bsoutheast\b/i.test(text)) for(const L of touched){ S[L]=T.south(T.east(S[L])) }
  if(/\bsouthwest\b/i.test(text)) for(const L of touched){ S[L]=T.south(T.west(S[L])) }

  return { S, touched };
}

----------------------------------------------------------------
E) ENFORCE ≤7 WORDS AND HARD NOVELTY IN GENERATORS
----------------------------------------------------------------
In both **GeomGen.generate(r)** and **ArithGen.generate(r)**, keep your `within7Words(txt)` check.

Add before returning a candidate:
  if(window.IW_Novelty && !IW_Novelty.isNovel(txt)) continue;
  if(window.IW_Novelty) IW_Novelty.record(txt);

(If IW_Novelty already exists, leave your implementation but ensure both text and structural signatures are checked.)

----------------------------------------------------------------
F) VARY LINE ENDPOINTS IN TEMPLATES WITHOUT EXTRA WORDS
----------------------------------------------------------------
In your geometric templates that used “line U,V”, replace the literal endpoints at generation time:

// helper near GeomGen:
function varyLineByDigitOrSalt(r){
  // fall back to salt if no explicit digit context
  const i = 1 + Math.floor(r()*24), j = 2 + Math.floor(r()*24);
  return [Phi(i), Phi(j)];
}

Then in templates:
const [L1,L2]=varyLineByDigitOrSalt(r);
return `${A} project ${S} to line ${L1},${L2}`;

and similarly for “reflect … across line …”.

----------------------------------------------------------------
G) PRECEDENCE (DOCUMENTED, NO NEW TOKENS)
----------------------------------------------------------------
Unary → digitRole → binary → geometric → predicate.
Ensure your parsers apply effects in that order.

----------------------------------------------------------------
H) VALIDATE WITH SHORT, DENSE EXAMPLES (≤7 WORDS)
----------------------------------------------------------------
- `√A × B3 ÷ inverted C`
- `A^2 − √B + inverted C`
- `A3 ÷ √B × inverted C`
- `A project B to line Q,T`
- `C reflect A across line H,M`
- `B scale4 U from A`
- `A 2 east 3 north B`

# END
