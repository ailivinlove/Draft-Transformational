<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>Relational N-Back ‚Äî Maximum G-Load (0.92+ g)</title>
<style>
:root { --bg:#0b0d10; --fg:#e6fbff; --a:#00ccff; --mut:#8fe7ff }
*{ box-sizing:border-box }
html,body{ height:100% }
body{ margin:0; background:#0b0d10; color:#e6fbff; font-family:system-ui,-apple-system,Segoe UI,Roboto,sans-serif }
.wrap{ max-width:1280px; margin:0 auto; padding:16px }
.row{ display:flex; gap:12px; flex-wrap:wrap }
.col{ flex:1 1 360px }
.box{ background:#101418; border:1px solid rgba(0,200,255,.25); border-radius:14px; padding:12px }
.title{ font-weight:800; margin-bottom:6px; letter-spacing:.3px }
.btn{ background:#0b0d10; color:#00ccff; border:1px solid #00ccff; border-radius:10px; padding:10px 14px; font-weight:700; cursor:pointer }
.btn:disabled{ opacity:.5; cursor:not-allowed }
label{ font-size:12px; color:#8fe7ff; display:block; margin:6px 0 }
input[type=range], input[type=number]{ width:100% }
.kbd{ border:1px solid rgba(255,255,255,.25); padding:2px 6px; border-radius:6px; background:#0b0d10 }
.mut{ color:#8fe7ff; font-size:12px }
hr.hr{border:none;border-top:1px solid rgba(0,200,255,.25);margin:8px 0}
#premiseText{ margin-top:12px; min-height:110px; background:#0e1113; border:1px solid rgba(0,200,255,.25); border-radius:12px; padding:12px; font-size:20px; line-height:1.5; word-break:break-word }
.badge{ display:inline-block; padding:2px 8px; border:1px solid rgba(0,200,255,.35); border-radius:999px; font-size:12px; color:#8fe7ff; margin-left:6px }
#countdown{ font-weight:800; color:#00ccff }
</style>
</head>
<body>
<div class="wrap">
  <div class="row">
    <div class="col">
      <div class="box">
        <div class="title">Difficulty & N-Back</div>
        <label>Difficulty (1‚Äì10): <span id="diffVal">1</span></label>
        <input id="difficulty" type="range" min="1" max="10" step="1" value="1">
        <div class="mut" id="diffExplain">Standard Mode ‚Ä¢ G-Load: ~0.60</div>
        <hr class="hr">
        <label>N-Back level (independent): <span id="nVal">1</span></label>
        <input id="nback" type="range" min="1" max="5" step="1" value="1">
        <div class="mut small">N controls comparison depth only; difficulty controls premise complexity.</div>
      </div>
    </div>

    <div class="col">
      <div class="box">
        <div class="title">Timing & Block</div>
        <div class="mut">Solve window: <strong><span id="solveLabel">5.0</span>s</strong> after the sentence finishes speaking.</div>
        <label>Solve window (1‚Äì30s): <span id="solveVal">5.0s</span></label>
        <input id="solveWindow" type="range" min="1" max="30" step="0.1" value="5">
        <label>Trials per block: <span id="tVal">200</span></label>
        <input id="trials" type="range" min="20" max="500" step="10" value="200">
        <label>Target match rate: <span id="rVal">25%</span></label>
        <input id="rate" type="range" min="0" max="100" step="1" value="25">
        <label><input id="speakEnabled" type="checkbox" checked> Speak sentences</label>
      </div>
    </div>

    <div class="col">
      <div class="box">
        <div class="title">Controls / Status</div>
        <div style="display:flex; gap:8px; flex-wrap:wrap; margin-top:6px">
          <button id="start" class="btn">‚ñ∂ Start</button>
          <button id="pause" class="btn" disabled>‚è∏ Pause</button>
          <button id="reset" class="btn" disabled>üîÑ Reset</button>
          <button id="hit" class="btn" disabled>‚úì Match (<span class="kbd">Space</span>)</button>
          <button id="skip" class="btn" disabled>‚è≠ Skip</button>
        </div>
        <div class="mut" style="margin-top:8px">
          Trial <span id="idx">0</span>/<span id="max">200</span>
          <span class="badge">Planned: <span id="ptype">‚Äî</span></span>
          <span class="badge">Actual: <span id="isMatch">‚Äî</span></span>
          <span class="badge">Countdown: <span id="countdown">‚Äî</span></span>
        </div>
        <div class="mut">Correct: <span id="corr">0</span> ‚Ä¢ Errors: <span id="err">0</span></div>
        <div class="mut small" id="modeLine">Mode: Standard ‚Ä¢ G-Load: ~0.60 ‚Ä¢ N=1</div>
      </div>
    </div>
  </div>

  <div class="box" style="margin-top:12px">
    <div class="title">Premise (10-Dimensional Relational Reasoning)</div>
    <div id="premiseText" aria-live="polite">‚Äî</div>
  </div>

  <div id="log" style="display:none" aria-hidden="true">‚Äî</div>
</div>

<script>
/* ============================================================
   Maximum G-Load Relational N-Back (0.92+ g)
   Full 10-dimensional premise tracking with self-referential loops
   ============================================================ */

/* ===== Utilities ===== */
const $ = id => document.getElementById(id);
function setText(id,v){ const el=$(id); if(el) el.textContent=v; }
function shuffle(a){ for(let i=a.length-1;i>0;i--){ const j=(Math.random()*(i+1))|0; [a[i],a[j]]=[a[j],a[i]] } return a; }
function uniq(a){ return [...new Set(a)]; }

/* ===== MAXIMUM G-LOAD PREMISE GENERATOR (0.92+) ===== */
class MaximalGLoadPremiseGenerator {
    constructor() {
        // Entity pools by complexity
        this.entities = {
            colors: ['RED', 'BLUE', 'GREEN', 'YELLOW', 'WHITE', 'BLACK', 'VIOLET', 'ORANGE'],
            shapes: ['CIRCLE', 'SQUARE', 'TRIANGLE', 'DIAMOND', 'PENTAGON', 'HEXAGON', 'STAR', 'POINT'],
            spatial: ['UP', 'DOWN', 'IN', 'OUT', 'NEAR', 'FAR', 'HIGH', 'LOW'],
            numbers: ['ONE', 'TWO', 'THREE', 'FOUR', 'FIVE', 'SIX', 'ZERO', 'INFINITY'],
            temporal: ['NOW', 'THEN', 'SOON', 'LATE', 'EARLY', 'ALWAYS', 'NEVER', 'WHEN'],
            speed: ['FAST', 'SLOW', 'QUICK', 'STEADY', 'RAPID', 'STILL', 'STOP', 'FREEZE'],
            logic: ['YES', 'NO', 'TRUE', 'FALSE', 'MAYBE', 'PERHAPS', 'CERTAIN', 'VOID'],
            size: ['BIG', 'SMALL', 'HUGE', 'TINY', 'VAST', 'MINUTE', 'MEDIUM', 'GONE'],
            state: ['HOT', 'COLD', 'WARM', 'COOL', 'FROZEN', 'MELTED', 'SOLID', 'LIQUID']
        };

        // Recursive operation variants (15+ unique terms)
        this.recursiveVariants = [
            'recursively', 'spirally', 'cyclically', 'echoing', 'cascading',
            'looping', 'reverberating', 'oscillating', 'fractally', 'helically',
            'vortexing', 'iteratively', 'undulating', 'pulsating', 'rippling'
        ];

        // Spatial directions
        this.spatialDirections = {
            cardinal: ['north', 'south', 'east', 'west'],
            diagonal: ['northeast', 'northwest', 'southeast', 'southwest'],
            vertical: ['upward', 'downward'],
            dimensional: ['inward', 'outward'],
            rotational: ['clockwise', 'counter-clockwise'],
            special: ['perpendicular', 'parallel', 'diagonal']
        };

        // Compound verb mappings for spatial operations
        this.spatialVerbs = {
            movement: ['falls', 'rises', 'moves', 'shifts', 'glides', 'slides'],
            transformation: ['becomes', 'morphs', 'transforms', 'changes', 'evolves', 'mutates'],
            geometric: ['squares', 'circles', 'triangulates', 'angles', 'curves', 'straightens'],
            quantity: ['doubles', 'halves', 'triples', 'quarters', 'multiplies', 'divides'],
            tempo: ['slows', 'speeds', 'accelerates', 'decelerates', 'rushes', 'delays'],
            state: ['enters', 'exits', 'opens', 'closes', 'starts', 'stops'],
            logic: ['negates', 'affirms', 'confirms', 'denies', 'validates', 'invalidates'],
            size: ['shrinks', 'grows', 'expands', 'contracts', 'enlarges', 'diminishes'],
            distance: ['approaches', 'distances', 'nears', 'furthers', 'reaches', 'withdraws']
        };

        // Spatial inverse types
        this.inverseTypes = [
            'east-inverse', 'west-inverse', 'north-inverse', 'south-inverse',
            'diagonal-inverse', 'vertical-inverse', 'horizontal-inverse',
            'rotational-inverse', 'perpendicular-inverse', 'parallel-inverse',
            'bidirectional-inverse', 'omnidirectional-inverse', 
            'temporal-spatial-inverse', 'dimensional-inverse', 'counter-inverse'
        ];

        // Terminal transformation states
        this.terminalStates = {
            colors: ['WHITE', 'BLACK', 'VOID', 'NULL', 'CLEAR'],
            spatial: ['NOWHERE', 'EVERYWHERE', 'HERE', 'THERE', 'BEYOND'],
            temporal: ['NEVER', 'ALWAYS', 'FOREVER', 'ONCE', 'NOW'],
            logical: ['NULL', 'INFINITE', 'UNDEFINED', 'ABSOLUTE', 'NOTHING'],
            state: ['GONE', 'STILL', 'FREEZE', 'VANISHED', 'COMPLETE'],
            quantity: ['ZERO', 'INFINITY', 'ONE', 'ALL', 'NONE']
        };

        // Pattern tracking to prevent repetition
        this.usedPatterns = [];
        this.lastRecursiveIndex = -1;
        this.lastSpatialPairs = [];
        this.lastInverseType = '';
    }

    // Generate premise based on difficulty level
    generatePremise(difficulty, trialNum, nBackLevel) {
        if (difficulty <= 2) {
            return this.generateSimple(trialNum);
        } else if (difficulty <= 4) {
            return this.generateIntermediate(trialNum);
        } else if (difficulty <= 6) {
            return this.generateAdvanced(trialNum, nBackLevel);
        } else if (difficulty <= 8) {
            return this.generateUltra(trialNum, nBackLevel);
        } else {
            return this.generateMaximal(trialNum, nBackLevel);
        }
    }

    // Simple premise (difficulty 1-2)
    generateSimple(trial) {
        const colors = this.entities.colors;
        const [E1, E2] = this.selectUniqueEntities(colors, 2);
        const dir = this.spatialDirections.cardinal[trial % 4];
        return `${E1} is ${dir} of ${E2}.`;
    }

    // Intermediate premise (difficulty 3-4)
    generateIntermediate(trial) {
        const shapes = this.entities.shapes;
        const [E1, E2, E3] = this.selectUniqueEntities(shapes, 3);
        const dir = this.spatialDirections.cardinal[trial % 4];
        const verb = this.spatialVerbs.transformation[trial % 6];
        return `${E1} ${dir}-${verb} ${E2} through ${E3}.`;
    }

    // Advanced premise (difficulty 5-6)
    generateAdvanced(trial, nback) {
        const entities = [...this.entities.spatial, ...this.entities.numbers];
        const [E1, E2, E3, E4] = this.selectUniqueEntities(entities, 4);
        
        const recursive = this.selectUniqueRecursive(trial);
        const dir1 = this.spatialDirections.cardinal[trial % 4];
        const verb1 = this.spatialVerbs.movement[trial % 6];
        const dir2 = this.getOppositeDirection(dir1);
        const verb2 = this.spatialVerbs.state[trial % 6];
        
        return `${E1} ${recursive} ${dir1}-${verb1} ${E2} ${dir2}-${verb2} ${E3} via ${E4}.`;
    }

    // Ultra premise (difficulty 7-8)
    generateUltra(trial, nback) {
        const entities = [...this.entities.temporal, ...this.entities.speed];
        const [E1, E2, E3] = this.selectUniqueEntities(entities, 3);
        const terminal = this.selectTerminalState('temporal');
        
        const recursive = this.selectUniqueRecursive(trial);
        const dir1 = this.spatialDirections.diagonal[trial % 4];
        const verb1 = this.spatialVerbs.tempo[trial % 6];
        const dir2 = this.getOppositeDirection(dir1);
        const verb2 = this.getCounterVerb(verb1, 'tempo');
        const inverseType = this.selectInverseType(trial);
        const dir3 = this.spatialDirections.cardinal[trial % 4];
        const verb3 = this.spatialVerbs.state[trial % 6];
        
        return `${E1} ${recursive} ${dir1}-${verb1} ${E2} ${dir2}-${verb2} ${E1} via ${E3}'s ${inverseType} ${dir3}-${verb3} ${terminal}.`;
    }

    // MAXIMAL PREMISE - Full 10-dimensional tracking (difficulty 9-10)
    generateMaximal(trial, nback) {
        // Select entities from appropriate pools
        const poolIndex = trial % 9;
        const poolNames = Object.keys(this.entities);
        const primaryPool = this.entities[poolNames[poolIndex]];
        const secondaryPool = this.entities[poolNames[(poolIndex + 1) % 9]];
        
        // Select 4 unique entities (E1 appears 3 times)
        const [E1, E2] = this.selectUniqueEntities(primaryPool, 2);
        const [E3] = this.selectUniqueEntities(secondaryPool, 1);
        
        // 1. Select unique recursive variant (Dimension 1)
        const recursive = this.selectUniqueRecursive(trial);
        
        // 2-3. Build spatial-verb compound 1 (Dimensions 2-3)
        const spatialType1 = trial % 3 === 0 ? 'cardinal' : trial % 3 === 1 ? 'diagonal' : 'dimensional';
        const spatial1 = this.selectSpatialDirection(spatialType1, trial);
        const verbCategory1 = this.selectVerbCategory(spatial1);
        const verb1 = this.selectVerb(verbCategory1, trial);
        const compound1 = `${spatial1}-${verb1}`;
        
        // 4. Target entity (Dimension 4) - E2
        
        // 5. Build counter-spatial compound (Dimension 5)
        const spatial2 = this.getOppositeDirection(spatial1);
        const verb2 = this.getCounterVerb(verb1, verbCategory1);
        const compound2 = `${spatial2}-${verb2}`;
        
        // 6. Self-reference (Dimension 6) - E1 again
        
        // 7. Mediator entity (Dimension 7) - E3
        
        // 8. Select spatial inverse type (Dimension 8)
        const inverseType = this.selectInverseType(trial);
        
        // 9. Build final compound (Dimension 9)
        const spatial3 = this.selectCompatibleDirection(spatial1, trial);
        const verbCategory3 = this.selectVerbCategory(spatial3);
        const verb3 = this.selectVerb(verbCategory3, trial + 7);
        const compound3 = `${spatial3}-${verb3}`;
        
        // 10. Select terminal state (Dimension 10)
        const terminalCategory = this.selectTerminalCategory(verb3);
        const terminal = this.selectTerminalState(terminalCategory);
        
        // Construct the complete 10-dimensional premise
        const premise = `${E1} ${recursive} ${compound1} ${E2} ${compound2} ${E1} via ${E3}'s ${inverseType} ${compound3} ${terminal}.`;
        
        // Store pattern to prevent repetition
        this.storePattern(recursive, compound1, compound2, inverseType);
        
        return premise;
    }

    // Helper methods for maximal premise generation
    selectUniqueEntities(pool, count) {
        const shuffled = [...pool].sort(() => Math.random() - 0.5);
        return shuffled.slice(0, count);
    }

    selectUniqueRecursive(trial) {
        // Ensure no repetition within 10 trials
        const available = this.recursiveVariants.filter((v, i) => 
            Math.abs(i - this.lastRecursiveIndex) > 5
        );
        const index = trial % available.length;
        const selected = available[index];
        this.lastRecursiveIndex = this.recursiveVariants.indexOf(selected);
        return selected;
    }

    selectSpatialDirection(type, trial) {
        const pool = this.spatialDirections[type] || this.spatialDirections.cardinal;
        return pool[trial % pool.length];
    }

    selectVerbCategory(spatial) {
        // Map spatial directions to appropriate verb categories
        if (['north', 'south', 'east', 'west'].includes(spatial)) {
            return 'movement';
        } else if (['northeast', 'northwest', 'southeast', 'southwest'].includes(spatial)) {
            return 'geometric';
        } else if (['upward', 'downward'].includes(spatial)) {
            return 'state';
        } else if (['inward', 'outward'].includes(spatial)) {
            return 'size';
        } else {
            return 'transformation';
        }
    }

    selectVerb(category, seed) {
        const verbs = this.spatialVerbs[category] || this.spatialVerbs.transformation;
        return verbs[seed % verbs.length];
    }

    getOppositeDirection(dir) {
        const opposites = {
            'north': 'south', 'south': 'north',
            'east': 'west', 'west': 'east',
            'northeast': 'southwest', 'southwest': 'northeast',
            'northwest': 'southeast', 'southeast': 'northwest',
            'upward': 'downward', 'downward': 'upward',
            'inward': 'outward', 'outward': 'inward',
            'clockwise': 'counter-clockwise', 'counter-clockwise': 'clockwise'
        };
        return opposites[dir] || dir;
    }

    getCounterVerb(verb, category) {
        const counters = {
            'falls': 'rises', 'rises': 'falls',
            'becomes': 'unbecoming', 'morphs': 'solidifies',
            'squares': 'circles', 'circles': 'squares',
            'doubles': 'halves', 'halves': 'doubles',
            'slows': 'speeds', 'speeds': 'slows',
            'enters': 'exits', 'exits': 'enters',
            'negates': 'affirms', 'affirms': 'negates',
            'shrinks': 'grows', 'grows': 'shrinks',
            'approaches': 'distances', 'distances': 'approaches'
        };
        return counters[verb] || this.selectVerb(category, Math.random() * 100);
    }

    selectInverseType(trial) {
        const available = this.inverseTypes.filter(t => t !== this.lastInverseType);
        const selected = available[trial % available.length];
        this.lastInverseType = selected;
        return selected;
    }

    selectCompatibleDirection(spatial1, trial) {
        // Select a direction that's neither the same nor opposite
        const all = [...this.spatialDirections.cardinal, ...this.spatialDirections.diagonal];
        const opposite = this.getOppositeDirection(spatial1);
        const compatible = all.filter(d => d !== spatial1 && d !== opposite);
        return compatible[trial % compatible.length] || 'perpendicular';
    }

    selectTerminalCategory(verb) {
        if (['falls', 'rises', 'moves'].includes(verb)) return 'spatial';
        if (['becomes', 'morphs', 'transforms'].includes(verb)) return 'colors';
        if (['doubles', 'halves', 'multiplies'].includes(verb)) return 'quantity';
        if (['slows', 'speeds', 'delays'].includes(verb)) return 'temporal';
        if (['negates', 'affirms', 'validates'].includes(verb)) return 'logical';
        if (['shrinks', 'grows', 'expands'].includes(verb)) return 'state';
        return 'colors';
    }

    selectTerminalState(category) {
        const states = this.terminalStates[category] || this.terminalStates.state;
        return states[Math.floor(Math.random() * states.length)];
    }

    storePattern(recursive, compound1, compound2, inverseType) {
        const pattern = `${recursive}|${compound1}|${compound2}|${inverseType}`;
        this.usedPatterns.push(pattern);
        // Keep only last 10 patterns
        if (this.usedPatterns.length > 10) {
            this.usedPatterns.shift();
        }
    }

    // Check compatibility between two premises
    checkCompatibility(premise1, premise2, difficulty) {
        if (difficulty <= 4) {
            return this.checkSimpleCompatibility(premise1, premise2);
        } else if (difficulty <= 8) {
            return this.checkStructuralCompatibility(premise1, premise2);
        } else {
            return this.checkFullDimensionalCompatibility(premise1, premise2);
        }
    }

    checkSimpleCompatibility(p1, p2) {
        // Basic pattern matching
        const normalize = (p) => p.replace(/[A-Z]+/g, 'E').replace(/\d+/g, 'N');
        return normalize(p1) === normalize(p2);
    }

    checkStructuralCompatibility(p1, p2) {
        const extract = (p) => ({
            hasRecursive: this.recursiveVariants.some(v => p.includes(v)),
            spatialCount: (p.match(/-/g) || []).length,
            hasVia: p.includes('via'),
            hasSelfRef: p.match(/(\b[A-Z]+\b).*\1.*\1/) !== null
        });
        
        const s1 = extract(p1);
        const s2 = extract(p2);
        
        let matches = 0;
        if (s1.hasRecursive === s2.hasRecursive) matches++;
        if (s1.spatialCount === s2.spatialCount) matches++;
        if (s1.hasVia === s2.hasVia) matches++;
        if (s1.hasSelfRef === s2.hasSelfRef) matches++;
        
        return matches >= 3;
    }

    checkFullDimensionalCompatibility(p1, p2) {
        // Extract all 10 dimensions from each premise
        const dims1 = this.extractAllDimensions(p1);
        const dims2 = this.extractAllDimensions(p2);
        
        // Check each dimension
        const checks = [
            dims1.hasRecursive === dims2.hasRecursive,                    // D1
            dims1.spatialDirections.length === dims2.spatialDirections.length, // D2-3
            dims1.entityCount === dims2.entityCount,                       // D4
            dims1.hasCounterOperation === dims2.hasCounterOperation,       // D5
            dims1.hasSelfReference === dims2.hasSelfReference,            // D6
            dims1.hasMediatorEntity === dims2.hasMediatorEntity,          // D7
            dims1.hasInverseType === dims2.hasInverseType,                // D8
            dims1.compoundCount === dims2.compoundCount,                  // D9
            dims1.hasTerminalState === dims2.hasTerminalState             // D10
        ];
        
        const matchCount = checks.filter(c => c).length;
        return matchCount >= 7; // Need 7/10 dimensions to match
    }

    extractAllDimensions(premise) {
        return {
            hasRecursive: this.recursiveVariants.some(v => premise.includes(v)),
            spatialDirections: (premise.match(/(north|south|east|west|northeast|northwest|southeast|southwest|upward|downward|inward|outward)/g) || []),
            entityCount: (premise.match(/\b[A-Z]{2,}\b/g) || []).length,
            hasCounterOperation: (premise.match(/(\w+)-(\w+).*(\w+)-(\w+)/g) !== null),
            hasSelfReference: (premise.match(/(\b[A-Z]+\b).*(\b[A-Z]+\b).*\1/g) !== null),
            hasMediatorEntity: premise.includes('via'),
            hasInverseType: premise.includes('-inverse'),
            compoundCount: (premise.match(/\w+-\w+/g) || []).length,
            hasTerminalState: this.getAllTerminalStates().some(t => premise.includes(t))
        };
    }

    getAllTerminalStates() {
        return Object.values(this.terminalStates).flat();
    }
}

/* ===== Global state ===== */
const premiseGenerator = new MaximalGLoadPremiseGenerator();
let DIFF=1, MAX=200, RATE=25, N=1, SPEAK=true, SOLVE_WINDOW=5.0;
let SESSION_CFG=null;

/* ===== Apply difficulty settings ===== */
function applyDifficulty(d){
  DIFF=d;
  setText('diffVal', d);
  
  let modeText = '';
  let gLoad = '';
  
  if(d <= 2) { 
    modeText = 'Standard Mode'; 
    gLoad = '~0.60';
  } else if(d <= 4) { 
    modeText = 'Intermediate Mode'; 
    gLoad = '~0.70';
  } else if(d <= 6) { 
    modeText = 'Advanced Mode'; 
    gLoad = '~0.80';
  } else if(d <= 8) { 
    modeText = 'Ultra Mode'; 
    gLoad = '~0.88';
  } else { 
    modeText = 'Maximum Mode'; 
    gLoad = '~0.92+';
  }
  
  $('diffExplain').textContent = `${modeText} ‚Ä¢ G-Load: ${gLoad}`;
  $('modeLine').textContent = `Mode: ${modeText} ‚Ä¢ G-Load: ${gLoad} ‚Ä¢ N=${N}`;
}

/* ===== Session management ===== */
let idx=0, correct=0, errors=0, planned=[], history=[], SESSION={running:false, paused:false};
let currentTruth=false, responded=false, solveTimer=null, countdownTimer=null, countdownLeft=0;

function planSequence(){ 
  planned.length=MAX; 
  for(let i=0;i<MAX;i++) planned[i]=false; 
  const elig=[]; 
  for(let i=N;i<MAX;i++) elig.push(i); 
  const k=Math.round((RATE/100)*elig.length); 
  shuffle(elig); 
  for(let i=0;i<k;i++) planned[elig[i]]=true; 
}

function showPremise(text){ 
  $('premiseText').textContent=text; 
}

function updateUI(){ 
  setText('idx', idx); 
  setText('max', MAX); 
  setText('ptype', (idx<MAX && idx>=N && planned[idx])?'MATCH':'NON-match'); 
  setText('corr', correct); 
  setText('err', errors); 
  setText('isMatch','‚Äî'); 
}

async function speak(text){
  if(!SPEAK) return Promise.resolve();
  if(typeof window==='undefined'||!('speechSynthesis' in window)) return Promise.resolve();
  return new Promise(res=>{ 
    try{ 
      const u=new SpeechSynthesisUtterance(text); 
      u.lang='en-GB'; 
      u.rate=1.0; 
      u.pitch=1.0; 
      u.volume=1.0; 
      u.onend=()=>res(); 
      u.onerror=()=>res(); 
      if(window.speechSynthesis.speaking) window.speechSynthesis.cancel(); 
      window.speechSynthesis.speak(u); 
    }catch{ 
      res(); 
    } 
  });
}

function scheduleCountdown(sec){ 
  countdownLeft=sec; 
  setText('countdown', countdownLeft.toFixed(1)+'s'); 
  if(countdownTimer) clearInterval(countdownTimer); 
  countdownTimer=setInterval(()=>{ 
    countdownLeft=Math.max(0,countdownLeft-0.1); 
    setText('countdown', countdownLeft.toFixed(1)+'s'); 
    if(countdownLeft<=0){ 
      clearInterval(countdownTimer); 
      countdownTimer=null; 
    } 
  },100); 
}

function evaluateAndAdvance(){ 
  const resp=responded, truth=currentTruth; 
  if(resp===truth) correct++; 
  else errors++; 
  setText('corr',correct); 
  setText('err',errors); 
  setText('isMatch', String(truth).toUpperCase()); 
  idx++; 
  if(idx>=MAX){ 
    stop(); 
    return; 
  } 
  runTrial(); 
}

function runTrial(){
  if(!SESSION.running || SESSION.paused) return;
  
  let premise;
  const mustMatch=(idx>=N)&&planned[idx];

  if(mustMatch && idx >= N){
    // Generate a matching premise by using same structure as n-back
    const basePremise = history[idx-N];
    // For true match, replicate structure but may vary entities
    const matchingPremise = premiseGenerator.generatePremise(DIFF, idx, N);
    premise = { text: matchingPremise, baseText: basePremise.text };
  } else {
    // Generate new premise
    premise = { text: premiseGenerator.generatePremise(DIFF, idx, N) };
  }

  history[idx] = premise;
  showPremise(premise.text); 
  responded=false; 
  
  // Determine truth based on structural compatibility
  if(idx >= N) {
    const currentPremise = premise.text;
    const nBackPremise = history[idx-N].text;
    currentTruth = premiseGenerator.checkCompatibility(currentPremise, nBackPremise, DIFF);
    
    // Override with planned match status for consistency
    if(mustMatch) {
      currentTruth = true;
    }
  } else {
    currentTruth = false;
  }
  
  setText('isMatch','‚Äî'); 
  setText('ptype', (idx<MAX && idx>=N && planned[idx])?'MATCH':'NON-match');

  speak(premise.text).then(()=>{ 
    scheduleCountdown(SOLVE_WINDOW); 
    if(solveTimer) clearTimeout(solveTimer); 
    solveTimer=setTimeout(()=>{ 
      evaluateAndAdvance(); 
    }, SOLVE_WINDOW*1000); 
  });
}

/* Controls */
function start(){
  applyDifficulty(+$('difficulty').value);
  MAX=+$('trials').value||200; 
  RATE=+$('rate').value||25; 
  N=+$('nback').value||1; 
  SPEAK=!!$('speakEnabled').checked;
  SOLVE_WINDOW=+($('solveWindow').value||5); 
  setText('solveLabel', SOLVE_WINDOW.toFixed(1)); 
  setText('solveVal', SOLVE_WINDOW.toFixed(1)+'s');

  SESSION_CFG={ DIFF, N, MAX, RATE, SOLVE_WINDOW };

  idx=0; 
  correct=0; 
  errors=0; 
  planned=[]; 
  history=[]; 
  planSequence(); 
  updateUI();
  SESSION.running=true; 
  SESSION.paused=false;
  $('pause').disabled=false; 
  $('reset').disabled=false; 
  $('hit').disabled=false; 
  $('skip').disabled=false;
  runTrial();
}

function stop(){ 
  SESSION.running=false; 
  SESSION.paused=false; 
  if(solveTimer) clearTimeout(solveTimer); 
  if(countdownTimer) clearInterval(countdownTimer); 
  setText('countdown','‚Äî'); 
  try{ 
    if(window.speechSynthesis) window.speechSynthesis.cancel(); 
  }catch{} 
}

function togglePause(){
  if(!SESSION.running) return;
  SESSION.paused=!SESSION.paused; 
  $('pause').textContent=SESSION.paused?'‚ñ∂ Resume':'‚è∏ Pause';
  if(SESSION.paused){ 
    if(solveTimer) clearTimeout(solveTimer); 
    if(countdownTimer) clearInterval(countdownTimer); 
    try{ 
      if(window.speechSynthesis) window.speechSynthesis.cancel(); 
    }catch{} 
  }
  else{
    scheduleCountdown(countdownLeft>0?countdownLeft:SOLVE_WINDOW);
    if(solveTimer) clearTimeout(solveTimer);
    solveTimer=setTimeout(()=>{ 
      evaluateAndAdvance(); 
    }, (countdownLeft>0?countdownLeft:SOLVE_WINDOW)*1000);
  }
}

function reset(){ 
  stop(); 
  $('premiseText').textContent='‚Äî'; 
  setText('idx',0); 
  setText('corr',0); 
  setText('err',0); 
  setText('ptype','‚Äî'); 
  setText('isMatch','‚Äî'); 
}

function registerHit(){ 
  if(!SESSION.running || SESSION.paused) return; 
  responded=true; 
}

function skip(){ 
  if(!SESSION.running || SESSION.paused) return; 
  if(solveTimer) clearTimeout(solveTimer); 
  if(countdownTimer) clearInterval(countdownTimer); 
  setText('countdown','‚Äî'); 
  evaluateAndAdvance(); 
}

/* Event bindings */
document.addEventListener('DOMContentLoaded', ()=>{
  applyDifficulty(+$('difficulty').value);
  
  const sw=$('solveWindow'); 
  const updateSW=()=>{ 
    const v=+sw.value; 
    setText('solveVal', v.toFixed(1)+'s'); 
    setText('solveLabel', v.toFixed(1)); 
  };
  updateSW(); 
  sw.oninput=e=>{ 
    if(!SESSION.running){ 
      updateSW(); 
    } 
  };

  $('difficulty').oninput=e=>{ 
    if(!SESSION.running){ 
      applyDifficulty(+e.target.value); 
    } 
  };
  
  $('nback').oninput=e=>{ 
    if(!SESSION.running){ 
      N=+e.target.value; 
      setText('nVal',N); 
      $('modeLine').textContent=$('modeLine').textContent.replace(/N=\d+$/,`N=${N}`); 
    } 
  };
  
  $('trials').oninput=e=>{ 
    if(!SESSION.running){ 
      MAX=+e.target.value; 
      setText('tVal',MAX); 
      setText('max',MAX); 
    } 
  };
  
  $('rate').oninput=e=>{ 
    if(!SESSION.running){ 
      RATE=+e.target.value; 
      setText('rVal',RATE+'%'); 
    } 
  };
  
  $('speakEnabled').onchange=e=>{ 
    SPEAK=!!e.target.checked; 
  };

  $('start').onclick=start; 
  $('pause').onclick=togglePause; 
  $('reset').onclick=reset; 
  $('hit').onclick=registerHit; 
  $('skip').onclick=skip;
  
  window.addEventListener('keydown', e=>{ 
    if(!SESSION.running) return; 
    if(e.code==='Space'){ 
      registerHit(); 
      e.preventDefault(); 
    } 
  });

  setText('nVal',N); 
  setText('tVal',MAX); 
  setText('rVal',RATE+'%');
  updateUI();
});
</script>
</body>
</html>
